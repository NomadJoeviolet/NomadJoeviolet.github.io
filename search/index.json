[{"content":"violet\n初步入门嵌入式开发后（假定已经会使用Keil和CubeMX进行开发），需要回头补充的基础以及提升，本指南只起到抛砖引玉的作用，对所需知识仅作精简的概述，主要在于帮助构建知识框架\nStep1 Keil+CubeMX工具链使用，HAL库使用，基本外设，基本开发常识 开发常识 该部分内容摘自队内文档部分内容\n开发环境 开发环境是软件开发过程中使用的软件和硬件的组合。通常情况下包括代码编辑器、编译器、调试工具和其他工具。开发环境帮助程序员编写、测试和调试代码的环境。\nIDE集成开发环境 集成开发环境是一种包含代码编辑器、编译器和调试器的综合性软件应用程序。IDE提供了方便编写、测试和调试程序的一体化界面。例如Keil，Clion，RTT Studio，CubeIDE等，本文中主要介绍Keil和Clion\n代码编辑器 代码编辑器是用于编写和修改代码的工具。它提供了基本的文本编辑功能，通常还包括语法高亮、代码格式化和错误检查等特性。比如我们所使用的VScode。一般来讲，对于一个项目，代码编辑器的选择通常是无所谓的\n关于单片机 单片机是一种微型计算机\n单片机（Microcontroller Unit，简称MCU）是一种将微处理器、存储器（包括程序存储器和数据存储器）、输入/输出接口和其他必要的功能模块集成在单个芯片上的微型计算机。它通常用于控制应用，可以在没有外部支持芯片的情况下独立运行。\n可以理解为单片机=微处理器+存储器+片上外设\n微处理器主要负责运算与控制逻辑的执行 存储器用于存储代码与数据 外设用于实现单片机的各种功能，例如定时器的定时，输入捕获功能，USART的串口通信功能 外设 单片机外设是指用于扩展单片机功能的辅助电路，包括内部外设和外部外设，能够与单片机协同工作，实现各种控制和处理任务\n例如定时器TIM和USART就是两个常见的单片机的片上外设 定时器可以用来实现定时，PWM调制，输入捕获等复杂功能 USART可以用来实现同步/异步的串口通信\n关于CubeMX CubeMX本质是代码生成器，图形化嵌入式开发辅助工具，用于快速配置STM32硬件资源并生成初始化代码框架，降低底层开发门槛，通过图形化界面，自动配置好用户所需的外设资源\nCubeMX生成的代码与HAL库强绑定\n关于HAL库 HAL库（Hardware Abstraction Layer，硬件抽象层）是ST公司为STM32微控制器设计的标准化硬件驱动库。作为嵌入式开发的关键基础设施，其实质是在硬件寄存器与用户应用之间构建了一个抽象接口层，彻底改变了传统嵌入式开发模式\n用户只需要关注HAL库提供的抽象层，而不用去关注抽象层之下的外设寄存器操作（这类设计思想很值得借鉴）\nHAL库提供统一的接口函数，例如HAL_xxxx_Transmit发送执行函数，xxxxCallback回调函数等\n开发范式变为： 应用层-\u0026gt;HAL库的抽象层-\u0026gt;具体硬件平台\nStep2 工具链的基础认知构建与工具链换新 对于整个工具链的理解，需要建立在对单片机（微型计算机）的基本工作方式有一定认知的基础上\n计算机的运行都是基于机器语言，我们编写的C语言程序，最后经过编译得到汇编代码，再经过汇编，得到二进制代码（已经是机器语言，但不可运行），最后经过链接，得到一个能运行于单片机上的可执行程序\n同时，还需要提一下的是，在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码，嵌入式开发的程序编译就是典型的交叉编译，用到的编译器用被称作交叉编译器\n目前队内的开发工具链是VScode/Clion+arm-none-eabi/armclag+CMake+Ninja+Ozone+cland/intellisence/Clion_LSP（编辑器+编译器+项目构建工具+项目构建的执行工具+烧录器+语法服务支持LSP），个人认为还是相当现代化且高度自定义的 下面简单讲解C语言到机器语言的定义以及编译过程\n从C语言到机器语言 机器语言 计算机（包括单片机）是不能直接识别我们所编写的C语言程序。它只能识别机器语言，而机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合\n汇编语言 汇编语言是一种用于微处理器、微控制器或其他可编程器件的低级语言。 在不同的设备中，汇编语言对应着不同的机器语言指令集。 一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。汇编语言的主体是汇编指令，汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，有一些架构的汇编指令中的加法指令00000011写成汇编语言就是 Add\n通俗的理解，汇编语言与对应计算机的架构相关，x86和arm结构的计算机分别有一套对应的汇编指令，而汇编语言是机器语言的文本化表达，例如 某一汇编指令中00000011可以简记为Add\n高级语言（C\u0026amp;C++\u0026amp;Java等）到机器语言 高级语言到汇编语言需要经过编译，例如 .c文件经过编译后，会生成 .s文件\n汇编语言到机器语言需要经过汇编，例如 .s文件经过汇编后，会生成 .o文件\n需要注意的是，高级语言具有迁移性，在不同架构的计算机上高级语言是不变的，但是汇编语言对于不同的架构会有不同的指令， 这就需要我们选择对应的编译器，例如stm32是arm架构的芯片，在C编译器的选择上需要 选择将C语言编译为arm架构汇编语言的编译器，例如armcc，armclang，arm-none-eabi等编译器\n所以在嵌入式开发中，需要根据单片机的架构选择对应的编译器\n编译原理 C语言编译原理涉及将C语言代码转换为机器语言的过程。这个过程包括预处理、编译、汇编和链接。编译器在这个过程中对源代码进行优化和转换，生成可执行文件，主要包括以下几个阶段：\n1. 预处理（Preprocessing） 作用：处理源代码文件中的预处理指令，如#include和#define 过程：替换宏定义，处理条件编译指令，包含头文件内容 工具：预处理器，如cpp、armclang\n2.编译（Compilation） 作用：将预处理后的源代码转换成汇编语言 过程：进行语法分析和语义分析，生成汇编代码 工具：编译器，如GCC、armclang\n3.汇编（Assembly） 作用：将汇编语言转换成机器语言，即目标代码（Object Code） 过程：汇编器将汇编指令转换为机器码 工具：汇编器，如as、armasm\n4.链接（Linking） 作用：将多个目标代码文件和库文件合并成一个单独的可执行文件\n过程： 解决外部符号引用，如函数和全局变量 合并不同模块中的相同段（如.text，.data） 生成最终的可执行文件或库文件 工具：链接器，如ld、armlink\n编译器与链接器 在整个编译过程中，编译器和链接器是核心组件，一般的环境配置也主要针对这二者展开：\n编译器（Compiler）：负责将源代码转换成汇编代码或直接生成目标代码。编译器的高级优化包括循环优化、常数传播、死码删除等 链接器（Linker）：负责将多个目标代码文件整合为一个可执行文件。链接器处理符号解析、重定位等任务\n多文件编程 简单来说就是头文件提供声明（就是给编译器说有某一个函数），源文件里面有函数的具体定义/实现\n多文件编译时会生成多个二进制文件，链接器会实现重定位后生成唯一的可执行文件（也就是最后实现 main.c能使用usart.c里面的函数）\n核心原理：分离式编译与链接 编译链接过程 关键步骤\n预处理阶段：处理#include指令，将头文件内容复制到源文件中 编译阶段：将每个.c文件独立编译为目标文件(.o) 链接阶段：合并所有目标文件，解析符号引用，生成可执行文件 作用域与链接属性 1. 存储类说明符 关键字 文件内作用 文件间作用 典型用途 static 私有 不可访问 内部辅助函数 extern 声明 可访问 全局变量声明 (默认) 定义 可访问 公共函数 2. 作用域控制示例 1 2 3 4 5 6 7 8 9 10 11 12 13 // module.c static int internal_counter = 0; // 文件内私有变量 //只有在该文件内的函数才可以访问 void public_function(void) { internal_counter++; } // header.h extern int global_variable; // 声明全局变量 //注意，声明不等于定义 // main.c int global_variable = 10; // 定义全局变量 符号解析与重定位 链接器核心任务 符号解析：将符号引用与符号定义关联 重定位：合并目标文件，调整地址引用 符号类型 符号类型 定义位置 引用位置 链接器处理 强符号 .text/.data 其他文件 必须唯一 弱符号 未初始化全局变量 其他文件 可覆盖 外部引用 未定义 当前文件 需在其它文件找到定义 符号解析示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // module.c //需要#include \u0026#34;helper.h\u0026#34; void helper(void); // 外部引用（未定义） void public_func(void) { helper(); } // helper.c void helper(void) { // 强符号定义 /* 实现 */ } // main.c extern void public_func(void); // 外部引用 int main() { public_func(); // 链接器解析到module.c中的定义 } 链接器符号表处理 扫描所有目标文件，收集符号定义 构建全局符号表： 强符号：记录地址 弱符号：标记为可选（weak关键字） 解析引用： 找到匹配的强符号 或使用弱符号（如果存在） 报告未解析引用错误 总结 在上述内容的基础上，我们可以知道，无论是Clion还是VScode，其本质都还是代码编辑器（虽然Clion内置了编译器），配环境实际上配的都还是对应的编译器（现代的编译器包含了编译器，汇编器，链接器等），如arm-none-eabi的gcc/g++或者是 arm-clang和arm-cc\nStep3 C\u0026amp;C++混合编程，CMake\u0026amp;Make\u0026amp;Ninja C\u0026amp;C++混合编程 核心原理 在于C与C++的符号修饰，如何利用extern \u0026quot;C\u0026quot;命令实现C call C++以及C++ call C\n【关于C和C++混合编程中编译和链接的问题】https://www.bilibili.com/video/BV1Zm4y1E7nm?vd_source=5a0790755035f26a67935abfbfcdfd5b\nextern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园 C++\u0026ndash;名字修饰_c++的函数名修饰是在哪个阶段进行的-CSDN博客 C/C++ 函数签名与名字修饰（符号修饰）-CSDN博客 C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n符号修饰 在C/C++中，一个程序要运行起来，需要经历以下几个阶段：预处理、编译、汇编、链接。\n名字修饰（Name Mangling）是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过一定算法，重新修饰为一个全局唯一的名称。\n由于C++和C的名字修饰规则不同（不同操作系统下的编译器的名字修饰方式也会不同），导致C++可以支持函数重载，而C不支持函数重载\n可以简单理解为，c++中支持函数重载，c语言不支持函数重载，这造成了c++和c语言的函数名解析不同（名字修饰/符号修饰）。c语言函数名就是函数名，c++的函数名是函数名+参数组合起来的。\nC与C++符号修饰的实例 extern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园 （直接copy自该博客）\n比如，函数void func(double a) 在C和C++中的编译阶段函数名称会被解析成什么呢？\n在C语言中，由于没有名称修饰，所以在编译时函数名称仍然是func，不会因为参数类型或数量而改变。\n在C++中，由于名称修饰的存在，函数名称在编译阶段会被编译器转换成一个包含函数原型信息的唯一标识符。通常会涉及函数返回类型、参数类型以及参数数量。以GCC(GNU Compiler Collection)为例，func(double a)会被转换成_Z4funcd ，这里：\n_Z：是GCC用来表示修饰名称的前缀 4：表示函数名称func的的字符数 d：是double类型的编码 因此，用c++的方式去寻找c语言的符号是无法寻找到的。extern \u0026quot;C\u0026quot;为何可以做到？\nextern \u0026quot;C\u0026quot;的作用就是修改了符号表的生成方式，将c++符号的生成方式换成了c的生成方式。\n即c库中生成的符号是c编译器的符号， 因此c语言可以直接链接。而c++程序需要使用extern \u0026quot;C\u0026quot;让编译器使用c的符号命名方式去进行链接，这样才能找到对应的符号。\nextern \u0026ldquo;C\u0026rdquo; C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n看这一篇就够了 看实例\ncpp调用c，cpp编译时会有C++的符号修饰，导致链接C库的函数找不到，需要用extern \u0026ldquo;C\u0026quot;告诉g++编译器以C语言的风格进行编译 c调用cpp（不涉及C++的类和成员函数），设计一个C的接口，接口的实现在cpp中，接口函数内部去使用C++的特性 c中调用c++成员函数，需要一个接口函数 CMake这一块 CMake是一个C/C++项目构建工具 根据CMakeLists.txt来构建makefile/ninja文件，再根据makefile/ninja文件来编译C和C++文件并生成可执行文件\n只需要理解 在命令行使用g++ 进行多文件编译时，每次输入都需要输入一大堆的文件，非常麻烦 使用CMake+make/ninja进行简化操作即可（个人认为的CMake的一个核心思想（极简化理解））\n层级关系\n开发者层：编写CMakeLists.txt定义构建规则 生成器层：CMake解析配置，生成底层构建文件 执行器层：Make/Ninja执行具体构建命令 工具链层：编译器(如gcc)、链接器等实际执行编译 cmake cmake是一个生成 .ninja 和 .makefile 的工具。cmake只需要用户通过对源码文件的简单描述（就是CMakeLists.txt文件），就能自动生成一个project的makefile文件或者ninja文件，然后就可以通过ninja或者make进行启动编译了，很多IDE都在用cmake作为项目管理工具。\nmake与ninja make功能强大，可以给人看，ninja启动速度快，项目构建速度快，但不是给人看的\n可以认为两者同级。\nStep4 C++提升\u0026amp;设计模式 这一节也是本人极其欠缺的，目前正在恶补\nC++的提升推荐C\u0026amp;C++ 系统学习（自荐这一块儿）\n设计模式推荐：暂无\nC++提升 内存对齐 一文轻松理解内存对齐 - 知乎 这里仅以结构体的内存对齐为例，不提供具体例子，具体例子详见上面的博客\n结构体（struct）对齐 规则 1：成员地址 = min(自身对齐值, 有效对齐值) 的倍数\n规则 2：结构体总大小 = 最大成员对齐值的整数倍\n规则 3：成员排列顺序影响最终大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #pragma pack(1)//设置默认对齐数为1 struct S1 { char c1; int i; char c2; }; #pragma pack()//取消设置的默认对齐数，还原为默认 int main() { //输出的结果是什么？ printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct S1)); return 0; } 1 2 3 4 5 6 7 #pragma pack(push, 1)//设置默认对齐数为1 struct MyStruct { char a; int b; double c; }; #pragma pack(pop)//取消设置的默认对齐数，还原为默认 1 2 3 4 5 struct MyStruct { char a; int b; double c; } __attribute__((packed)); 深拷贝与浅拷贝 1. 浅拷贝（Shallow Copy） 原理：仅复制对象的成员值（包括指针的值），不复制指针指向的实际资源。\n结果：原对象和拷贝对象的指针成员指向同一块内存地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Shallow { public: int* data; Shallow(int d) { data = new int(d); // 分配堆内存 } // 编译器生成的默认拷贝构造函数（浅拷贝） Shallow(const Shallow\u0026amp; other) : data(other.data) {} ~Shallow() { delete data; } }; // 使用示例 Shallow obj1(10); Shallow obj2 = obj1; // 浅拷贝：obj2.data 指向 obj1.data 的内存 *obj1.data = 20; // 修改 obj1 cout \u0026lt;\u0026lt; *obj2.data; // 输出 20（obj2 也被修改） // main结束时：obj2 和 obj1 会先后调用析构函数 // 导致同一内存被 delete 两次 → 程序崩溃！ 浅拷贝的核心问题： 悬空指针：一个对象释放资源后，另一个对象的指针失效 重复释放：多个对象尝试释放同一块内存 → 崩溃 数据篡改：通过一个对象修改数据会影响其他对象 2. 深拷贝（Deep Copy） 主要用于拷贝构造函数，赋值运算符 原理：不仅复制对象成员，还复制指针指向的资源。\n结果：原对象和拷贝对象拥有完全独立的资源副本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Deep { public: int* data; Deep(int d) { data = new int(d); } // 自定义拷贝构造函数（深拷贝） Deep(const Deep\u0026amp; other) { data = new int(*other.data); // 关键：分配新内存并复制值 } // 深拷贝赋值运算符 Deep\u0026amp; operator=(const Deep\u0026amp; other) { if (this != \u0026amp;other) { // 防止自赋值 delete data; // 释放原有资源 data = new int(*other.data); // 创建新副本 } return *this; } ~Deep() { delete data; } }; // 使用示例 Deep obj1(10); Deep obj2 = obj1; // 深拷贝：obj2 拥有独立的内存副本 *obj1.data = 20; // 修改 obj1 cout \u0026lt;\u0026lt; *obj2.data; // 输出 10（obj2 不受影响） // 析构时各自释放独立内存 → 安全 深拷贝的核心优势： 资源独立：每个对象拥有自己的资源副本 安全析构：不会发生重复释放 数据隔离：修改一个对象不影响其他对象 构造函数\u0026amp;拷贝构造函数\u0026amp;赋值运算符 大疆C++一面：C++什么时候生成默认拷贝构造函数？\n1.构造函数 用于初始化对象的特殊成员函数，与类同名，无返回值\n可重载，支持默认参数 若未显式定义，编译器生成默认构造函数 对象创建时自动调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ```cpp class Point { private: int x, y; public: // 1. 默认构造函数 Point() : x(0), y(0) {} // 2. 带参数构造函数 Point(int x_val, int y_val) : x(x_val), y(y_val) {} }; // 使用 Point p1; // 调用默认构造函数 Point p2(3, 4); // 调用带参数构造函数 2.拷贝构造函数 用已有对象初始化新对象时调用的特殊构造函数，注意与赋值运算符区分\n参数为同类对象的 const 引用 若未显式定义，编译器生成默认拷贝构造函数（浅拷贝） 涉及动态内存时必须显式定义（深拷贝） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class String { private: char* data; public: // 普通构造函数 String(const char* str) { data = new char[strlen(str) + 1]; strcpy(data, str); } // 拷贝构造函数（深拷贝） String(const String\u0026amp; other) { //不需要提前处理data，这是在构造是调用的 data = new char[strlen(other.data) + 1]; strcpy(data, other.data); } // 禁用拷贝构造函数（C++11） // String(const String\u0026amp;) = delete; ~String() { delete[] data; } }; // 使用 String s1(\u0026#34;hello\u0026#34;); String s2(s1); // 调用拷贝构造函数 需要注意的是，不用再拷贝构造函数中先判断是否删除data的动态内存，因为拷贝构造函数本质还是一个构造函数，初始化时调用\n3.赋值运算符 当类中包含指针或需要深拷贝的数据成员时，使用默认的赋值运算符可能会导致问题，如内存泄漏或重复释放内存。因此，在这些情况下，需要显式地重载赋值运算符。\n注意赋值运算符在内存管理上的细节\n避免自赋值 赋值前先回收，避免内存泄漏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class ClassA { public: ClassA() {} ClassA(const char* pszInputStr) { pszTestStr = new char[strlen(pszInputStr) + 1]; strncpy(pszTestStr, pszInputStr, strlen(pszInputStr) + 1); } virtual ~ClassA() { delete pszTestStr; } // 赋值运算符重载函数 ClassA\u0026amp; operator=(const ClassA\u0026amp; cls) { // 避免自赋值 if (this != \u0026amp;cls) { // 避免内存泄露 if (pszTestStr != NULL) { delete pszTestStr; pszTestStr = NULL; } pszTestStr = new char[strlen(cls.pszTestStr) + 1]; strncpy(pszTestStr, cls.pszTestStr, strlen(cls.pszTestStr) + 1); } return *this; } public: char* pszTestStr; }; int main() { ClassA obj1(\u0026#34;liitdar\u0026#34;); ClassA obj2; obj2 = obj1; cout \u0026lt;\u0026lt; \u0026#34;obj2.pszTestStr is: \u0026#34; \u0026lt;\u0026lt; obj2.pszTestStr \u0026lt;\u0026lt; endl; return 0; } 模板(函数模板\u0026amp;类模板) 函数模板生成的实例化成为模板函数，类模板和模板类的定义同理\n函数模板 定义：通用函数定义，支持多种数据类型，编译器根据实际类型（隐式实例化）或者显式实例化生成具体函数 特点：\n用 template 关键字声明 可显式或隐式实例化 支持函数重载和特化 模板的定义（实现），还是模板的全特化，都建议放在头文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 1. 基本函数模板 template\u0026lt;typename T\u0026gt; T max(T a, T b) { return a \u0026gt; b ? a : b; } // 2. 函数模板特化（针对特定类型） template\u0026lt;\u0026gt; const char* max\u0026lt;const char*\u0026gt;(const char* a, const char* b) { return strcmp(a, b) \u0026gt; 0 ? a : b; } // 使用 int i = max(3, 5); // 隐式实例化int版本 const char* s = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;); // 调用特化版本 类模板 定义：通用类定义，成员变量和函数可使用模板参数类型。\n特点：\n类内成员函数可在类内定义（默认内联） 或类外定义 支持全特化和部分特化 实例化时需指定具体类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 1. 基本类模板 template\u0026lt;typename T, int Size\u0026gt; class Array { private: T data[Size]; public: Array() {} T\u0026amp; operator[](int index) { return data[index]; } int getSize() const { return Size; } }; // 2. 类模板特化（针对bool类型优化） template\u0026lt;int Size\u0026gt; class Array\u0026lt;bool, Size\u0026gt; { private: unsigned char data[(Size + 7) / 8]; // 位压缩存储 public: bool get(int index) const { return (data[index / 8] \u0026gt;\u0026gt; (index % 8)) \u0026amp; 1; } }; // 使用 Array\u0026lt;int, 10\u0026gt; intArray; // 实例化int类型数组 Array\u0026lt;bool, 100\u0026gt; boolArray; // 使用特化版本 设计模式 To be continued\nStep5 arm-cortex-M学习\u0026amp;启动文件与链接器脚本 在对上面的抽象层级有一定了解后，还需要将上述偏软件的抽象层与具体的硬件相连接，建立软硬结合的认知需要有一定微机原理的知识\n自荐一下笔者的博客 从CPU架构到操作系统实现\ncortex-M 架构特性 Cortex-M 系列作为微控制器内核，采用哈佛架构（指令与数据独立存储但共享内存空间），具备低功耗、高性能、中断易用性强、代码密度高等优势，支持嵌入式操作系统运行。其内核演变包含 Cortex-M0/M3/M4 等多个型号，其中 M3/M4 集成 3 级流水线（取指 - 译码 - 执行），M4F 额外支持浮点运算单元\n核心组件包括：\nNVIC（嵌套向量中断控制器）：管理中断响应，支持多级中断优先级。 MPU（内存保护单元）：实现内存访问权限控制，保障系统安全。 调试接口：支持 JTAG 或 Serial Wire 调试，搭配嵌入式跟踪模块（ETM）实现代码跟踪。 指令集：主要支持 Thumb/Thumb2 指令集（16 位 + 32 位混合），兼顾代码密度与执行效率，属于 RISC 架构（精简指令系统），每条指令仅完成单一操作，硬件实现简单高效。 内存分布规则 Cortex-M 芯片内存分为 FLASH和 RAM两大区域，具体分布由硬件特性和链接脚本共同定义，以 STM32F103C8Tx（64K FLASH、20K RAM）为例：\n内存类型 起始地址 大小 权限 存储内容 FLASH 0x8000000 64K 可读可执行 中断向量表、.text 代码段、.rodata 只读常量段 RAM 0x20000000 20K 可读可写 .data 初始化数据段、.bss 未初始化数据段、堆、栈 内存段特性： .isr_vector：位于 FLASH 起始地址，存储栈顶地址和中断 / 异常处理函数地址，是复位后内核首个访问的区域。 .text：存放可执行代码（函数实现），包括用户代码和启动文件逻辑。 .rodata：存储只读常量（如 const 变量、字符串字面量），节省 RAM 空间。 .data：存放已初始化的全局 / 静态变量，编译时初始值存于 FLASH，运行时复制到 RAM。 .bss：存放未初始化的全局 / 静态变量，运行时由启动文件清零，无需占用 FLASH 空间。 堆 / 栈：堆从低地址向上生长（供 malloc 使用），栈从高地址向下生长（供函数调用、局部变量使用），由链接脚本预留空间。 启动文件与启动原理 启动原理 硬件复位：内核读取 FLASH 起始地址的中断向量表，初始化 MSP（栈顶地址），将 PC 指向Reset_Handler。 执行 Reset_Handler：完成时钟配置、内存段初始化（.data 复制、.bss 清零）。 进入用户代码：跳转至main函数，启动流程结束，正式运行应用逻辑。 中断响应：运行中触发中断时，内核从向量表查找对应处理函数地址，执行后返回断点。 启动模式 STM32F103 支持 3 种启动模式，由 BOOT0 和 BOOT1 引脚电平决定：\nBOOT0=0：主 FLASH 启动（默认模式），从用户代码区启动。 BOOT0=1、BOOT1=0：系统内存启动，从芯片出厂固化的 Bootloader 启动。 BOOT0=1、BOOT1=1：嵌入式 SRAM 启动，从 RAM 加载代码（用于调试）。 启动文件 启动文件（如startup_stm32f103xb.s）是汇编语言编写的底层程序，作为 \u0026ldquo;硬件到软件的桥梁\u0026rdquo;，负责衔接硬件复位与用户main函数，核心功能包括硬件初始化、内存初始化、中断系统准备和引导用户代码\n启动文件结构拆解 （1）汇编环境配置 指定处理器架构、指令集和浮点模式，确保汇编代码与硬件兼容，例如：\n1 2 3 4 .syntax unified ; 兼容ARM与Thumb指令集 .cpu cortex-m3 ; 目标内核为Cortex-M3 .fpu softvfp ; 软件模拟浮点运算（无硬件FPU） .thumb ; 启用Thumb指令集 （2）关键符号声明 引用链接器脚本定义的内存地址符号，建立启动文件与内存布局的关联，例如：\n1 2 3 4 5 .word _sidata ; .data段在FLASH的加载地址 .word _sdata ; .data段在RAM的运行起始地址 .word _edata ; .data段在RAM的运行结束地址 .word _sbss ; .bss段在RAM的起始地址 .word _ebss ; .bss段在RAM的结束地址 （3）复位处理函数（Reset_Handler） 复位后执行的核心逻辑，是启动流程的入口，分为 5 个关键步骤：\n系统时钟初始化：调用SystemInit函数配置 HSE/PLL，将时钟从 8MHz HSI 提升至 72MHz .data 段复制：从 FLASH 的_sidata地址复制初始值到 RAM 的_sdata至_edata区域 .bss 段清零：将 RAM 中_sbss至_ebss区域全部置 0，符合 C 语言标准 C++ 静态构造函数初始化：调用__libc_init_array，执行全局对象构造（兼容 C++ 项目） 跳转至 main 函数：完成底层初始化后，将程序控制权交给用户代码 （4）中断向量表（g_pfnVectors） 存储所有异常 / 中断的处理函数地址，位于 FLASH 起始地址，核心特性包括：\n第 0 个元素为栈顶地址（_estack），用于初始化主栈指针（MSP） 第 1 个元素为Reset_Handler地址，是复位后程序计数器（PC）的初始指向 向量表顺序隐含中断优先级，靠前元素对应优先级更高（如硬 fault 优先级高于 SysTick） （5）默认中断处理函数（Default_Handler） 为未自定义的中断提供 \u0026ldquo;兜底\u0026rdquo; 逻辑，通过无限循环防止程序跑飞，同时支持弱别名机制（.weak），允许用户在 C 代码中重定义中断函数覆盖默认逻辑\n链接器脚本 链接脚本（.ld）是链接器的配置文件，本质是告知链接器芯片内存布局、代码 / 数据的段分配规则、全局符号定义和内存合法性检查，是生成可执行文件（.elf/.hex）的关键，没有它链接器无法确定 \u0026ldquo;代码放哪里、变量放哪里\u0026rdquo;\n（1）入口点与栈顶定义 指定程序入口和栈堆大小，例如：\n1 2 3 4 ENTRY(Reset_Handler) ; 程序入口为Reset_Handler _estack = ORIGIN(RAM) + LENGTH(RAM); 栈顶地址=RAM起始+RAM大小 _Min_Heap_Size = 0x200; 最小堆大小（512字节） _Min_Stack_Size = 0xF00; 最小栈大小（3840字节） （2）内存区域定义（MEMORY 块） 描述 FLASH 和 RAM 的物理属性，例如：\n1 2 3 4 5 MEMORY { RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 20K ; RAM：可读可写可执行 FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 64K ; FLASH：可读可执行 } （3）段分配规则（SECTIONS 块） 定义编译生成的段与物理内存的映射关系，核心段包括：\n.isr_vector：分配到 FLASH 起始地址，用KEEP关键字防止被优化删除。 .text：存放代码段，定义_etext标记结束地址。 .rodata：存放只读常量，分配到 FLASH。 .data：运行地址在 RAM，加载地址在 FLASH，定义_sidata（加载地址）、_sdata（运行起始）、_edata（运行结束）。 .bss：分配到 RAM，定义_sbss（起始）、_ebss（结束）。 ._user_heap_stack：预留堆和栈空间，检查 RAM 容量是否充足。 /DISCARD/：丢弃无用段（如标准库冗余代码），减小文件大小。 链接脚本与启动文件的协同关系 启动文件与链接脚本通过全局符号和段分配紧密耦合，二者协作关系如下：\n协作维度 启动文件角色 链接脚本角色 内存地址提供 引用_sdata、_ebss等符号 计算并定义内存地址符号 段分配依据 将代码 / 数据放入指定段（如.text） 规定段的存储位置（如 FLASH/RAM） 程序入口指定 实现Reset_Handler函数 通过ENTRY指定入口为Reset_Handler 内存合法性检查 依赖符号确保内存访问不越界 检查堆 / 栈 / 数据段总大小是否超过 RAM 容量 架构→内存→链接脚本：Cortex-M 的哈佛架构决定内存分为 FLASH 和 RAM，链接脚本根据硬件内存参数（起始地址、大小）定义存储规则。 链接脚本→启动文件：链接脚本提供内存地址符号（如_sdata），启动文件依赖这些符号完成.data 复制、.bss 清零等初始化操作。 启动文件→架构：启动文件根据 Cortex-M 内核特性（如向量表位置、栈初始化要求）实现底层逻辑，最终引导程序进入用户代码。 待续 ","date":"2025-09-17T23:37:07+08:00","permalink":"https://NomadJoeviolet.github.io/p/%E7%94%B5%E6%8E%A7%E6%88%90%E9%95%BF%E6%8C%87%E5%8D%97/","title":"电控成长指南"},{"content":"基于 南科大 于仕琪老师的课程学习笔记 【快速学习C和C++，基础语法和优化策略，学了不再怕指针(南科大计算机系原版)】https://www.bilibili.com/video/BV1Vf4y1P7pq?vd_source=5a0790755035f26a67935abfbfcdfd5b\n推荐文章 C++ 如何进阶？如何准备 C++ 面试？ - 知乎\n程序基本常识 编译与链接 C语言编译原理涉及将C语言代码转换为机器语言的过程。这个过程包括预处理、编译、汇编和链接。编译器在这个过程中对源代码进行优化和转换，生成可执行文件，主要包括以下几个阶段：\n1. 预处理（Preprocessing） 作用：处理源代码文件中的预处理指令，如#include和#define\n过程：替换宏定义，处理条件编译指令，包含头文件内容\n工具：预处理器，如cpp、armclang\n2.编译（Compilation） 作用：将预处理后的源代码转换成汇编语言\n过程：进行语法分析和语义分析，生成汇编代码\n工具：编译器，如GCC、armclang\n3.汇编（Assembly） 作用：将汇编语言转换成机器语言，即目标代码（Object Code）\n过程：汇编器将汇编指令转换为机器码\n工具：汇编器，如as、armasm\n4.链接（Linking） 作用：将多个目标代码文件和库文件合并成一个单独的可执行文件\n过程：\n解决外部符号引用，如函数和全局变量\n合并不同模块中的相同段（如.text，.data）\n生成最终的可执行文件或库文件\n工具：链接器，如ld、armlink\n编译器与链接器 在整个编译过程中，编译器和链接器是核心组件，一般的环境配置也主要针对这二者展开：\n编译器（Compiler）：负责将源代码转换成汇编代码或直接生成目标代码。编译器的高级优化包括循环优化、常数传播、死码删除等\n链接器（Linker）：负责将多个目标代码文件整合为一个可执行文件。链接器处理符号解析、重定位等任务\n错误 编译错误，链接错误，运行错误\n预处理与宏 预处理，对宏定义进行替换 宏就是字符替换\n1 #define PI 3.1415926 初始化 c++11开始支持的初始化{}和()\n1 2 3 4 int test{};//初始化为0，c++11支持，c++98不支持 int man();//初始化为0，c++11支持，c++98不支持 int wow[]{1,2,3};//初始化，c++11支持，c++98不支持 int test_man[] = {0,1,2};//初始化，c++11支持，c++98支持 Data-Types-and-Arithmetic-Operators integer-numbers int 注意在不同平台上，int，short int，long int，long long的定义是不同的\nsizeof() sizeof是一个操作符，不是函数\n1 2 3 int i ; cout \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt; sizeof(i) \u0026lt;\u0026lt; endl ; char char本质上是一个8位的整数，可以用有符合和无符号修饰符修饰\n1 2 3 char CH ; unsigned char UCH ; signed SCH ; 注意char在不同平台上不一定是signed char，有可能是unsigned char 一般char是int8_t\nbool bool数据类型，1byte而不是1bit，同时这是c++里的数据类型\nc语言中需要#include \u0026lt;stdbool.h\u0026gt;来引入bool数据类型，或者有以下代码来使用bool\n1 2 3 typedef char bool; #define true 1 #define false 0 注意给bool类型数据赋值，只要不是0，就都是1\n1 2 bool test = -256 ; cout \u0026lt;\u0026lt; test ; 输出test，会发现test是1\ncstdint c++11之后引入\u0026lt;ctsdint\u0026gt;\n1 2 3 4 5 6 7 8 int8_t int16_t int32_t int64_t uint8_t uint16_t uint32_t uint64_t 以及一些宏\n1 2 3 4 5 6 7 8 INT8_MIN INT16_MIN INT32_MIN INT64_MIN INT8_MAX INT16_MAX INT32_MAX INT64_MAX floating-point-numbers float 单精度浮点数，float类型的数据一定会带有误差 32bits\n1 2 3 4 5 6 7 int main() { float f1 = 1.2f ; float f2 = f1*1000000000000000 ;//1e15 cout \u0026lt;\u0026lt; std::fixed\u0026lt;\u0026lt;std::steprecision(15)\u0026lt;\u0026lt; f1 \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt; std::fixed\u0026lt;\u0026lt;std::steprecision(15)\u0026lt;\u0026lt; f2 \u0026lt;\u0026lt; endl ; return 0 ; } 输出结果\n1 2 1.200000047683716 1200000038076416.000000000000000 float类型数的规格，详见IEEE规定 1 2 3 4 5 6 7 8 9 10 int main() { float f1 = 2.34E+10f; float f2 = f1+10;//but f2=f1 cout.setf(ios_base::fixed,ios_base::floatfield);//fixed-point cout \u0026lt;\u0026lt; \u0026#34;f1=\u0026#34; \u0026lt;\u0026lt; f1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;f2=\u0026#34; \u0026lt;\u0026lt; f2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;f1-f2\u0026#34; \u0026lt;\u0026lt; f1-f2 \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;(f1-f2==0)=\u0026#34;\u0026lt;\u0026lt;(f1-f2==0) \u0026lt;\u0026lt; endl; return 0; } 输出结果\n1 2 3 4 f1=23399999488.000000 f2=23399999488.000000 f1-f2=0.000000 (f1-f2==0)=1 原因是float类型本质是在采样点，该例子中中+10的采样点间隔不够，数值不发生变化 浮点数是取一些间隔值\n关于.f/.F 在 C++ 中，1.0f 和 1.0F 都表示单精度浮点数（float 类型），两者在功能上是完全等价的，唯一的区别是字母 f 的大小写不同。\n说明： 1.0f 和 1.0F 都表示 float 类型的字面量，值为 1.0。 如果不加后缀 f 或 F，例如 1.0，则默认是 double 类型（双精度浮点数）。 类似地，1.0L 或 1.0l 表示 long double 类型（扩展精度浮点数）。 示例： 1 2 3 4 float a = 1.0f; // float 类型 float b = 1.0F; // 同上，float 类型 double c = 1.0; // double 类型 long double d = 1.0L; // long double 类型 为什么有两种写法？ C++ 允许 f 和 F 两种写法，主要是为了代码风格的一致性。例如：\n某些编码规范可能推荐使用大写 F 以增强可读性（避免与数字 1 混淆）。 而小写 f 更常见，因为更简洁。 总结： 1.0f 和 1.0F 在 C++ 中完全等价，选择哪一种取决于个人或团队的代码风格偏好。\n浮点数不要直接相等 浮点数都是近似，不是精确的数值，所以不适合用==判断相等\n1 2 if(f1==f2)//bad if(fabs(f1-f2)\u0026lt;FLT_EPSILON)//good inf and nan 1 2 float f1 = 2.0f / 0.0f ; float f2 = 0.0f / 0.0f ; +/- inf：infinity ( Exponent=11111111 , fraction=0 ) nan：not a number ( Exponent=11111111 , fraction!=0 ) 如果计算过程中出现了inf或者nan,后续的计算会产生问题\ndouble 双精度浮点数，64bits\nlong double 如果系统支持，128bits 否则，64bits\nArithmetic Operators 算数运算，对计算的实现要有所理解，才能避免出现一些错误\nConstant-numbers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 95//十进制 0137//八进制 0x5F//十六进制 95//int 95u//unsigned int 95l//long 95lu//unsianed long 95ul//unsianed long 3.14//3.14 6.02e23//6.02*10^23 1.6e-19//1.6*10^-19 6.02e23L//long double 6.02e23f//float 6.02e23//double const类型限定符 在变量前加了const限定符，变量的值就不可以被修改了\n1 2 const float PI = 3.1415926f ; PI += 1 ;//error! 运算符优先级\n1 2 3 4 5 a++ ++a * / + - \u0026lt;\u0026lt; \u0026gt;\u0026gt; 赋值操作\n1 2 3 4 5 6 7 8 a = b a += b a -= b a *= b a \u0026amp;= b a |= b a \u0026lt;\u0026lt;= b a \u0026gt;\u0026gt;= b 自增自减\n1 2 3 4 i ++ ++ i i -- -- i 1 2 3 int i = 3 ; int b = i ++ ;//先赋值再++ int c = ++ i ;//先++再赋值 类型转换 浮点类型转整型，会直接舍弃小数位，保留整数位\n1 2 implicit conversion 隐式转换 explicit conversion 显式转换 很多时候有错的隐式转换不会被报错，能正常编译，需要格外注意\n1 2 3 float f = 17 / 5 ;//f will be 3.f , not 3.4f float f = 17 / 5.f ;//f will be 3.4f 除法两边都是整数，做的是整数除法\nData loss 占用字节低的数据类型 转换到 占用字节高的数据类型，不会有数据丢失\n占用字节高的数据类型 转换到 占用字节低的数据类型，就会有数据丢失\nAuto auto( since C++11 ) auto is placeholder type specifier\n1 2 3 auto a = 2;//type of a is int auto b - 2.3;//type of b is double auto c ;//valid in C , error in C++ auto在初始化阶段就会确定数据类型，后面不再改变\n1 2 auto a = 2; a = 2.3 ;// int = 2.3 , 会发生类型转换，最后a = 2 Branching-and-Looping-Statements 循环和分支结构\nif else 如果没有花括号去约束，else会与最近的if配对\n三目运算符 1 2 3 factor = isPositive ? 1 : -1 ; //isPositive成立，取前面的值 //isPositive不成立，取后面的值 Logical Expressions !\u0026gt;\u0026amp;\u0026amp;\u0026gt;|| 如果逻辑运算两边不是布尔，则会隐式转换为布尔\n1 2 if( -2 \u0026amp;\u0026amp; true )//-2会被强制转换为bool，其布尔值为1（只要不是零，全部转换成1） cout \u0026lt;\u0026lt; \u0026#34;The condition is true.\u0026#34; \u0026lt;\u0026lt; endl; 指针用作条件判断时\n1 2 3 int * p = new int [1024]; if(!p)// if( p == NULL ) cout \u0026lt;\u0026lt; \u0026#34;Memory allocation failed.\u0026#34; \u0026lt;\u0026lt; endl ; while loop 如果条件为true，就会执行循环\n循环执行中间可以用break打断循环，或者用continue跳过当前循环\n1 2 3 4 5 6 size_t num = 10 ; while( num \u0026gt;= 0 ) { cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl ; num -- ; } //这是一个死循环，size_t是无符号数 赋值操作这个表达式也有值\n1 2 3 4 bool flag = false ; while( flag = true ) { flag = false ; } do-while loop 先执行一次循环，再判断条件\nfor loop 1 2 for(init-clause;cond-expression;iteration-expression) loop-statement 初始化表达式，条件表达式，迭代表达式\nendless-loop 1 2 3 4 5 6 7 for(;;) { } while(true) { } goto-and-switch Statement case相当于goto的label\n1 2 3 4 5 6 7 8 switch(str) { case \u0026#39;a\u0026#39;: break; case \u0026#39;b\u0026#39;: break; default: break; } Data-Structures Array 在C和C++中，数组就是一块连续的内存 数组的名字指向数组的首地址\n初始化\n1 2 int number[5]={2,2};//只初始化前两个值 int number[5]{2,2}; 需要注意数组操作没有越界提示，甚至可以取负数\n1 num_array[-1] = 100 ; 但如果超出应用程序的内存边界时，会被操作系统杀死\n变长数组 其长度由变量决定，在运行时决定而非编译时决定\n1 2 3 4 5 6 int len = 0 ; int num_array[len];//可以为0 for (int i = 1 ; i \u0026lt; 10 ; ++ i ) { cout \u0026lt;\u0026lt; sizeof(num_array) \u0026lt;\u0026lt; endl ; ++ len ; } Array of unkown size 未知长度的数组\n1 2 3 4 5 int num_array[]={1,2,3,4}; //作为函数参数 float array_sum(float values[],size_t length); float array_sum(float *values,size_t length); 二维数组 1 2 3 void init_2d_array(float mat[][] , uint8_t rows , uint8_t cols);//error void init_2d_array(float mat[][3] , uint8_t rows , uint8_t cols); const-Arrays const修饰的数组不允许被修改\nStrings Array-style strings 1 2 3 4 5 6 7 8 char man[4]={\u0026#39;m\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;n\u0026#39;}; char MAN[3]={\u0026#39;M\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;N\u0026#39;};//a bad one char Man[4]={\u0026#39;M\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;\\0\u0026#39;}; //beter defination //更好的定义方式 char name[]=\u0026#34;MAN!\u0026#34;; //数组大小是5，字符串大小是4 strlen(Man)==3，因为有\\0限制\nstring class 同样没有越界检查\n1 2 #include \u0026lt;string\u0026gt; std::string str1 = \u0026#34;MAN\u0026#34;; Struct\u0026amp;Union\u0026amp;Enum Struct 注意有内存对齐\n1 2 3 4 5 6 7 8 9 typedef struct Student{ char name[4]; int born; bool male; }Stu; struct Student stu={\u0026#34;Yu\u0026#34;,2004,true}; Stu stu1 ; Union Union所有成员共享一个内存，以最大的成员变量为准 相当于同一个数据多个名字\n1 2 3 4 union ipv4add{ std::uint32_t add32; std::uint8_t add8[4]; }; Enum 枚举类型\n1 2 3 4 enum color{WHITE,BLACK,RED,BLUE};(0,1,2,3) enum color pen_color = RED ; pen_color += 1;//error typedef 用于创建别名\n1 typedef unsigned char uint8_t; Memory and Pointer Pointers 指针变量存储的是一个地址 对指针进行加减，加减是加减一个元素\n1 2 int numbers[4]; int * p =numbers+1 ;//加1个元素，每个元素是4个字节 Pointers of Pointers 1 2 3 int num=10; int * p =\u0026amp;num; int ** pp = \u0026amp;p ; const pointers 1 const int * p1=\u0026amp;num; 该指针指向的内容不可以通过该指针去修改\n1 2 *p1 = 3;//error num=3;//ok 可以修改指针指向的内容，但指针不能去指其他值\n1 2 3 int * const p2 = \u0026amp;num ; *p2 = 3 ;//ok p2 = \u0026amp;another;//error 换行转义符 虽然实际上是3行，但是在语义上是1行\n1 2 3 #define PRINT_ARRAY(array,n) \\ for( int i = 0 ; i \u0026lt; (n) ; ++ i ) \\ cout \u0026lt;\u0026lt; (array)[i] \u0026lt;\u0026lt; endl; Allocate-memory:C-style 只是示意图，在不同系统下会有区别 申请内存\n1 int *p1 = (int*)malloc(4); 释放内存\n1 void free(void* ptr); 内存泄漏问题 第一次申请的内存无法进行管理了，无法回收\n1 2 3 4 5 p = (int *)malloc(4*sizeof(int)); // ... p = (int *)malloc(8*sizeof(int)); // ... free(p); p是局部变量，函数返回后就消失了，这段申请的内存就无法回收了\n1 2 3 4 void foo() { int * p = (int *)malloc(sizeof(int)); return ; }//memory leak Allocate-memory:C++-style operator new and new[] 申请内存，比malloc功能更丰富 new是一个操作符\n1 2 3 4 5 int * p1 = new int ; int * p2 = new int(5);//申请内存后初始化为5 int * p3 = new int();//初始化为0 int * p4 = new int{};//初始化为0 1 2 int * pa1 = new int[16]{1,2,3};//申请16个int的内存，64字节 //同时还进行初始化 operator delete and delete[] 对于数组和普通变量而言，没有区别\n1 2 3 4 5 6 7 8 9 int *p1 = new int ; int *ps1 = new int[16]; delete p1 ;//没区别 delete []p1 ; delete ps1 ; delete []ps1; 但如果是一个类的对象的数组，两种方式都会释放所有的内存， 但是delete只有第一个元素会去调用析构函数， delete[]所有元素都会去调用析构函数\n1 2 3 4 stu *p1 = new stu[3] ; delete p1 ; delete []p1 ; Basics of Functions Functions 函数是为了让编程更加模块化而设计的\nParameters 传参的两种方式，值传递和引用传递 值传递的值可以认为是一个函数内的局部变量\n值传递 值传递的值可以认为是一个函数内的局部变量\n1 2 3 4 5 6 7 8 9 10 int foo(int x) { x += 10 ; return x ; } int main() { int num1 = 20 ; int num2 = foo(num1); return 0; } x是num1的一份拷贝（会涉及拷贝构造函数）\n引用传递-Reference 引用是一个变量的 别名\n1 2 int num = 0; int \u0026amp; num_ref = num ;//别名 引用创建的时候一定要初始化\n1 int \u0026amp;num_ref ;//error 在函数传递一个内存占用巨大的参数时，采用值传递，拷贝的变量会占用大量内存，这个时候可以使用指针或者引用\n指针与引用的区别 引用相较于指针更加安全 Return-statement 如果return一个数据很大，可以采用以下的方式\n1 2 3 4 5 bool matrix_add(const Matrix \u0026amp; matA , const Matrix \u0026amp; matB , Matrix \u0026amp; matC ) { //检查参数是否正常 //... //return true if everything ok } Inline-functions 内联函数，众所周知，函数的调用是有代价的，需要将一部分数据压入栈中，跳转执行完后再回来出栈\n如果一个微小的函数且被频繁调用，这个代价就会变得不可忽视，此时可以使用内联函数（空间换时间的典型案例）\n1 2 3 4 inline float max_function(float a ,float b ) { if(a\u0026gt;b) return a; else return b; } 需要注意的是inline是建议编译器以内联inline的方式编译这个函数（所以有可能编译器会不听你的建议）\n内联函数\u0026amp;宏 的区别 与宏定义是有去别的，宏定义是在预编译之前的文本替换，有较大的安全性问题\n注意，宏是在做文本替换，一定要警惕文本替换后的运算符优先级问题\n1 2 3 4 5 6 7 8 9 10 11 //宏 文本替换后运算优先级 #define MAX_MACRO(a,b) (a)\u0026gt;(b) ? (a):(b) //#define MAX_MACRO(a,b) a\u0026gt;b ? a : b int num1=20; int num2=30; int maxv=MAX_MACRO(num1,num2); int maxt=MAX_MACRO(num1++,num2++); //maxt=(num1++)\u0026gt;(num2++)?(num1++):(num2++); //实际执行了两次num2++,num2实际是32 //而num1只执行了一次num1++,num1实际是31 1 2 3 4 5 6 7 8 9 10 11 //宏 文本替换后运算优先级 //#define MAX_MACRO(a,b) (a)\u0026gt;(b) ? (a):(b) #define MAX_MACRO(a,b) a\u0026gt;b ? a : b int num1=0xAB09; int num2=0xEF08; int maxv=MAX_MACRO(num1\u0026amp;0xFF,num2\u0026amp;0xFF); //maxv=0x0009 //maxv= num1\u0026amp;0xFF \u0026gt; num2\u0026amp;0xFF ? num1\u0026amp;0xFF : num2\u0026amp;0xFF //实际上\u0026gt;优先级大于\u0026amp; //执行的是num1\u0026amp;(0xFF\u0026gt;num2)\u0026amp;0xFF Advances in Functions Default-arguments 默认参数是C++的特性，C并不支持\n1 2 3 float norm(float x,float y,float z); float norm(float x,float y,float z=0); //x,y,z是parameters,z=0的0是arguments Function-Overloading 函数重载是只有C++才支持的特性，C并不支持 与C++和C函数名符号修饰有关\n需要注意的是，C++的函数重载只允许将参数重载，而不能重载返回值\n1 2 3 float sum(float x , float y); double sum(float x , float y);//error //会出现重定义的错误 同时要注意，函数调用不要出现歧义，一旦出现歧义，编译器会停止工作，无法编译通过\nFunction-templates 函数模板生成的函数是模板函数，模板函数是函数模板被实例化以后生成的\n此处的T是定义的一个泛型\n1 2 3 4 5 template\u0026lt;typename T\u0026gt; T sum(T x , T y ) { cout \u0026lt;\u0026lt; \u0026#34;The input type is\u0026#34;\u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; return x+y; } 函数模板定义后，当编译器看到这段代码的时候，编译器并不会去生成真正的可执行代码\n要让编译器去生成函数模板对应的可执行代码需要实例化\n1 2 3 4 template double sum\u0026lt;double\u0026gt;(double,double);//全写 template char sum\u0026lt;\u0026gt;(char,char);//省略\u0026lt;\u0026gt;内的定义 template int sum(int,int);//省略\u0026lt;\u0026gt; //以上是显示的实例化 需要注意的是，函数模板除了显式的实例化，还可以做隐式的实例化\n1 2 3 4 5 6 template float sum\u0026lt;float\u0026gt;(float,float);//全写 //1.0f (float) //1.0 (double) auto man = sum(1.0,1.0);//会进行隐式实例化 //实例化的模板函数应该是 //template double sum\u0026lt;double\u0026gt;(double,double); 隐式的实例化可以指定实例化的类型\n1 2 auto man = sum\u0026lt;int\u0026gt;(1.0f,2.0f); //这里指定实例化类型后，对参数会有隐式转换 实例化后还可以进行自定义，也就是特例化，特例化的代码是会被编译的，一般会放在.cpp源文件\n1 2 3 4 5 6 7 8 9 //Point是一个结构体 //注意template后面一定要加\u0026lt;\u0026gt; template \u0026lt;\u0026gt; Point sum\u0026lt;Point\u0026gt;(Point pt1,Point pt2) { cout \u0026lt;\u0026lt; \u0026#34;The input type is \u0026#34; \u0026lt;\u0026lt; typeid(pt1).name() \u0026lt;\u0026lt; endl ; Point pt; pt.x = pt1.x+pt2.x; pt.y = pt1.y+pt2.y; } Function-Pointers and References Function-Pointers 函数指针是一个指针，指向函数，也就是指向执行指令的地址 指针函数的类型需要与其指向的函数类型完全匹配\n1 2 3 4 5 6 7 8 9 10 float nprm_l1(float x , float y); float norm_l2(float x , float y); float (*norm_ptr)(float x , float y);//括号不能省 //两种写法等价 norm_ptr = norm_l1; norm_ptr = \u0026amp;norm_l2; float len1 = norm_ptr(-3.0f,4.0f); float len2 = (*norm_ptr)(-3.0f,4.0f); 常见的应用案例是将函数作为一个参数传递到另外一个函数里面，作为回调函数\nFunction-references 函数引用，需要注意函数引用在初始化的时候需要定死\n1 2 3 float nprm_l1(float x , float y); float norm_l2(float x , float y); float (\u0026amp;norm_ref)(float x, float y) =norm_l1; Recursive-Functions 递归函数，自己调用自己，需要有递归终止条件，否则一直递归会爆栈\n1 2 3 4 5 6 7 8 void div2(double val) { if(val\u0026gt;1.0) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; div(val/2); } else cout \u0026lt;\u0026lt; \u0026#34;over\u0026#34;; cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } 函数的每一次调用需要压栈进行数据保存，无穷递归就会导致爆栈\nSpeedup-Your-Program C-and-Cpp-with-arm C和C++语言是由明确的语言规范的，是具有平台无关性的，能通过编译器编译成平台相关的可执行程序\n机器人或者说是智能设备领域全是arm的天下\nSpeedup-Your-Program Simple is Beautiful 代码优化常用策略上，优化代码一定要考虑到内存\n大量的内存读写带来的时间浪费 非连续内存的跳跃式读取导致的cache命中率下降 避免大量的内存拷贝 关于SIMD和OpenMP SIMD:Single instruction,multiple data （例如向量加法） OpenMP 1 2 3 4 5 6 #include \u0026lt;omp.h\u0026gt; #pragma omp parallel for for( int i = 0 ; i \u0026lt; n ; ++ i ) c[i] = a[i]+b[i]; //将循环拆开，分给不同的cpu核运行 //需要注意将任务拆开给不同的cpu核本身也是需要时耗的 Basics of Classes classes-and-objects 类的对象去操作成员会更加的安全 类的成员函数在类内声明时，默认是inline函数 所以简单的函数在类内实现，复杂函数在类外实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Student { private: char name[4]; int born; bool male; public: //类内实现，默认inline void setName(cont cahr s) { strcpy(name,s,sizeof(name)) } void setGender(); void printInfo(); }; inline void Student:::setGender(bool isMale) { male = isMale; } void Student::printInfo() {//不是inline函数 cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl ; //... } Constructors-and-Destructors 构造函数与析构函数 构造函数可以有很多个，析构函数只能有一个\n构造函数Constructors 1 2 struct in C:alloca te memory class in C++:allocate memory\u0026amp;invoke a constructor 构造函数的用途是对 对象里面的数据 进行初始化 如果一个类不定义构造函数，编译器会默认生成一个默认构造函数\n定义构造函数需要定义在public里面\n每个new出来的对象，都会调用构造函数进行初始化\n析构函数Destructors 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { public: //... Student() { name = new char[1024]{0}; } //... ~Student() { delete [] name; } } this-Pointer 对于类而言，函数的指令只有一份 All methods in a function have a this-pointer\n1 2 3 4 5 6 7 8 9 10 11 void setBorn(int b) { born=b; } void setBorn(int b) { this-\u0026gt;born=b; } void setBorn(int born) { this-\u0026gt;born=born;//this指针不可省略，用来对参数进行区分 } const-and-static-Members const Members 常量成员变量不能被修改，常量成员函数不能去修改成员变量\n1 2 3 4 5 6 7 8 9 class Student { private: const int BMI=24; public: int getBorn() const { //born ++ ;//error return born; } } static Members 静态成员变量和静态成员函数并不绑定在某一个实例上 类的静态变量属于类，不属于实例化的对象 静态函数不能访问实例成员，也不能修改非静态数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { public: int born ; static int stu_num ;//仅仅是声明 //inline static int stu_num = 0 ;//C++17标准，不需要外部定义 int getBorn() const { //born ++ ;//error return born; } static int getNum() { return stu_num; } } int Student::stunum = 1 ;//外部定义 Advances in Classes Operator-overloading 运算符重载\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class complex { public: complex();//默认构造函数 complex(double,double);//初始化构造函数 complex(double);//强制转换构造函数 //*****************************************************// //下面是二选一 complex operator + (const complex\u0026amp;);//运算符重载成员函数实现 complex operator - (const complex\u0026amp;);//运算符重载成员函数实现 friend complex operator + (complex\u0026amp;,complex\u0026amp;);//友元函数实现 friend complex operator - (complex\u0026amp;,complex\u0026amp;);//友元函数实现 //重载+=符号 complex \u0026amp; operator+=（const complex\u0026amp; comp1) { this-\u0026gt;real += comp1.real; this-\u0026gt;imag += comp1.imag; return *this; } //****************************************************// friend std::istream\u0026amp; operator \u0026gt;\u0026gt; (std::istream\u0026amp; , complex\u0026amp;);//istream类\u0026gt;\u0026gt;运算符重载 friend std::ostream\u0026amp; operator \u0026lt;\u0026lt; (std::ostream\u0026amp; , complex\u0026amp;);//ostream类\u0026lt;\u0026lt;运算符重载 private: double real , imag ; }; 需要注意运算符重载是有方向的\n1 2 3 4 complex comp1(1.0,1.0); complex comp2(2.0,2.0); comp1 += comp2; //comp1.operator+=(comp2); Friend-Functions 友元函数的声明在类内，能访问类的私有变量和私有函数，但是它不是类的成员，是一个特殊的函数\n友元函数的定义可以在类内紧跟声明，也可以在类外\nOperator \u0026lt;\u0026lt; 也能被重载，一般采用友元函数形式重载\n1 2 3 4 5 6 7 8 9 10 //返回类型是输入输出流的引用 friend std::istream\u0026amp; operator \u0026gt;\u0026gt; (std::istream\u0026amp; , complex\u0026amp;);//istream类\u0026gt;\u0026gt;运算符重载 friend std::ostream\u0026amp; operator \u0026lt;\u0026lt; (std::ostream\u0026amp; , complex\u0026amp;);//ostream类\u0026lt;\u0026lt;运算符重载 /**************************************************/ friend std::ostream\u0026amp; operator \u0026lt;\u0026lt; (std::ostream\u0026amp; os, complex\u0026amp; comp) { os\u0026lt;\u0026lt;comp.real\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;comp.imag; return os ;//一定要返回os，为了能够链式调用 } 输入输出流的返回一定是输入输出流的引用，为了能够链式调用\nuser-defined-type-conversion 类转基本数据类型，运算符重载\n1 2 3 4 5 6 7 8 9 //implicit conversion operator int() const {//允许隐式转换 return int(this-\u0026gt;real) ; } //只允许显式转换 explicit operator float() const { return float(this-\u0026gt;real); } 基本类型转类，可以利用构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 complex(int m):real(m),imag(0) {} complex\u0026amp; operator=(int m) { this-\u0026gt;real = m ; this -\u0026gt;imag = 0 ; return *this ; } //上面是构造函数，在类内 //调用 complex comp1 = 100 ;//就会自动调用构造函数 //初始化 执行的是构造函数 comp1 = 10 ;//此处才是赋值运算符，赋值操作 comp1 = complex(20);//此处是构造函数 Increment 有前置(++i)和后置(i++)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //都是类的成员函数 //prefix increment complex\u0026amp; operator++() {//前置 this-\u0026gt;real ++ ; return *this ; } //postfix increment complex operator++(int) {//后置，参数列表里面放int 主要是为了做区分 //需要保存旧值用来返回 complex old = *this ;//keep the old value operator++();//prefix increment return old ; } Dynamic-Memory-Management-in-Classes Some-default-operations Default-Constructors 默认构造函数\n如果一个类没有任何构造函数，编译器就会生成一个空的构造函数，如果给类定义了构造函数，编译器就不会生成默认构造函数\n需要避免歧义\n1 2 3 4 5 6 7 8 complex() { cout \u0026lt;\u0026lt; \u0026#34;man\u0026#34;\u0026lt;\u0026lt;endl ; } complex(int n=0) { cout \u0026lt;\u0026lt; \u0026#34;MAN\u0026#34; \u0026lt;\u0026lt; endl ; } //此时就会有歧义，编译器奴知道执行哪一个 Implicitly-defined-Destructor 隐式定义的析构函数，没有显式定义析构函数，编译器会去定义一个空的析构函数\nDefault-Copy-Constructors 大疆C++一面：C++什么时候生成默认拷贝构造函数？\n拷贝构造函数的参数必须是const引用（避免无限递归调用） 拷贝构造函数定义如下\n1 2 3 4 5 6 7 complex::complex(complex \u0026amp; comp1) { //... } complex comp(1.0,1.0); complex comp_copy = comp;//copy constructor complex comp_kobe(comp);//copy constructor 默认拷贝构造函数，如果用户没有显式定义，编译器会默认生成一个空的拷贝构造函数，该默认构造函数会将对象里面的所有非静态成员全部拷贝一遍\n可以使用下面的=delete来让编译器不去提供默认的copy-constructors\n1 complex(const complex\u0026amp;)=delete; Default-Copy-Assignment Assignment operators:=,+=,-=\n1 2 3 4 5 6 7 complex\u0026amp; complex::operator=(complex \u0026amp; comp) { //... } complex comp(1.0,1.0); complex comp_man = comp;//copy constructor拷贝构造函数 comp_man = comp;//copy assignment Default-Copy-Assignment 如果用户没有定义Copy-Assignment，编译器会自动生成一个默认的Copy-Assignment\n该默认函数会将对象所有的非静态成员变量全部拷贝一遍\n可以使用下面的=delete来让编译器不去提供默认的copy-assignment\n1 complex \u0026amp; operator= (const complex\u0026amp;)=delete; Copy-Assignment 注意赋值运算符在内存管理上的细节\n避免自赋值 赋值前先回收，避免内存泄漏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class ClassA { public: ClassA() {} ClassA(const char* pszInputStr) { pszTestStr = new char[strlen(pszInputStr) + 1]; strncpy(pszTestStr, pszInputStr, strlen(pszInputStr) + 1); } virtual ~ClassA() { delete pszTestStr; } // 赋值运算符重载函数 ClassA\u0026amp; operator=(const ClassA\u0026amp; cls) { // 避免自赋值 if (this != \u0026amp;cls) { // 避免内存泄露 if (pszTestStr != NULL) { delete pszTestStr; pszTestStr = NULL; } pszTestStr = new char[strlen(cls.pszTestStr) + 1]; strncpy(pszTestStr, cls.pszTestStr, strlen(cls.pszTestStr) + 1); } return *this; } public: char* pszTestStr; }; int main() { ClassA obj1(\u0026#34;liitdar\u0026#34;); ClassA obj2; obj2 = obj1; cout \u0026lt;\u0026lt; \u0026#34;obj2.pszTestStr is: \u0026#34; \u0026lt;\u0026lt; obj2.pszTestStr \u0026lt;\u0026lt; endl; return 0; } An-Example-with-Dynamic-Memory 注意深拷贝与浅拷贝的问题，导致重复释放同一块内存 这种错误最容易由 默认拷贝构造函数 和 默认赋值运算符重载 导致\nHard-Copy 每次创建和赋值的时候都去重新申请内存 缺点在于如果每次申请的内存较大会很耗时\nSoft-Copy 如果是赋值操作，或者 拷贝构造，可以让两个变量共享同一块内存，同时用过一个变量去记录该块内存的引用数量\nSmart-Pointers 使用智能指针的话，可以只管申请，不管释放，系统会自动帮你释放，释放delete会调用对应的析构函数\nstd::shared_ptr 定义\n1 2 3 std::shared_ptr\u0026lt;数据类型\u0026gt; man(new 数据类型(参数列表));//参数列表是构造函数的参数列表 std::shared_ptr\u0026lt;string\u0026gt; man(new string(\u0026#34;MAN\u0026#34;)); auto MAN = std::make_shared\u0026lt;int\u0026gt;(119); 多个指针指向的是同一个对象，共享\nstd::unique_ptr 指针指向一个对象后，就不允许分享\n1 2 3 4 5 std::unique_ptr\u0026lt;string\u0026gt; man(new string(\u0026#34;MAN\u0026#34;)); auto MAN = std::make_unique\u0026lt;int\u0026gt;(119);//C++17标准 std::unique_ptr\u0026lt;string\u0026gt; m3 = std::move(man);//移动过去后，man成了空指针 std::unique_ptr\u0026lt;int\u0026gt; m4 = MAN ;//error How-to-Understand-Smart-Pointers 智能指针的定义，是指针的同时还是一个对象\n1 2 3 template\u0026lt;class T\u0026gt;class shared_ptr; template\u0026lt;class T,class Deleter=std::default_delete\u0026lt;T\u0026gt;\u0026gt;class unique_ptr; Class-Inheritance Improve-your-source-code 在赋值操作上，很多时候一个一个赋值不如memcopy直接将内存的内容复制过去效率高 二维数组最好用一维数组去表达，因为这样不用多次去申请一维的内存，多次申请的一维数据不保证连续，会降低读取速率 一个函数，一定要去检查函数的参数是否有效 注意头文件重复包含的问题 注意内存对齐 函数的输入参数，不需要修改的加const关键字 Derived-class Base class(parent)，Derived class(child) 一个是基类（父类），一个是派生类（子类）\n可以多层继承和多个继承\n构造函数与析构函数在子类中的执行 构造函数 子类的构造函数执行的第一刻，父类的构造函数先执行\n下面子类的构造函数执行顺序：Base的构造函数-\u0026gt;MAN的赋值-\u0026gt;最后是子类构造函数内部\n1 2 3 4 5 6 7 class Derived :public base { public ： int MAN ; Derived(int man):Base(man-1,man-2),MAN(man) { //... } }; 析构函数 子类的析构函数会先执行子类的析构函数，再执行父类的构造函数\n1 2 3 4 5 6 7 8 9 10 class Derived :public base { public ： int MAN ; Derived(int man):Base(man-1,man-2),MAN(man) { //... } ~Derived() { //... } }; Acess-Control 访问控制 private只能类内访问，protected可以在类内和子类里面访问\n关于继承方式：有三种继承方式，public，protected，private Virtual-Functions 虚函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class A{ protected: int x; public: A(){ x =1000; } virtual void print(){ //虚函数 cout \u0026lt;\u0026lt; \u0026#34;x=\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl ; } }; class B:public A{ int y; public: B() { y=2000; } void print() { //派生虚函数 cout \u0026lt;\u0026lt; \u0026#34;y=\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl ; } }; class C:public A{ int z; public: C(){ z=3000; } void print(){ //派生虚函数 cout \u0026lt;\u0026lt; \u0026#34;z=\u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl ; } }; void main(void ) { A a, *pa; B b; C c; a.print(); b.print(); c.print(); //以上为静态关联 pa=\u0026amp;a; pa-\u0026gt;print(); //调用类A的虚函数 pa=\u0026amp;b; pa-\u0026gt;print(); //调用类B的虚函数 pa=\u0026amp;c; pa-\u0026gt;print();//调用类C的虚函数 } 虚函数与非虚函数的绑定不同，常规函数都是静态绑定，虚函数是动态绑定\n有虚函数时，此类定义的对象会有一个隐含的成员变量，该隐含变量会指向一个函数表\n对于纯虚函数，在类内定义\n1 virtual void print() = 0; 来告诉编译器这是一个纯虚函数，拥有纯虚函数的类就不能创建对象\n另外，析构函数也是一个虚函数\nInheritance-and-dynamic-memory-allocation 如果一个子类只有基类有动态内存申请，就不用考虑子类，只需要解决基类的问题，自定义写 构造函数，赋值运算符重载，拷贝构造函数\n如果子类有动态内存申请，解决方案一样，重新把 构造函数，拷贝构造函数，赋值运算符重载 定义即可\n下面用伪代码展示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyMap:public MyString { private: char *keyname; public: MyMap(const char *key , const char *value) {//会自动先调用基类的构造函数，此处不需要向基类构造函数传递参数 //...，为新的指针变量动态申请内存 } //析构函数将子类的指针申请的动态内存释放掉 MyMap(const MyMap \u0026amp;mm):MyString(mm.buf_len,mm.characters) {//给基类的构造函数传递参数，调用基类的构造函数去申请内存 //allocate memory for keyname //and hard copy from mm to *this } MyMap \u0026amp; operator=(const MyMap \u0026amp;mm) { MyString::operator=(Mys(mm));//调用基类的 //allocate memory for keyname //and hard copy from mm to *this return *this; } }; Class-Templates-and-Std-Library 模板十分实用，前面有函数模板，此处是类模板\n函数模板回顾 函数模板生成的函数是模板函数，模板函数是函数模板被实例化以后生成的\n1 2 3 4 5 6 7 8 9 template \u0026lt;typename T\u0026gt; T sum(T x , T y ) { cout \u0026lt;\u0026lt;\u0026#34;The input type is \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl ; return x+y ; } template double sum\u0026lt;double\u0026gt;(double,double);//实例化 template char sum\u0026lt;\u0026gt;(char,char); template int sum(int,int); 类模板和模板类也是类似的\nclass-template 类模板的定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 template\u0026lt;typename T\u0026gt; class Mat { uint16_t rows ; uint16_t clos ; T* data ; public : Mat(uint16_t rows,uint16_t cols):rows(rows),cols(cols) { data = new T[rows*cols]{}; } ~Mat() { delete [] data; } T getElement(uint16_t r , uint16_t c);//函数模板，类内声明 bool setElement(uint16_t r , uint16_t c , T value);//函数模板，类内声明 }; //类内函数模板的类外定义 template \u0026lt;typename T\u0026gt; T Mat\u0026lt;T\u0026gt;::getElement(uint16_t r , uint16_t c) {//getElement是Mat\u0026lt;T\u0026gt;的成员函数 if( r \u0026gt;= this-\u0026gt;rows || c \u0026gt;= this-\u0026gt;cols ) { cout \u0026lt;\u0026lt; \u0026#34;getElement():Indices are out of range\u0026#34; \u0026lt;\u0026lt; endl ; return 0 ; } return data[this-\u0026gt;cols*r+c]; } template \u0026lt;typename T\u0026gt; T Mat\u0026lt;T\u0026gt;::setElement(uint16_t r , uint16_t c , T value) { if( r \u0026gt;= this-\u0026gt;rows || c \u0026gt;= this-\u0026gt;cols ) { cout \u0026lt;\u0026lt; \u0026#34;setElement():Indices are out of range\u0026#34; \u0026lt;\u0026lt; endl ; return false ; } data[this-\u0026gt;cols*r+c]=value; return true ; } //显式实例化 template class Mat\u0026lt;int\u0026gt;; 模板的参数 declare a template\n1 template \u0026lt;parameter-list\u0026gt; declaration The parameters can be\ntype template parameters(例如int，float 类型) `templaate template parameters(模板类型做为参数)` non-type template parameters(定值，float,int类型的定值，例如1.0f，值参数) Template-Non-Type-Parameters 模板的非类型参数 此处相当于在编译时就要确定矩阵有多少行多少列，而不是动态申请 因为不需要动态申请，也就没有必要析构的时候删除\n1 2 3 4 5 6 7 8 template\u0026lt;typename T,uint16_t rows,uint16_t cols\u0026gt; class Mat { T data[rows][cols]; public: Mat() {} T getElement(uint16_t rows,uint16_t cols); bool setElement(uint16_t r , uint16_t c , T value); }; 1 2 3 4 Mat\u0026lt;int\u0026gt; vec1(3,3);//会在构造函数内部动态申请内存 Mat\u0026lt;int,3,3\u0026gt; vec2;//编译时就确定 typedef Mat\u0026lt;int,2,2\u0026gt; Mat22i;//简化 另外补充，静态数组的默认拷贝构造，是一个一个值复制过去，不会有内存管理问题\n模板类是可以相互继承的\n1 2 3 4 5 6 //继承模板类，需要template\u0026lt;typename _Tp, int cn\u0026gt; template\u0026lt;typename _Tp, int cn\u0026gt;class Vec:public Matx\u0026lt;_Tp,cn,1\u0026gt; { public； typedef _Tp value_type; }; Class-template-specialization 类模板的特化\n一个MyVector的类模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template\u0026lt;typename T\u0026gt; class MyVector { uint16_t length ; T *data ; public : MyVector(uint16_t length):length(length) {//构造函数 data = new T[length]{};//所有元素初始化为0 } ~MyVector() { delete [] data ; } MyVector(const MyVector\u0026amp;)=delete;//删除拷贝构造函数 MyVector\u0026amp; operator=(const MyVector\u0026amp;)=delete; T getElement(uint16_t index); bool setElement(uint16_t index , T value); }; template\u0026lt;typename T\u0026gt; T MyVector\u0026lt;T\u0026gt;::getElement(uint16_t index) { //... } bool类型变量是一个字节，因为内存管理删除申请的最小单位是一个字节 现在对于上述模板想使用bool，又想更加压缩内存，可以将bool类型的模板特化，特殊情况特殊处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;\u0026gt; class MyVector \u0026lt;bool\u0026gt; { uint16_t length ; unsigned char *data ; public : MyVector(uint16_t length):length(length) {//构造函数 int num_bytes = (length-1)/8+1; data = new unsigned char [num_bytes]{};//所有元素初始化为0 } ~MyVector() { delete [] data ; } MyVector(const MyVector\u0026amp;)=delete;//删除拷贝构造函数 MyVector\u0026amp; operator=(const MyVector\u0026amp;)=delete; bool getElement(uint16_t index); bool setElement(uint16_t index , bool value); }; bool MyVector\u0026lt;bool\u0026gt;::getElement(uint16_t index) { //... } std-classes std::string array\n1 2 3 template\u0026lt;class T,std::size_t N\u0026gt;struct array; std::array\u0026lt;int,3\u0026gt;a = {1,2,3}; others Error-Handling Standard-Output-Stream-and-Standard-Error-Stream 标准输出流与标准错误流 C\u0026amp;C++的输出流与错误流 标准输出流的内容可以通过管道输出到其他文件，而标准错误流不会\n重定向 1 2 3 4 5 6 7 ./program | less ./program \u0026gt; output.log 将stdout输出到output.log文件，如果文件已存在就销毁再创建，内容覆盖 ./program 1\u0026gt; output.log 将stdout输出到output.log文件 ./program \u0026gt;\u0026gt; output.log 将stdout输出到output.log文件，如果没有则创建，有内容则加到已有内容后面 ./program 2\u0026gt; error.log 将stderr输出到error.log文件 由此可以看出关于日志的重要性，以及日志是什么\nassert 在编译过程中，方便debug的工具\nExceptions catch，try与throw\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 float ratio( float a , float b ) { if(...) throw 1; if(...) throw 2; return a+b; } try{ z = ratio(x,y); } catch(int eid) { //... } throw相当于扔出一个异常，再函数调用中一级一级往上，如果有catch，就进入对应的catch的处理，否则若返回到main函数中仍没有catch，程序就会被杀死\n1 2 3 4 catch(...) { //表示所有异常都能接住 std::cerr\u0026lt;\u0026lt;\u0026#34;Unrecognized Exception\u0026#34;\u0026lt;\u0026lt;std::endl; //... } throw可以扔一个类，std标准可有提供std::exception的类\nNested-Classes-and-RTTI Friend-Classes 复习一下友元函数，注意有顺序问题\n1 2 3 4 5 6 7 8 9 10 11 class MyVector { //... public: friend MyVector operator(int m , const MyVector\u0026amp; v); }; MyVector operator+(int m , const MyVector \u0026amp;v ) { MyVector v_trmp ; //... return v_temp ; } 友元类\n1 2 3 4 5 6 7 8 class Sniper { private: int bullets; public: Sniper(int bullets=0):bullets(bullets){} friend class Supplier;//仅仅是声明 } Friend-Member-Functions 可以用来实现最小授权，另一个类的某一个成员函数可以访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Supplier;//先声明 class Sniper { private: int bullets; public: Sniper(int bullets=0):bullets(bullets){} friend bool Supplier::provider(Sniper \u0026amp;); } class Supplier{ //... } 注意顺序问题以及先声明再实现的处理方法\nNested-Types 内部类型，此处的enum DataTYpe即是内部类型，作用是这个枚举类型仅Mat类能用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Mat { public: enum DataType { TYPE8U, TYPE8S, TYPE32F, TYPE64F }; private: DataType type ; void* data ; public: Mat(DataType type):type(type),data(NULL){} DataType getType() const { return type ;} }; Nested-Classes 与内部类型的类似，不用过多赘述，著需要注意在使用时加上前缀\n1 Storage::Fruit apple(\u0026#34;apple\u0026#34;,100); Runtime-Type-Identification(RTTI) 运行时的类型鉴别\n1 2 3 4 5 6 7 8 9 10 class Person; class Student: pubic Person;//student类对person类进行了拓展 Person person(\u0026#34;Yu\u0026#34;); Student student(\u0026#34;MAN\u0026#34;,\u0026#34;20210212\u0026#34;); Person *pp = \u0026amp;student ;//ok Student *ps = (Student*)\u0026amp;person;//danger //从内存管理角度去理解会很简单，本质还是访问内存越界的问题 cout \u0026lt;\u0026lt; ps-\u0026gt;getInfo() \u0026lt;\u0026lt; endl ;//可能会访问不该访问的内存 但是如果getInfo是virtual虚函数，则会有动态绑定，不会出现访问越界的问题\n1 2 3 4 5 6 dynamic_cast operator:conversion of polymorphic types. polymorphic types(多态类型) typeid operator:Identify the exact type of an object. 可以用typeid()操作符来获取类的名称\n1 2 if( typeid(std::string)==typeid(s) ) cout \u0026lt;\u0026lt; \u0026#34;s is a std::string object.\u0026#34; \u0026lt;\u0026lt; endl ; 使用dynamic_cast转换（仅多态类型使用） 多态类型的类里面需要有virtual\n1 2 3 4 5 6 7 8 9 10 11 class Person; class Student: pubic Person;//student类对person类进行了拓展 Person person(\u0026#34;Yu\u0026#34;); Student student(\u0026#34;MAN\u0026#34;,\u0026#34;20210212\u0026#34;); Person *pp = NULL ; Student *ps = NULL ; ps = dynamic_cast\u0026lt;Student*\u0026gt;(\u0026amp;person);//不会进行转换，转换失败，ps=NULL，更安全 pp = dynamic_cast\u0026lt;Person*\u0026gt;(\u0026amp;student); More-Type-Cast-Operations const_cast:Type cast for const or volatile value .\nstatic_cast:如果两类型能够隐式转换，则发生转换，否则不能转\n1 2 3 Base *pB = static_cast\u0026lt;Base*\u0026gt;(derived);//valid Derived *pD = static_cast\u0026lt;Derived*\u0026gt;(base);//valid UnRelated *pU = static_cast\u0026lt;UnRelated*\u0026gt;(base);//invalid reinterpret_cast:Converts between types by reinterpreting the underlying bit pattern.\n1 2 3 int i = 18; float *p1 = reinterpret_cast\u0026lt;float *\u0026gt;(i);//static_cast will fail int *p2 = reinterpret_cast\u0026lt;int *\u0026gt;(p1); Code-Optimization Register-and-Cache 三级，Register,Cache,Memory 一般通过Latency延迟,Bandwidth带宽这两个指标来衡量\n在访问内存中连续数据的情况下，访问速度会更快 现代多核的CPU在缓冲区的设置上会更复杂，会分为专门存放指令的区域和专门存放数据的区域，同时多核会有共享的缓存区\nLocality-of-Reference 局部性主要有时间局部性和空间局部性，局部性是观察程序的运行得出的 时间局部性是指同一块内存在一两个指令周期后很有可能会被再次访问 空间局部性是指被访问的一块内存，其周围也会很有可能被访问\n计算CPU优化效率 Peak_FLOPS=2*Frequency*cores*每周期发送的指令*(指令宽度/数据宽度)\n3GHz，24核，每周期发送2指令，指令宽度512比特 假设算的是double（64比特）\nFLOPS=2*3G*24*2*(512/64)\n有效floating op计算 Matrix A是m*k，Matrix B是k*n，Matrix C是m*n Effected floating op = 2*m*k*n\n衡量优化效率 Efficiency=Eddected_Performance/Peak_Performance\n个人的补充与总结 关于Include 1 2 include \u0026lt;\u0026gt;//从编译器指定的路径去找 include \u0026#34;\u0026#34;//从编译器指定的路径去找以及当前.cpp文件所在目录去找 关于类 类内成员函数可在类内定义（默认内联） 或类外定义 关于模板 c++模板编程应该把实现放在头文件中吗，这样写会不会让头文件变得很难看？ - 知乎 借用其中的一个回答\n理论上，模板函数的实现应该放在头文件里，这是因为 C++ 继承了 C 语言先分离编译最后链接的传统，而模板的实例化在编译期，所以必须要让编译器看到函数的实现，才能实例化\n这里从原理上来看就知道模板的声明和定义（实现）应该都放在头文件中了，不然在编译期引用了模板实例化的源文件会无法正常编译，也就是无法正常生成实例化的模板函数，类模板同理\n详解如下 C++中模板以及模板实例化都放在头文件_模板特化能放到cpp文件吗-CSDN博客\n关于全特化，函数模板的特化版本本质上是一个具体的函数（不再是模板），但由于它与通用模板存在关联，实践中几乎都放在头文件中\n类模板特例化的同样规则，类模板的全特化和部分特化也建议放在头文件中\n原因如下\n避免隐式实例化冲突\n当编译器处理模板实例化时，如果在某个编译单元中看不到特化版本的声明，会自动实例化通用模板。若此时其他编译单元存在特化版本的实现，会导致链接时出现 “多重定义” 错误 1 2 3 4 5 6 7 8 9 10 11 // 头文件（func.h） template\u0026lt;typename T\u0026gt; void print(T value) { // 通用模板 std::cout \u0026lt;\u0026lt; value; } // 特化版本放在头文件，确保所有使用处可见 template\u0026lt;\u0026gt; void print\u0026lt;const char*\u0026gt;(const char* str) { std::cout \u0026lt;\u0026lt; \u0026#34;String: \u0026#34; \u0026lt;\u0026lt; str; } 符合模板使用习惯\n模板（包括特化）的使用者通常会通过头文件获取完整定义，无需关心实现文件的链接细节。将特化放在头文件中，能让代码结构更清晰，减少外部依赖 类模板和函数模板的例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 1. 基本函数模板 template\u0026lt;typename T\u0026gt; T max(T a, T b) { return a \u0026gt; b ? a : b; } // 2. 函数模板特化（针对特定类型） template\u0026lt;\u0026gt; const char* max\u0026lt;const char*\u0026gt;(const char* a, const char* b) { return strcmp(a, b) \u0026gt; 0 ? a : b; } // 使用 int i = max(3, 5); // 隐式实例化int版本 const char* s = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;); // 调用特化版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 1. 基本类模板 template\u0026lt;typename T, int Size\u0026gt; class Array { private: T data[Size]; public: Array() {} T\u0026amp; operator[](int index) { return data[index]; } int getSize() const { return Size; } }; // 2. 类模板特化（针对bool类型优化） template\u0026lt;int Size\u0026gt; class Array\u0026lt;bool, Size\u0026gt; { private: unsigned char data[(Size + 7) / 8]; // 位压缩存储 public: bool get(int index) const { return (data[index / 8] \u0026gt;\u0026gt; (index % 8)) \u0026amp; 1; } }; // 使用 Array\u0026lt;int, 10\u0026gt; intArray; // 实例化int类型数组 Array\u0026lt;bool, 100\u0026gt; boolArray; // 使用特化版本 ","date":"2025-09-17T17:31:07+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/","title":"C\u0026C++ 系统学习"},{"content":"引言 重载的本质 重载（overloading）是同一符号在不同作用域的不同应用条件下具有不同的语义。这个符号可以是函数，运算符，也就是一物多用\n函数重载 函数重载：定义同名但参数类型与数量不同的函数，编译系统根参数的匹配规则来决定调用哪一个函数\n前置内容（带缺省值的函数） 带缺省值的函数 函数在说明或函数定义中，形参指定了一个数值，则称此函数为带缺省值的函数，指定的值称为缺省值\nExample 1 2 3 //带缺省值的函数声明： float area(float r=6.5) //6.5就是缺省值 在调用时，如果不传参数，使用默认值，就会默认形参等于缺省值\n1 area();//默认 r=6.5 不使用默认值\n1 area(7.5);// r=7.5 带多个缺省参数的函数 如果函数有多个缺省参数，则缺省参数必须是 从右向左定义，并且在一个缺省参数的右边不能有 未指定缺省值的参数。(缺省值集中在参数表右侧)\n1 2 void f1( float a , int b=6 , int c , char d=\u0026#39;a\u0026#39; );//错误定义 void f2( float a , int c , int b=6 , char d=\u0026#39;a\u0026#39; );//正确定义 调用形式可以为：\n1 2 3 f2( 3.5 , 5 , 3 , \u0026#39;x\u0026#39; ); f2( 3.5 , 5 , 3 ); f2( 3.5 , 5 ); 不带缺省的得函数重载 函数重载：定义同名但参数类型与数量不同的函数，编译系统根据参数的匹配规则来来决定调用哪一个函数\n1 2 3 4 5 6 7 8 9 int max( int a , int b , int c ) { ... } int max( int a , int b ) { ... } double max(double a , double b ) { ... } 注意：不能出现函数参数个数，参数类型都相同，只有函数返回值不同的同名函数。 因为系统将无法从调用形式上判断调用哪个函数\n1 2 3 4 5 6 int max( int a , int b ) { ... } bool max( int a , int b ) { ... } 带缺省值的函数重载 一般带缺省值的函数不能进行重载，容易出现错误 错误实例：\n1 2 3 4 5 6 7 8 9 10 int max( int a , int b , int c=1 ) { ... } int max( int a , int b ) { ... } int main() { max(1,2) ; } 此时系统无法匹配正确的函数，不能实现函数重载（静态多态）\n一个函数不能即作为重载函数，又 作为有默认参数的函数！ （这是一个建议，其实并不绝对，只要让系统能匹配到唯一的函数就行）\n运算符重载 前置内容（C++ 类与对象）\n运算符重载本质上是函数重载，将指定的运算表达式转化为对运算符函数的调用，运算对象转化为运算符函数的实参（看个乐呵就行）\n为什么需要运算符重载 C++中预定义的运算符其运算对象只能是基本数据类型，而不适用于用户自定义类型。运算符重载允许把C++标准运算符应用于自定义数据类型的对象，与函数重载类似，对已有的运算符赋予新的含义，用一个运算符表示不同功能的运算， 这就是运算符重载\n运算符重载的例子 类的定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class complex { public: complex();//默认构造函数 complex(double,double);//初始化构造函数 complex(double);//强制转换构造函数 //*****************************************************// //下面是二选一 complex operator + (complex\u0026amp;);//运算符重载成员函数实现 complex operator - (complex\u0026amp;);//运算符重载成员函数实现 friend complex operator + (complex\u0026amp;,complex\u0026amp;);//友元函数实现 friend complex operator - (complex\u0026amp;,complex\u0026amp;);//友元函数实现 //****************************************************// friend istream\u0026amp; operator \u0026gt;\u0026gt; (istream\u0026amp; , complex\u0026amp;);//istream类\u0026gt;\u0026gt;运算符重载 friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; , complex\u0026amp;);//ostream类\u0026lt;\u0026lt;运算符重载 private: double real , imag ; }; 成员函数重载运算符 隐含this指针，左侧自定义类型\n1 c3 = c1+c2 ; 翻译为\n1 c3 = c1.operator+(c2); 参数个数=原操作数个数-1（后置++、\u0026ndash;除外）\n模板 1 2 3 数据类型(返回值类型) 类名(域)::operator 运算符( 形参表 ) { 重载处理 } 具体例子 1 2 3 4 5 6 7 8 9 10 11 12 13 complex complex::operator + (const complex \u0026amp;c1) { complex c2 ; c2.real = real+c1.real ; c2.imag = imag+c1.imag ; return c2 ; } complex complex::operator - (const complex \u0026amp;c1) { complex c2 ; c2.real = real-c1.real ; c2.imag = imag-c1.imag ; return c2 ; } 友元函数重载运算符 1 c3 = c1 + c2 ; 翻译为\n1 c3 = operator+(c1,c2);//友元函数 参数个数=原操作数个数 (至少有一个自定义类型形参)\n模板 1 2 3 friend 数据类型(返回值类型) 类名(域):: operator 运算符( 形参表 ) { 重载处理 } 具体例子 1 2 3 4 5 6 7 8 9 10 11 12 13 complex complex::operator + (const complex \u0026amp;c1 , const complex \u0026amp;c2) { complex c ; c.real = c2.real+c1.real ; c.imag = c2.imag+c1.imag ; return c ; } complex complex::operator - (const complex \u0026amp;c1 , const complex \u0026amp;c2) { complex c ; c.real = c1.real-c2.real ;、 c.imag = c1.imag-c2.imag ; return c ; } 重载\u0026laquo;和\u0026raquo;运算符 \u0026laquo;重载函数和\u0026raquo;重载函数只能定义为友元函数，不能定义为成员函数， 因为\u0026laquo;和\u0026raquo;运算符有两个形参，并且第一个形参不是自定义类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //类中的友元函数定义 //***********************************// friend istream\u0026amp; operator \u0026gt;\u0026gt; (istream\u0026amp; , complex\u0026amp;);//istream类\u0026gt;\u0026gt;运算符重载 friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; , complex\u0026amp;);//ostream类\u0026lt;\u0026lt;运算符重载 //***********************************// //复数的自定义输入输出 istream\u0026amp; operator \u0026gt;\u0026gt; (istream\u0026amp; input , complex\u0026amp;c ) { input \u0026gt;\u0026gt; c.real \u0026gt;\u0026gt; c.imag ; return input ; } ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; output , complex\u0026amp;c ) { output \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#39;+\u0026#39; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; \u0026#39;i\u0026#39; \u0026lt;\u0026lt; endl ; return output ; } 重载单目运算符 成员函数重载 前置++\n1 2 //前置 complex operator ++(); 后置++\n1 2 3 //后置 complex operator ++(int); //如果在形参中添加int占位参数，编译器会识别出这是后置++ 友元函数重载 前置++\n1 2 //前置 friend complex operator ++ (complex); 后置++\n1 friend complex operator ++ (complex,int); 运算符重载的规则（看个乐呵就行） • 运算符重载不允许发明新的运算符。如@ • 不能改变运算符操作对象的个数，如+是双目运算 • 运算符被重载后，优先级和结合性不会改变 • 经重载的运算符至少有一个参数为自定义类型，否则系 统已经实现\n运算符重载的实现形式 运算符重载函数可以声明为 类成员函数 也可以是 类的友元函数 ，还可以是 普通函数\n推荐使用成员函数或是友元函数实现 （主要因为私有成员的访问问题） 实现运算符重载的方式\u0026mdash;\u0026mdash;既然是操作符重载，一般会访问类的私有成员变量，根据类的封装性要求，除了友元函数外，其他任何外部操作都是违规的，所以不推荐用 普通函数 来重载操作符\n","date":"2025-09-04T10:13:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E9%87%8D%E8%BD%BD/","title":"C++ 重载"},{"content":"C++ 引用 | 菜鸟教程\n什么是引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字 一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量 引用必须在定义时初始化，并且一旦绑定到一个变量后，就不能再绑定到其他变量\n1 2 int a = 10; int \u0026amp;ref = a; // ref 是 a 的引用 解释：\nint \u0026amp;ref 表示 ref 是一个 int 类型的引用 ref 是 a 的别名，对 ref 的操作会直接作用于 a 引用与指针 引用很容易与指针混淆，它们之间有三个主要的不同：\n不存在空引用，引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 引用的对象必须是一个变量，而指针必须是一个地址。 特性 引用 指针 定义与初始化 必须初始化，且不能为 null。 可以不初始化，可以在后续代码中指向其他对象，可以为 null。 语法 使用 \u0026amp; 声明，例如：int \u0026amp;ref = a; 使用 * 声明，例如：int *ptr = \u0026amp;a; 重新绑定 不能重新绑定，一旦初始化后始终引用同一个对象。 可以重新指向其他对象，例如：ptr = \u0026amp;b; 空值（Nullability） 不能为 null，必须绑定到有效的对象。 可以为 null，表示不指向任何对象。 内存占用 不占用额外内存（编译器通常将其优化为直接操作所引用的对象）。 占用额外内存（存储地址，通常是一个机器字长，如4字节或8字节）。 访问方式 直接使用，无需解引用操作符，例如：ref = 10; 需要使用 * 解引用操作符访问或修改所指向的对象，例如：*ptr = 10; 多级间接访问 不支持多级间接访问（不能有引用的引用）。 支持多级间接访问（如指针的指针：int **pptr;）。 函数参数传递 常用于函数参数传递，语法简洁，例如：void func(int \u0026amp;x) { x = 10; } 也可以用于函数参数传递，但需要使用解引用操作符，例如：void func(int *x) { *x = 10; } 数组与引用 不能直接创建引用数组，但可以创建数组的引用，例如：int (\u0026amp;ref)[10] = arr; 可以创建指针数组，也可以创建指向数组的指针，例如：int *ptrArr[10]; 安全性 更安全，不能为 null，且语法更直观。 更灵活，但容易出错（如空指针、野指针等）。 底层实现 通常通过指针实现，但编译器会优化为直接操作所引用的对象。 直接存储目标对象的内存地址。 创建引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; int main () { // 声明简单的变量 int i; double d; // 声明引用变量 int\u0026amp; r = i; double\u0026amp; s = d; i = 5; cout \u0026lt;\u0026lt; \u0026#34;Value of i : \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of i reference : \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; d = 11.7; cout \u0026lt;\u0026lt; \u0026#34;Value of d : \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of d reference : \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 输出\n1 2 3 4 Value of i : 5 Value of i reference : 5 Value of d : 11.7 Value of d reference : 11.7 引用的一些用法 引用作为函数参数 直接交换是交换的形参，用引用就可以交换实值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; // 函数声明 void swap(int\u0026amp; x, int\u0026amp; y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u0026lt;\u0026lt; \u0026#34;交换前，a 的值：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换前，b 的值：\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; /* 调用函数来交换值 */ swap(a, b); cout \u0026lt;\u0026lt; \u0026#34;交换后，a 的值：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;交换后，b 的值：\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } // 函数定义 void swap(int\u0026amp; x, int\u0026amp; y) { int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } 输出\n1 2 3 4 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 引用作为函数返回值 通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似\n当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0}; double\u0026amp; setValues(int i) { double\u0026amp; ref = vals[i]; return ref; // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i] } // 要调用上面定义函数的主函数 int main () { cout \u0026lt;\u0026lt; \u0026#34;改变前的值\u0026#34; \u0026lt;\u0026lt; endl; for ( int i = 0; i \u0026lt; 5; i++ ) { cout \u0026lt;\u0026lt; \u0026#34;vals[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34;; cout \u0026lt;\u0026lt; vals[i] \u0026lt;\u0026lt; endl; } setValues(1) = 20.23; // 改变第 2 个元素 setValues(3) = 70.8; // 改变第 4 个元素 cout \u0026lt;\u0026lt; \u0026#34;改变后的值\u0026#34; \u0026lt;\u0026lt; endl; for ( int i = 0; i \u0026lt; 5; i++ ) { cout \u0026lt;\u0026lt; \u0026#34;vals[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34;; cout \u0026lt;\u0026lt; vals[i] \u0026lt;\u0026lt; endl; } return 0; } 输出\n1 2 3 4 5 6 7 8 9 10 11 12 改变前的值 vals[0] = 10.1 vals[1] = 12.6 vals[2] = 33.1 vals[3] = 24.1 vals[4] = 50 改变后的值 vals[0] = 10.1 vals[1] = 20.23 vals[2] = 33.1 vals[3] = 70.8 vals[4] = 50 当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用\n","date":"2025-09-04T10:12:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E5%BC%95%E7%94%A8/","title":"C++ 引用"},{"content":"基于菜鸟教程和课件的个人学习笔记\n引言 C++的类有构造函数和析构函数用于初始化和清理对象 两个函数都会被自动调用，不自定义构造函数和析构函数，编译器会自动提供两个函数的空实现\n构造函数\u0026amp;析构函数 构造函数：主要作用于创建函数时对对象成员的属性赋值 析构函数：主要作用于对象销毁前，执行清理工作（比如释放new开辟在堆区的空间） 构造函数和析构函数是一种特殊的公有成员函数，每一个类都有一个默认的构造函数和析构函数 构造函数在类定义时由系统自动调用，析构函数在类被销毁时由系统自动调用 构造函数的名称和类名相同，一个类可以有多个构造函数，不同的构造函数之间通过参数个数和参数类型来区 一个类只能有一个析构函数 可以在构造函数中给类分配资源，在类的析构函数中释放对应的资源 如果程序员没有提供构造和析构，系统会默认提供空实现 构造函数和析构函数，必须定义在public里面，才可以调用 构造函数 构造函数可用于为某些成员变量设置初始值 类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行\n构造函数定义形式 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void\n1 类名(形参表); 例子 1 2 3 4 5 6 7 8 9 10 11 12 class complex { public: complex();//默认构造函数 complex(double,double);//初始化构造函数 complex(double);//强制转换构造函数 complex operator + (complex);//运算符重载 complex operator - (complex);//运算符重载 friend istream\u0026amp; operator \u0026gt;\u0026gt; (istream\u0026amp; , complex\u0026amp;);//istream类\u0026gt;\u0026gt;运算符重载 friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; , complex\u0026amp;);//ostream类\u0026lt;\u0026lt;运算符重载 private: double real , imag ; }; 构造函数特点 构造函数可以有参数，所以允许构造函数重载\n无参构造函数与全缺省函数 全缺省构造函数和无参可能会在调用的时候出问题，并不是不可以同时存在（构成函数重载），而是调用出现歧义 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个 无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。（一般情况写全缺省） 无参数构造函数（默认构造函数） 1 2 3 4 //类外实现 complex::complex() { real = 0 ;imag = 0 ; } 有参数构造函数（初始化构造函数） 括号内的名字为个人感悟所起\n1 2 3 4 //类外实现 complex::complex(double r , double i ) { real = r ; imag = i ; } 有特殊语法规则\n使用初始化列表来初始化字段 1 2 3 complex::complex(double r , double i ):real(r),imag(i) { cout \u0026lt;\u0026lt; \u0026#34;特殊语法规则,使用初始化列表来初始化字段\u0026#34; \u0026lt;\u0026lt; endl ; } 强制转换构造函数 1 2 3 4 5 6 7 8 9 10 11 12 //类外实现 complex::complex(double r ) { real = r ; imag = 0 ; } //主函数内的调用 int main() { complex c1(2.5,6.7) , c2(3.5,7.6) ; complex c = c1+c2+complex(2.0) ;//强制转换的作用 cout \u0026lt;\u0026lt; c ; return 0 ; } 析构函数 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。 析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源\n析构函数定义形式 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数\n1 ~类名(); 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Student { public: void Print() { cout \u0026lt;\u0026lt; \u0026#34;学生姓名：\u0026#34; \u0026lt;\u0026lt; _name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;学生年龄：\u0026#34; \u0026lt;\u0026lt; _age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;学生学号：\u0026#34; \u0026lt;\u0026lt; _ID \u0026lt;\u0026lt; endl; } ~Student() {//析构函数 cout \u0026lt;\u0026lt; \u0026#34;~Student()\u0026#34; \u0026lt;\u0026lt;endl ; } private: char _name[20]; int _age; char _ID[20]; }; int main() { Student stu1;//调用默认构造函数 stu1.Print(); return 0; } 析构函数特点 没有参数，不允许重载，一个类只能由一个析构函数\n","date":"2025-09-04T10:09:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/","title":"C++ 构造函数与析构函数"},{"content":"基于菜鸟教程，课件的学习内容的个人笔记\n前言 C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型\n面向对象程序设计 将客观事物看作具有属性和行为的对象 将数据（属性）及对数据的操作方法（行为）封装在一起，作为一个整体——对象\n类是对象的抽象，对象是类的特例（具体实例）\n类 类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合 类中的数据称为成员变量，函数称为成员函数 类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象\n类是对象的抽象 类是抽象的，不占用内存，对象是具体的， 占用实际的存储空间\n定义类 定义一个类的例子 （1）class关键字+类名 （2）访问修饰符+成员（成员变量/成员函数）\n模板：\n1 2 3 4 5 class classname { Access specifiers: //访问修饰符：private/public/protected Data members ; //变量（成员变量） Member functions(); //声明了方法，成员函数，并未实现 };// 要以分号结束 具体例子：\n1 2 3 4 5 6 class student { public: int _id_ , _age_ ; string _name_ ; string _sex_ ; };// 要以分号结束 public关键字，定义了类的成员的访问属性 public关键字允许类的子类，以及类外类内的访问\n在类外定义成员函数的一般形式 C++ 成员函数与友元函数\n1 2 3 4 5 返回值类型 类名::成员函数名(参数表) { … … //函数体 } 其中::是作用域运算符。 例子\n1 2 3 void Student::get_value() { cin\u0026gt;\u0026gt; num \u0026gt;\u0026gt; name \u0026gt;\u0026gt; sex ; } 访问类的成员（数据成员） （1）类的对象的public成员可以直接使用成员访问运算符 . 来访问 需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问 （2）类的成员之间可以互相访问\n类成员的访问权限 公有的(public) ：对外接口，任何外部函 数都可以访问公有类型数据和函数\n私有的(private)：只允许本类中的成员函 数访问（友元除外）\n受保护的(protected): 与private类似，其差别表现在还可以被派生类的成员函数访问\n对象 对象是类的具体实例 定义一个类，并定义一个该类的（实例）对象\n1 2 3 4 5 6 7 8 9 10 class student {// 定义了一个student类 public: string _name_ ; string _sex_ ; int _id_ , _age_ ; };// 一定要以分号结束 //定义了一个student类的对象 student stu1 ; 需要注意的是，在定义类的时候，只是声明，并未给类的成员分配内存空间 在定义类的实例对象后，再给定义的对象分配空间\n类只是模板，是虚的 对象是类的实例，是实际的\n类与对象的相关概念 类成员函数 类访问修饰符 构造函数 \u0026amp; 析构函数 友元函数 this指针 类的静态成员静态 虚函数 虚基类 类的功能 继承与派生 多态 ","date":"2025-09-04T10:09:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","title":"C++ 类与对象"},{"content":"虚函数定义 虚函数是用关键字virtual修饰的某基类中的 protected或public成员函数。它可以在派生类中 重新定义，以形成不同版本。只有在程序的执 行过程中，依据指针具体指向哪个类对象，或 依据引用哪个类对象，才能确定激活哪一个版 本，实现动态关联\n可以在程序运行时通过调用相同的函数名而实现不同功能的函数称为虚函数\n虚函数的声明与特点 1 virtual FuncName(参数列表); 一旦把基类的成员函数定义为虚函数，由基类 所派生出来的所有派生类中，该函数均保持虚函数的特性 在派生类中重新定义基类中的虚函数时，可以不用关键字virtual来修饰这个成员函数\n虚函数实例 虚函数实现动态多态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class A{ protected: int x; public: A(){ x =1000; } virtual void print(){ //虚函数 cout \u0026lt;\u0026lt; \u0026#34;x=\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl ; } }; class B:public A{ int y; public: B() { y=2000; } void print() { //派生虚函数 cout \u0026lt;\u0026lt; \u0026#34;y=\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl ; } }; class C:public A{ int z; public: C(){ z=3000; } void print(){ //派生虚函数 cout \u0026lt;\u0026lt; \u0026#34;z=\u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl ; } }; void main(void ) { A a, *pa; B b; C c; a.print(); b.print(); c.print(); //以上为静态关联 pa=\u0026amp;a; pa-\u0026gt;print(); //调用类A的虚函数 pa=\u0026amp;b; pa-\u0026gt;print(); //调用类B的虚函数 pa=\u0026amp;c; pa-\u0026gt;print();//调用类C的虚函数 } 纯虚函数 在基类中不对虚函数给出有意义的实现，它只是在派生类中有具体的意义。这时基类中的虚函数只是一个入口，具体的目的地由不同的派生类中的对象决定。 这个虚函数称为纯虚函数。 包含纯虚函数的类为抽象类。\n1 2 3 4 5 6 7 8 9 10 11 12 class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } // pure virtual function virtual int area() = 0; }; virtual int area() = 0告诉编译器，函数没有主体，上面的虚函数是纯虚函数\n虚函数使用注意事项 当在基类中把成员函数定义为虚函数后， 在其派生类中定义的虚函数必须与基类中的虚函数 同名，参数的类型、顺序、数量必须一一 对应，函数的返回的类型也相同 若函数名相同，但参数的个数不同或者参数的类型不同时，则属于函数的重载，而不是虚函数。 若函数名不同，显然这是不同的成员函数\n实现这种动态的多态性时，必须使用 基类 类型的指针变量，并使该指针指向不同的派生类 对象，并通过调用指针所指向的虚函数才能实现动态的多态性 ，即在程序运行时，通过赋值语句实现多态性\n虚函数必须是类的一个成员函数，不能是 友元函数，也不能是 静态成员函数 (所有对象共有， 无法重新定义)\n可把析构函数定义为虚函数，但是，不能将 构造函数定义为虚函数\n一个函数如果被定义成虚函数，则不管经历 多少次派生，仍将保持其虚特性，以实现“一个 接口，多个形态”\n虚函数与一般的成员函数相比较，调用时的 执行速度要慢一些。为了实现多态性，在每一 个派生类中均要保存相应虚函数的入口地址表， 函数的调用机制也是间接实现的。因此，除了 要编写一些通用的程序，并一定要使用虚函数 才能完成其功能要求外，通常不必使用虚函数\n","date":"2025-09-04T10:09:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E8%99%9A%E5%87%BD%E6%95%B0/","title":"C++ 虚函数"},{"content":"多态，静态多态和动态多态\n多态的定义 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 多态性：调用同一个函数名，但可以根据需要实 现不同的功能。(消息相同，响应不同)\n运行时的多态性是指在程序执行之前，根据函数名和 参数无法确定应该调用哪一个函数，必须在程序的执 行过程中，根据具体的执行情况来动态地确定\n静态多态（函数重载） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout \u0026lt;\u0026lt; \u0026#34;Parent class area :\u0026#34; \u0026lt;\u0026lt;endl; return 0; } }; class Rectangle: public Shape{ public: Rectangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area :\u0026#34; \u0026lt;\u0026lt;endl; return (width * height); } }; class Triangle: public Shape{ public: Triangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u0026lt;\u0026lt; \u0026#34;Triangle class area :\u0026#34; \u0026lt;\u0026lt;endl; return (width * height / 2); } }; // 程序的主函数 int main( ) { Shape *shape; Rectangle rec(10,7); Triangle tri(10,5);// 存储矩形的地址 shape = \u0026amp;rec;// 调用矩形的求面积函数 area shape-\u0026gt;area();// 存储三角形的地址 shape = \u0026amp;tri;// 调用三角形的求面积函数 area shape-\u0026gt;area(); return 0; } 输出结果\n1 2 Parent class area : Parent class area : 调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。\n动态多态 在 Shape 类中，area() 的声明前放置关键字 virtual\n虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } virtual int area() { cout \u0026lt;\u0026lt; \u0026#34;Parent class area :\u0026#34; \u0026lt;\u0026lt;endl; return 0; } }; 输出结果\n1 2 Rectangle class area : Triangle class area : 若要基类指针访问派生类中相同名字的函数，必须将基类中的同名函数定义为虚函数， 这样，将不同的派生类对象的地址赋给基类的指针变量后，就可以动态地根据这种赋值语句 调用不同类中的函数(动态绑定、动态关联)\n动态多态实现注意事项 可以将一个派生类对象的地址赋给基类的指针变量\n基类指针，只能引用从基类继承来的成员 使用基类的指针时，只能访问从相应基类中继承来的成员，而 不允许访问在派生类中增加的成员\n","date":"2025-09-04T10:08:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E5%A4%9A%E6%80%81/","title":"C++ 多态"},{"content":"引言 在内存中，程序为保存某种类型数据如数组而分配 一块内存空间。 用完后就需要把先前占用的内存空间释放给内存， 以后重新分配，供程序的其它部分使用\nnew运算符（对应malloc函数） 1 指针变量 = new 数据类型; new从内存中分配内存空间，并返回指向该内 存的首地址，该地址存放于指针变量中\ndelete运算符（对应free函数） 运算符delete用于释放new分配的内存空间， 它的使用形式为\n1 delete 指针变量; 其中的指针变量保存着new动态分配的内存的首地址\n注意 (a) 用new获取的内存空间，必须用delete进行释放； ( (b) 对一个指针只能调用一次delete； (c) 用delete运算符作用的对象必须是用new分配的内 存空间的首地址。\n实例 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int *p; p=new int; // 分配内存空间 *p=5; cout\u0026lt;\u0026lt;*p; delete p; }// 释放内存空间 用new建立数组类型的变量 1 指针变量 = new 数据类型[数组大小] ; 此时指针变量指向第一个数组元素的地址。使用new 分配数组时，不能提供初始值\n使用new建立的数组 变量也由delete释放，其形式为:\n1 delete 指针变量; 同样，也可以用new来为多维数组分配空间，但是除第一维可以为变量外，其它维数都必须是常量\n注意在使用delete时，不用考虑数组的维数。 有时，并不能保证一定可以从堆内存中获得所需空间，当不能成功地分配到所需要的内存时，new返回0，即空指针。因此我们可以通过判断new的返回值是否为0，来得知系统中是否有足够的空闲内存来供程序使用\n例子 1 2 3 4 5 int *p= new int[100]; if(p==0) { cout\u0026lt;\u0026lt;“can’t allocate more memory,terminating.\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } 一维数组\n1 2 3 4 5 // 动态分配,数组长度为 m int *array=new int [m]; //释放内存 delete [] array; 二维数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int **p; int i,j; //p[4][8] //开始分配4行8列的二维数据 p = new int *[4]; for(i=0;i\u0026lt;4;i++){ p[i]=new int [8]; } for(i=0; i\u0026lt;4; i++){ for(j=0; j\u0026lt;8; j++){ p[i][j] = j*i; } } //打印数据 for(i=0; i\u0026lt;4; i++){ for(j=0; j\u0026lt;8; j++) { if(j==0) cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;p[i][j]\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;; } } //开始释放申请的堆 for(i=0; i\u0026lt;4; i++){ delete [] p[i]; } delete [] p; return 0; } 三维数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int ***array; // 假定数组第一维为 m， 第二维为 n， 第三维为h // 动态分配空间 array = new int **[m]; for( int i=0; i\u0026lt;m; i++ ) { array[i] = new int *[n]; for( int j=0; j\u0026lt;n; j++ ) { array[i][j] = new int [h]; } } //释放 for( int i=0; i\u0026lt;m; i++ ) { for( int j=0; j\u0026lt;n; j++ ) { delete[] array[i][j]; } delete[] array[i]; } delete[] array; ","date":"2025-09-04T10:04:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BEnewdelete/","title":"C++ 动态内存的分配与释放(new\u0026delete)"},{"content":"跟着下面的视频，系统梳理复习过往的嵌入式知识，同时也算是 电控成长指南 的一个 部分 实现，能有效且快速的建立一个嵌入式系统和工具链的整体认知\n【《从CPU架构到操作系统实现》系列课程 - Git 开源】https://www.bilibili.com/video/BV1ksNCzXEny?vd_source=5a0790755035f26a67935abfbfcdfd5b\n视频中详细且硬核的实例不会出现在此笔记中\n概述 关于ARM架构 目前arm内核主要演变分为Cortex-X，Cortex-A，Cortex-R，Cortex-M\nCortex-A：应用处理器，设计用来处理复杂应用（例如高端嵌入操作系统Linux，iOS，Android，Windows），对标PC和手机处理器的性能\nCortex-X：比Cortex-M更高的性能\nCortex-R：Real-time，主要用于实时系统\nCortex-M：Microcontrol，微处理器\nCortex-M优点 低功耗 高性能 中断易用 代码密度高（原因在于指令集） 可调式 支持操作系统 哈佛架构，指令与数据在同一内存 指令集 多套指令集用于处理不同的场景\n1.CISC（Complex Instruction Set Computer） 复杂指令系统计算机，CISC指令集包含大量复杂的指令，每条指令可以完成多个操作，这种设计使得编程简单，但硬件实现复杂，执行效率低\nx86架构（Intel的8086，8088，80286，80386）\n2.RISC（Reduced Instruction Set Computer） 精简指令系统计算机，RISC指令集包含较少的简单指令，每条指令只完成一个操作，使得硬件实现更简单，执行效率更高，但编程更复杂\nARM架构，RISC-V架构，MIPS架构\n开发环境（DEV） GUN-GCC编译器，CMake-\u0026gt;makefile STM32F103C8（C8T6）经典控制器（Cortex-M3）\n编译 编译链工具 ARM-Cortex-M处理器的编译器很多，常用的是MDK-ARM(ARM公司自研的)(Keil)，以及GCC(GNU-Compiler-Collection)\n编译器之间的最大区别在于汇编伪代码，链接语法，还有使用参数 arm-none-eabi\narm是指arm架构，none是指编译出的可执行文件是运行在硬件上，而不是操作系统上，eabi(The Embedded-Application Binary Interface)嵌入式应用二进制接口\narm-none-eabi-objcopy是一个二进制生成工具\n嵌入式编译烧录流程 个人更喜欢将编译过程拆解为 预编译，编译，汇编，链接\n转换这里是将.elf文件转换为.bin文件 .bin文件是代码的纯机器码\n一文看懂hex文件、bin文件、axf文件的区别 - 知乎\n预编译 将所有头文件和宏展开，同时去掉注释，生成.i文件（c中间文件）\n编译 将.i文件编译为.s汇编文件，编译优化发生在此处\n汇编 将.s文件汇编为.o二进制文件（机器码） 二进制文件中还包含很多的其他信息\n在汇编时，可以指定汇编器的参数来选择指令集\n链接 链接是将各个二进制文件里面的机器码所在的各个段拼接起来，以形成可执行文件.elf（带有调试信息）\n在链接这个阶段才能检测出有不有重复定义和未定义的错误\n对于GNU来说，可以编写.ld链接脚本来编排代码的分区地址\n转换 通过转换器能将.elf文件转换为.hex和.bin文件，主要用于提取信息\n.bin文件只包含二进制机器码 .hex文件是Intel定义的包含地址和二进制数值的ASC码文本文件\n烧录 烧录的过程是将编译好的机器码写到CPU存储器中\n反汇编 GCC中的反汇编工具Disassembler是arm-none-eabi-objdump\n启动 主要是讲解STM32的启动流程\n中断向量表 中断向量表的构建，根据不同的编译工具，有不同的方式构建\n中断向量表的前两项（.woed，4字节）是最关键的 第一项是堆栈指针的值 第二项是Reset_Handler函数入口\n在启动时，需要先设置堆栈指针，否则无法进行压栈的操作，从宏观上说，意味着C语言函数体不能调用子函数\nVTOR寄存器，中断向量表偏移寄存器\n启动原理 启动后，从零地址（零地址是经过映射的）出读取堆栈指针和程序计数器的值（此时程序计数器的值指向Reset_Handler），此外每个芯片的Boot code是定制化的，需要参考手册\n最后Reset_Handler会指向main函数\n以STM32F103为例 这里有三种启动模式，根据启动时BOOT1和BOOT0的电平来选择不同的启动地址（即 将该不同的地址映射为零地址），一般情况下是第一种\nRAM内存分布 启动文件详解 一、STM32F103 启动文件（startup_stm32f103xb.s）核心定位 STM32 的启动文件（如startup_stm32f103xb.s）是汇编语言编写的底层程序，是硬件复位后执行的第一段代码，负责衔接 “硬件初始化” 与 “用户 C 代码（main函数）”。其核心功能包括：设置栈指针、构建中断向量表、初始化数据段（.data）、清零未初始化数据段（.bss）、配置系统时钟，最终引导程序进入main函数，是 STM32 程序运行的 “底层基石”。\n二、启动文件整体结构拆解 该启动文件按功能可划分为 5 个核心模块，各模块职责明确且环环相扣：\n汇编环境配置：指定处理器架构、指令集、浮点模式，确保汇编代码与硬件兼容。 关键符号声明：引用链接器脚本（.ld）中定义的内存地址符号，建立启动文件与内存布局的关联。 复位处理函数（Reset_Handler）：复位后执行的核心逻辑，完成初始化并跳转到main。 中断向量表（g_pfnVectors）：存储所有异常 / 中断的处理函数地址，供内核响应中断时调用。 默认中断处理函数（Default_Handler）：未自定义的中断会默认进入此处，避免系统崩溃。 三、逐段解析启动文件代码 1. 汇编环境配置（开头基础设置） 1 2 3 4 .syntax unified ; 使用统一汇编语法（兼容ARM与Thumb指令集） .cpu cortex-m3 ; 目标处理器为Cortex-M3（STM32F103内核型号） .fpu softvfp ; 浮点模式：软件模拟（STM32F103无硬件FPU） .thumb ; 启用Thumb指令集（Cortex-M3仅支持Thumb/Thumb2指令） 作用：告诉汇编器（如arm-none-eabi-as）“如何编译这段代码”，确保生成的指令能被 STM32F103 正确执行。 关键细节：softvfp对应 STM32F103 的硬件特性 —— 该型号无硬件浮点处理单元（FPU），需通过软件模拟浮点运算，与之前解析的.ld文件中未配置 FPU 参数完全匹配。 2. 关键符号声明（与链接器脚本联动） 1 2 3 4 5 6 7 8 9 10 11 .global g_pfnVectors ; 全局符号：中断向量表（供链接器识别并分配地址） .global Default_Handler ; 全局符号：默认中断处理函数（供中断向量表引用） /* 引用链接器脚本（.ld）中定义的内存地址符号 */ .word _sidata ; .data段在FLASH中的加载地址（LMA，初始值存放位置） .word _sdata ; .data段在RAM中的运行起始地址（VMA，变量实际存储位置） .word _edata ; .data段在RAM中的运行结束地址 .word _sbss ; .bss段在RAM中的起始地址（未初始化变量存储区） .word _ebss ; .bss段在RAM中的结束地址 .equ BootRAM, 0xF108F85F ; 定义RAM启动模式的特殊地址（仅用于特定boot配置） 核心意义：通过.word指令声明的符号，直接引用.ld文件中根据硬件内存布局（64K FLASH、20K RAM）计算出的地址。例如： _sdata和_edata确定了.data段在 RAM 中的范围，_sidata确定了其初始值在 FLASH 中的位置，为后续 “数据段复制” 提供地址依据。 若缺少这些符号，启动文件无法知道 “数据该从哪里复制到哪里”，内存初始化会彻底失败。 3. 复位处理函数（Reset_Handler：启动核心逻辑） Reset_Handler是复位后执行的第一个函数（由中断向量表指定），对应 STM32 启动流程中的 “软件初始化” 阶段，代码逻辑可分为 5 步：\nasm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 .section .text.Reset_Handler ; 将函数放入.text段（代码段，.ld中分配到FLASH） .weak Reset_Handler ; 弱定义：允许用户代码重定义该函数（覆盖默认逻辑） .type Reset_Handler, %function ; 标记为函数类型（汇编器识别函数边界） Reset_Handler: /* 步骤1：初始化系统时钟 */ bl SystemInit ; 跳转到STM32库函数SystemInit（配置HSE/PLL，将时钟从8MHz HSI切换到72MHz） /* 步骤2：复制.data段（从FLASH到RAM） */ ldr r0, =_sdata ; r0 = .data段在RAM的起始地址（VMA） ldr r1, =_edata ; r1 = .data段在RAM的结束地址 ldr r2, =_sidata ; r2 = .data段在FLASH的加载地址（LMA） movs r3, #0 ; r3 = 偏移量（初始为0，每次复制4字节后递增） b LoopCopyDataInit ; 跳转到循环复制入口 CopyDataInit: ldr r4, [r2, r3] ; 从FLASH读取数据：r4 = *(r2 + r3)（源地址=加载地址+偏移量） str r4, [r0, r3] ; 写入RAM：*(r0 + r3) = r4（目标地址=运行地址+偏移量） adds r3, r3, #4 ; 偏移量+4（32位数据，每次复制1个word） LoopCopyDataInit: adds r4, r0, r3 ; r4 = 当前复制位置（运行地址+偏移量） cmp r4, r1 ; 比较当前位置与结束地址：是否复制完成？ bcc CopyDataInit ; 若未完成（r4 \u0026lt; r1），继续循环复制 /* 步骤3：清零.bss段（未初始化变量区） */ ldr r2, =_sbss ; r2 = .bss段在RAM的起始地址 ldr r4, =_ebss ; r4 = .bss段在RAM的结束地址 movs r3, #0 ; r3 = 0（用于清零） b LoopFillZerobss ; 跳转到循环清零入口 FillZerobss: str r3, [r2] ; 将0写入当前地址：*r2 = 0 adds r2, r2, #4 ; 地址+4（每次清零1个word） LoopFillZerobss: cmp r2, r4 ; 比较当前地址与结束地址：是否清零完成？ bcc FillZerobss ; 若未完成（r2 \u0026lt; r4），继续循环清零 /* 步骤4：初始化C++静态构造函数（兼容C++项目） */ bl __libc_init_array ; 调用C库函数，执行全局对象构造（纯C项目可忽略，不影响运行） /* 步骤5：跳转到用户main函数 */ bl main ; 跳转到用户C代码的main函数（启动流程结束，交权给用户） bx lr ; 若main函数返回（实际中main通常是死循环），跳回当前位置（无实际意义） .size Reset_Handler, .-Reset_Handler ; 定义函数大小（.表示当前地址，计算函数长度） 关键步骤解读： 系统时钟初始化（SystemInit）：STM32 复位后默认使用 8MHz 的内部高速时钟（HSI），SystemInit函数会配置外部高速时钟（HSE）和锁相环（PLL），将系统时钟提升到 72MHz（F103 的常用工作频率），确保外设和 CPU 高效运行。 .data 段复制：.data段存储 “已初始化的全局 / 静态变量”（如int a = 10;），这些变量需要读写权限，因此运行时必须在 RAM 中；但编译时其初始值会存放在 FLASH（节省 RAM），需通过此步骤复制到 RAM。 .bss 段清零：.bss段存储 “未初始化的全局 / 静态变量”（如int b;），C 语言标准要求其初始值为 0，因此无需在 FLASH 中存储初始值，直接将 RAM 对应区域清零即可。 跳转到main：这是启动文件的 “最终目标”—— 完成所有底层初始化后，将程序控制权交给用户代码，正式进入应用逻辑。 4. 中断向量表（g_pfnVectors：中断响应的 “地址簿”） 中断向量表是Cortex-M3 内核复位后访问的第一个数据结构，存储了所有异常（如复位、硬 fault）和外设中断（如串口、定时器）的处理函数地址。当发生中断 / 异常时，内核会从向量表中找到对应地址，跳转到处理函数执行。\nasm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 .section .isr_vector,\u0026#34;a\u0026#34;,%progbits ; 将向量表放入.isr_vector段（.ld中分配到FLASH起始地址0x8000000） .type g_pfnVectors, %object ; 标记为数据对象（而非函数） .size g_pfnVectors, .-g_pfnVectors ; 定义向量表大小（计算表的总字节数） g_pfnVectors: .word _estack ; 第0个元素：栈顶地址（MSP初始值，来自.ld文件） .word Reset_Handler ; 第1个元素：复位处理函数地址（复位后PC指向这里） .word NMI_Handler ; 第2个元素：不可屏蔽中断（NMI）处理函数 .word HardFault_Handler ; 第3个元素：硬fault异常处理函数（严重错误，如内存访问越界） .word MemManage_Handler ; 第4个元素：内存管理异常处理函数 .word BusFault_Handler ; 第5个元素：总线fault异常处理函数（如访问不存在的外设地址） .word UsageFault_Handler ; 第6个元素：用法fault异常处理函数（如指令错误） .word 0 ; 第7-10个元素：保留（未使用） .word 0 .word 0 .word 0 .word SVC_Handler ; 第11个元素：系统服务调用（SVC）处理函数（OS常用） .word DebugMon_Handler ; 第12个元素：调试监控处理函数 .word 0 ; 第13个元素：保留 .word PendSV_Handler ; 第14个元素：PendSV异常处理函数（任务切换常用） .word SysTick_Handler ; 第15个元素：系统滴答定时器（SysTick）处理函数 /* 以下为外设中断向量（第16个元素开始） */ .word WWDG_IRQHandler ; 窗口看门狗中断 .word PVD_IRQHandler ; 电源电压检测中断 .word TAMPER_IRQHandler ; 篡改检测中断 .word RTC_IRQHandler ; RTC时钟中断 .word FLASH_IRQHandler ; FLASH操作中断 .word RCC_IRQHandler ; RCC时钟控制中断 .word EXTI0_IRQHandler ; 外部中断0（如PA0）中断 ...（省略其余外设中断，共60+个，对应F103所有外设）... .word BootRAM ; RAM启动模式的特殊地址（仅用于从RAM启动，默认从FLASH启动时无用） 核心特性： 位置固定：在.ld文件中，.isr_vector段被强制分配到 FLASH 起始地址（0x8000000），这是 Cortex-M3 内核的硬件规定 —— 复位后内核会自动从0x8000000读取向量表。 第 0 个元素必为栈顶：内核复位后做的第一件事是 “初始化栈指针（MSP）”，因此向量表第 0 个元素必须是栈顶地址（_estack，来自.ld 文件），否则后续函数调用、局部变量存储会因栈地址错误崩溃。 中断优先级隐含：向量表中元素的顺序对应中断 / 异常的优先级（靠前的优先级更高），例如 “硬 fault”（第 3 个元素）优先级高于 “SysTick”（第 15 个元素）。 5. 默认中断处理函数（Default_Handler：中断 “兜底” 逻辑） 当用户未为某个中断定义处理函数时，中断向量表会将该中断的地址指向Default_Handler，避免系统因 “找不到中断处理函数” 而进入未知状态。\n1 2 3 4 5 .section .text.Default_Handler,\u0026#34;ax\u0026#34;,%progbits ; 放入.text段，属性为可执行（ax） Default_Handler: Infinite_Loop: b Infinite_Loop ; 无限循环（死循环），防止程序跑飞 .size Default_Handler, .-Default_Handler ; 定义函数大小 弱别名机制（用户可重定义中断函数） 启动文件通过 “弱别名（.weak）” 允许用户在 C 代码中重定义中断处理函数，具体逻辑如下：\n1 2 .weak NMI_Handler ; 弱定义：NMI_Handler可被用户代码覆盖 .thumb_set NMI_Handler,Default_Handler ; 若用户未定义，NMI_Handler默认指向Default_Handler 工作原理： .weak标记表示 “该符号是弱定义的，若用户定义了同名符号，优先使用用户定义的版本”。 用户只需在 C 代码中编写void USART1_IRQHandler(void) { ... }，链接时会自动覆盖启动文件中的弱定义，使串口 1 中断触发时执行用户代码。 若用户未定义，则使用默认的Default_Handler（无限循环）。 四、启动文件与链接器脚本（.ld）的配合关系 启动文件与.ld文件是紧密耦合的 “搭档”，二者通过 “全局符号” 和 “段分配” 协同工作，缺一不可：\n协作维度 启动文件角色 链接器脚本（.ld）角色 内存地址提供 引用.ld定义的_sdata、_ebss、_estack等符号 根据硬件内存布局（64K FLASH、20K RAM）计算并定义这些符号 段分配依据 将Reset_Handler放入.text段、向量表放入.isr_vector段 规定.text、.isr_vector等段的存储位置（如.isr_vector分配到 FLASH 起始地址） 程序入口指定 实现Reset_Handler函数（入口逻辑） 通过ENTRY(Reset_Handler)指定程序入口为该函数 内存合法性检查 依赖.ld确保_sdata、_ebss不超出 RAM 范围 检查堆、栈、数据段总大小是否超过 RAM/FLASH 容量，溢出则报错 五、总结：启动文件的核心价值 STM32 启动文件是 “从硬件到软件的桥梁”，其核心作用可概括为 3 点：\n硬件初始化：完成栈指针设置、系统时钟配置，为程序运行提供基础硬件环境。 内存初始化：通过复制.data段、清零.bss段，确保全局 / 静态变量符合 C 语言标准要求。 中断系统准备：构建中断向量表，提供默认中断处理逻辑，支持用户自定义中断函数。 引导用户代码：最终跳转到main函数，将程序控制权交给用户，完成 “底层初始化→应用逻辑” 的过渡。 简言之：没有启动文件，STM32 复位后无法完成任何初始化，更无法进入main函数 —— 它是 STM32 程序运行的 “第一块拼图”。 STM32 启动流程、.ld 文件作用及示例解析 要理解 STM32 的启动流程、.ld文件（链接器脚本）的作用，以及你提供的具体.ld文件内容，我们需要从宏观启动逻辑到链接器脚本细节逐步拆解，最终建立两者的关联。\n一、STM32 的启动流程（从复位到main函数） STM32 的启动流程是硬件复位→内核初始化→软件初始化→进入main 的过程，核心依赖「中断向量表」和「启动文件」，而.ld文件为这个流程提供了内存地址映射和段分配规则。\n1. 硬件复位：PC 指针的初始指向 当 STM32 上电或复位时，Cortex-M 内核会自动执行以下操作：\n读取中断向量表的第一个元素（栈顶地址_estack），初始化主栈指针（MSP）—— 这是内核执行的第一个动作，因为函数调用、局部变量都依赖栈。 将程序计数器（PC）指向中断向量表的第二个元素（Reset_Handler的地址）—— 这是复位后的第一个执行函数（启动流程的入口）。 关键：中断向量表的默认地址是0x8000000（STM32 FLASH 的起始地址），这也是.ld文件中FLASH的ORIGIN（起始地址）设置为0x8000000的原因。\n2. 执行Reset_Handler（启动文件核心逻辑） Reset_Handler是启动文件（如startup_stm32f103c8tx.s）中的汇编函数，是软件初始化的核心，其逻辑完全依赖.ld文件定义的全局符号（如_sdata、_ebss），具体步骤如下：\n初始化数据段（.data）：\n.data段存放「初始化过的全局 / 静态变量」（如int a = 10;），这些变量需要读写权限，因此运行时必须在 RAM 中；但编译时会把它们的初始值存放在 FLASH 中（节省 RAM 空间）。\nReset_Handler会执行复制操作：从.ld文件定义的_sidata（.data 在 FLASH 的加载地址）复制到_sdata（.data 在 RAM 的运行地址），直到_edata（.data 的结束地址）。\n清零未初始化数据段（.bss）：\n.bss段存放「未初始化的全局 / 静态变量」（如int b;），C 语言标准要求它们初始化为 0。\nReset_Handler会将_sbss（.bss 的起始地址）到_ebss（.bss 的结束地址）的 RAM 区域全部清零。\n初始化系统时钟（SystemInit）：\n调用SystemInit函数（由 STM32 标准库 / LL 库提供），配置 HSE/PLL 等，将系统时钟从默认的 HSI（8MHz）切换到更高频率（如 72MHz）。\n调用main函数：\n完成所有初始化后，跳转到 C 语言的main函数，进入用户应用逻辑。\n3. 异常 / 中断的触发（补充） 若程序运行中触发中断（如定时器、串口），内核会再次读取「中断向量表」，根据中断号找到对应的中断服务函数（ISR）地址，跳转到 ISR 执行，执行完成后返回断点继续运行。\n二、.ld 文件（链接器脚本）的核心作用 .ld文件是链接器（ld）的配置文件，其本质是告诉链接器：\n芯片的内存布局：FLASH（只读、存代码 / 常量）和 RAM（可读写、存变量 / 栈 / 堆）的起始地址和大小。 代码 / 数据的段分配规则：将编译生成的各个「段（Section）」（如.text、.data）分配到对应的内存区域（FLASH/RAM）。 定义全局符号：生成_sdata、_ebss、_estack等符号，供启动文件和用户代码使用（如启动文件依赖这些符号初始化内存）。 内存合法性检查：确保堆、栈、数据段的总大小不超过 RAM/FLASH 的实际容量，避免内存溢出。 简单说：没有.ld文件，链接器无法知道 “代码该放哪里、变量该放哪里”，无法生成可执行的.elf/.hex文件。 三、解析 STM32F103C8Tx 的.ld 文件 以下按文件结构逐段解析，结合 STM32F103C8Tx 的硬件参数（64K FLASH、20K RAM）说明每部分的作用。\n1. 入口点与栈顶定义 1 2 3 4 5 6 7 8 /* Entry Point */ ENTRY(Reset_Handler) // 定义程序的入口函数：Reset_Handler（与启动文件对应） /* Highest address of the user mode stack */ _estack = ORIGIN(RAM) + LENGTH(RAM); // 栈顶地址 = RAM起始地址 + RAM总大小 /* Generate a link error if heap and stack don\u0026#39;t fit into RAM */ _Min_Heap_Size = 0x200; // 最小堆大小（512字节，供malloc使用） _Min_Stack_Size = 0xF00; // 最小栈大小（3840字节，供函数调用/局部变量使用） ENTRY(Reset_Handler)：强制链接器将Reset_Handler作为程序第一个执行的函数，与启动流程中 PC 指向Reset_Handler完全对应。 _estack：定义栈顶地址（STM32F103C8Tx 的 RAM 是0x20000000~0x20004FFF，因此_estack=0x20005000），启动文件会将这个地址加载到 MSP（主栈指针）。 堆 / 栈大小：_Min_Heap_Size和_Min_Stack_Size是最小要求，若用户代码中堆 / 栈使用超过这个值，链接器会报错（防止 RAM 溢出），可根据需求调整（如栈不够时增大_Min_Stack_Size）。 2. 内存区域定义（MEMORY 块） 1 2 3 4 5 6 /* Specify the memory areas */ MEMORY { RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 20K // RAM区域 FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 64K // FLASH区域 } 这是.ld文件的核心，定义了芯片的物理内存属性：\nRAM (xrw)： xrw：权限（x= 可执行，r= 可读，w= 可写）——RAM 支持读写，理论上可执行（但通常不放代码）。 ORIGIN = 0x20000000：STM32 所有 Cortex-M3 内核芯片的 RAM 起始地址（硬件规定）。 LENGTH = 20K：STM32F103C8Tx 的 RAM 实际大小（20KB = 0x5000 字节，范围0x20000000~0x20004FFF）。 FLASH (rx)： rx：权限（r= 可读，x= 可执行，w= 不可写）——FLASH 是只读存储器，只能存放代码和常量。 ORIGIN = 0x8000000：STM32 FLASH 的起始地址（硬件规定，复位后 PC 默认指向这里）。 LENGTH = 64K：STM32F103C8Tx 的 FLASH 实际大小（64KB = 0x10000 字节，范围0x8000000~0x800FFFF）。 3. 段分配规则（SECTIONS 块） SECTIONS块是最复杂的部分，定义了「编译生成的段」如何映射到「MEMORY 块定义的物理内存」，每一个子段都对应特定的代码 / 数据类型。\n（1）.isr_vector：中断向量表（放 FLASH） 1 2 3 4 5 6 .isr_vector : { . = ALIGN(4); // 地址4字节对齐（Cortex-M内核要求，否则触发硬 fault） KEEP(*(.isr_vector)) // 保留中断向量表，防止链接器优化删除（核心！） . = ALIGN(4); } \u0026gt;FLASH // 分配到FLASH区域 作用：存放 STM32 的中断向量表（如复位向量、定时器中断向量、串口中断向量等），是复位后内核第一个访问的段。 KEEP(*(.isr_vector))：中断向量表由启动文件定义（如startup_stm32f103c8tx.s中的g_pfnVectors数组），KEEP关键字确保链接器不会因为 “看似未被调用” 而删除这个段 —— 如果删除，复位后内核找不到Reset_Handler地址，程序会崩溃。 \u0026gt;FLASH：明确将该段分配到MEMORY块定义的FLASH区域（符合硬件要求，向量表默认在 FLASH 起始地址）。 （2）.text：代码段（放 FLASH） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .text : { . = ALIGN(4); *(.text) // 所有.c/.s文件的代码（如main函数、自定义函数） *(.text*) // 扩展代码段（如C++的成员函数） *(.glue_7) // ARM指令与Thumb指令的胶水代码（Cortex-M用Thumb指令，兼容用） *(.glue_7t) // 同上 *(.eh_frame) // C++异常处理相关（若用C可忽略） KEEP (*(.init)) // 程序初始化函数（如构造函数） KEEP (*(.fini)) // 程序结束函数（如析构函数） . = ALIGN(4); _etext = .; // 定义符号：.text段的结束地址（供后续段定位） } \u0026gt;FLASH 作用：存放所有可执行代码（C 函数、汇编函数），是 FLASH 中占用空间最大的段。 _etext = .：.代表当前地址，_etext是全局符号，标记.text段的结束地址 —— 后续的.rodata段会从_etext之后的地址开始分配，避免段重叠。 （3）.rodata：只读常量段（放 FLASH） 1 2 3 4 5 6 7 .rodata : { . = ALIGN(4); *(.rodata) // 只读常量（如const int a = 10;、字符串常量\u0026#34;hello\u0026#34;） *(.rodata*) // 扩展只读常量段 . = ALIGN(4); } \u0026gt;FLASH 作用：存放只读数据，因为这些数据不需要修改，放在 FLASH 中可节省 RAM 空间。 示例：const char str[] = \u0026quot;STM32\u0026quot;;会被编译到.rodata段，运行时直接从 FLASH 读取，不会复制到 RAM。 （4）.ARM.extab/.ARM：ARM 架构兼容段（放 FLASH） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .ARM.extab (READONLY) : { . = ALIGN(4); *(.ARM.extab* .gnu.linkonce.armextab.*) . = ALIGN(4); } \u0026gt;FLASH .ARM (READONLY) : { . = ALIGN(4); __exidx_start = .; *(.ARM.exidx*) // ARM异常索引表（C++异常处理用） __exidx_end = .; . = ALIGN(4); } \u0026gt;FLASH 作用：主要用于ARM 架构与 Thumb 架构的兼容，以及 C++ 的异常处理（若项目用纯 C，这些段几乎为空，但保留可避免链接错误）。 READONLY：标记为只读，与 FLASH 的权限匹配（GCC11 + 支持，低版本需删除）。 （5）.preinit_array/.init_array/.fini_array：初始化 / 结束函数数组（放 FLASH） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 .preinit_array (READONLY) : { . = ALIGN(4); PROVIDE_HIDDEN (__preinit_array_start = .); KEEP (*(.preinit_array*)) // 预初始化函数（如动态库预初始化） PROVIDE_HIDDEN (__preinit_array_end = .); . = ALIGN(4); } \u0026gt;FLASH .init_array (READONLY) : { . = ALIGN(4); PROVIDE_HIDDEN (__init_array_start = .); KEEP (*(SORT(.init_array.*))) // 初始化函数（如C++全局对象的构造函数） KEEP (*(.init_array*)) PROVIDE_HIDDEN (__init_array_end = .); . = ALIGN(4); } \u0026gt;FLASH .fini_array (READONLY) : { . = ALIGN(4); PROVIDE_HIDDEN (__fini_array_start = .); KEEP (*(SORT(.fini_array.*))) // 结束函数（如C++全局对象的析构函数） KEEP (*(.fini_array*)) PROVIDE_HIDDEN (__fini_array_end = .); . = ALIGN(4); } \u0026gt;FLASH 作用：存放程序启动 / 退出时自动执行的函数数组（主要用于 C++），例如： init_array：main函数执行前，会自动调用这里的函数（如全局对象A a;的构造函数）。 fini_array：main函数退出后，会自动调用这里的函数（如全局对象的析构函数）。 PROVIDE_HIDDEN：若用户代码未定义__init_array_start等符号，链接器自动提供（隐藏符号，避免冲突）；KEEP确保这些段不被优化删除。 （6）.data：初始化数据段（放 RAM，加载地址在 FLASH） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* used by the startup to initialize data */ _sidata = LOADADDR(.data); // 定义符号：.data在FLASH的加载地址（LMA） .data : { . = ALIGN(4); _sdata = .; // 定义符号：.data在RAM的运行地址（VMA） *(.data) // 初始化的全局/静态变量（如int a = 10;） *(.data*) // 扩展初始化数据段 *(.RamFunc) // 要放到RAM中执行的函数（如某些快速中断处理函数） *(.RamFunc*) // 同上 . = ALIGN(4); _edata = .; // 定义符号：.data在RAM的结束地址 } \u0026gt;RAM AT\u0026gt; FLASH // 运行地址（VMA）在RAM，加载地址（LMA）在FLASH 核心概念：VMA（虚拟 / 运行地址）和LMA（加载地址）： \u0026gt;RAM：.data段的运行地址（VMA） 在 RAM（因为变量需要读写）。 AT\u0026gt;FLASH：.data段的加载地址（LMA） 在 FLASH（编译时将变量初始值存到 FLASH，节省 RAM）。 与启动流程关联：启动文件的Reset_Handler会从_sidata（FLASH 的 LMA）复制数据到_sdata（RAM 的 VMA），直到_edata—— 这就是 “初始化.data 段” 的具体实现。 .RamFunc：某些对执行速度要求高的函数（如高频中断服务函数），可通过__attribute__((section(\u0026quot;.RamFunc\u0026quot;)))标记，链接时会放到 RAM 中执行（RAM 访问速度比 FLASH 快）。 （7）.bss：未初始化数据段（放 RAM） 1 2 3 4 5 6 7 8 9 10 11 12 .bss : { _sbss = .; // 定义符号：.bss在RAM的起始地址 __bss_start__ = _sbss; *(.bss) // 未初始化的全局/静态变量（如int b;） *(.bss*) // 扩展未初始化数据段 *(COMMON) // 未初始化的全局变量（如extern int c;） . = ALIGN(4); _ebss = .; // 定义符号：.bss在RAM的结束地址 __bss_end__ = _ebss; } \u0026gt;RAM 作用：存放未初始化的全局 / 静态变量，C 语言标准要求这些变量初始化为 0，因此不需要在 FLASH 中存储初始值（节省 FLASH 空间）。 与启动流程关联：启动文件的Reset_Handler会将_sbss到_ebss的 RAM 区域清零 —— 这就是 “清零.bss 段” 的具体实现。 COMMON：对应未声明但外部引用的全局变量（如extern int c;），链接时会分配到.bss 段。 （8）._user_heap_stack：堆和栈的占位段（放 RAM） 1 2 3 4 5 6 7 8 9 ._user_heap_stack : { . = ALIGN(8); // 8字节对齐（堆/栈通常要求更高对齐，避免内存访问错误） PROVIDE ( end = . ); // 定义符号：RAM已分配区域的结束地址 PROVIDE ( _end = . ); . = . + _Min_Heap_Size; // 堆区域：从当前地址分配_Min_Heap_Size大小 . = . + _Min_Stack_Size;// 栈区域：在堆之后分配_Min_Stack_Size大小 . = ALIGN(8); } \u0026gt;RAM 作用：为堆和栈预留空间，并检查 RAM 是否足够 —— 若堆 + 栈 + 已分配段（.data+.bss）的总大小超过 RAM 容量，链接器会报错。 end/_end：标记 RAM 中 “已分配段（.data+.bss）” 的结束地址，堆从end开始向上生长，栈从_estack（栈顶）开始向下生长。 堆 / 栈生长方向： 堆：从end向上（地址增大方向）生长，供malloc/free使用。 栈：从_estack向下（地址减小方向）生长，供函数调用、局部变量使用。 若堆和栈生长时重叠，会导致内存溢出（硬 fault），因此需合理设置_Min_Heap_Size和_Min_Stack_Size。 （9）/DISCARD/：丢弃无用段（减小可执行文件大小） 1 2 3 4 5 6 /DISCARD/ : { libc.a ( * ) // 丢弃标准C库的所有段 libm.a ( * ) // 丢弃标准数学库的所有段 libgcc.a ( * ) // 丢弃GCC编译器库的所有段 } 作用：嵌入式系统通常不需要标准库的完整功能（如printf的文件输出、malloc的复杂内存管理），丢弃这些段可大幅减小.elf/.hex文件的大小。 注意：若项目需要使用标准库功能（如printf、sqrt），需删除对应行，否则会出现 “未定义引用” 错误（需搭配newlib-nano等嵌入式精简库）。 四、总结：启动流程与.ld 文件的关联 硬件复位 → 内核读取FLASH起始地址（0x8000000）的.isr_vector段 → 找到Reset_Handler地址。 执行Reset_Handler → 利用.ld定义的_sdata/_sidata/_edata复制.data段 → 利用_sbss/_ebss清零.bss段。 调用main → 用户代码中的变量（.data/.bss）已在 RAM 中初始化，函数（.text）在 FLASH 中执行，堆 / 栈在 RAM 中预留空间。 可以说：.ld 文件是 STM32 启动流程的 “地图”，没有它，启动文件不知道如何初始化内存，链接器不知道如何分配代码和数据，程序无法正常运行。 寄存器 认识一个CPU最直接的是去认识它的寄存器组 （Register bank） arm系统寄存器组\n还有5个特殊寄存器\n浮点数寄存器\n通用寄存器 通用寄存器通用性强，常用于存储临时的数据 其中R0-R7是低组寄存器，R8-R12是高组寄存器，高组寄存器部分指令无法访问\nPC程序计数器\u0026amp;程序如何跑起来 arm架构中的R15寄存器，是程序计数器（program counter），该寄存器可读可写\n在arm cortex-M的CPU内，每一次PC自增4（即向下移动了4个字节），但是在使用thumb指令集时，thumb指令集的部分指令是2个字节，这与处理器的执行流水线pipeline的特性有关，实际取址的时候是一次去4字节，也就是对于2字节的指令是一次取两条\nCPU在不断执行程序，本质就是程序计数器的不断更新，PC指向的就是当前要执行的指令的地址\n堆栈指针\u0026amp;双堆栈指针机制 栈是高址向低址方向生长，堆是低址向高址方向生长\narm cortex-M架构中R13是堆栈指针寄存器 在物理上该寄存器是两个不同的寄存器MSP主堆栈指针和PSP进程堆栈指针，在程序运行时选用哪一个寄存器会有Control控制寄存器的值来决定\n默认启动时，处理器使用的是主堆栈指针，可以修改Control控制寄存器的第一位的值来修改处理器使用的堆栈指针\n双堆栈指针-MSP主堆栈指针，PSP进程堆栈指针 可以用来实现隔离系统内核和应用程序任务\nLR链接寄存器\u0026amp;函数调用的本质 函数调用的本质是程序执行流的动态转移与上下文管理，其核心在于通过 栈 来实现代码模块化执行和状态的保存与恢复\narm架构的CPU有专门设立一个寄存器R14(link register)，用于存放子函数的返回地址\n以arm的bl指令为例（用于函数调用） bl \u0026lt;label\u0026gt;是跳转到标签地址，同时将返回地址存入LR寄存器\n需要注意的是，arm cortex-M架构的处理器指令都是半字对齐（两字节对齐），所以其反汇编的地址都是偶数，存在lr寄存器的返回地址也都是偶数，但是lr寄存器的第0位必须设置为1来指示thumb指令集的状态，所以lr寄存器的值会是返回地址+1\n在多级函数调用时，lr寄存器的值会被压入栈中\n另外lr寄存器还能记录异常返回值。当处理器进入中断时，链接寄存器会更新为异常返回值，用来实现异常返回机制，用来记录区分一些工作模式现场，这些信息是恢复中断上下文需要的\n地址分配 存储器系统 cortex-M处理器是32位地址，因此会有 4GB的地址空间，所有的指令和数据通过这个地址访问\n硬件资源都是通过地址映射的方式访问 另外cortex-M架构没有设置MMU内存管理单元，所以没有MMU内存管理单元，一般也不会搭载Linux,Windows这种通用类型的系统\n地址映射图 系统架构图\ncortex-M3M4内核架构图\n三级流水线外的设备属于CPU的内核外设，例如NVIC,SysTick系统滴答定时器，MPU等，用0xE004 0000-0xE00F F000地址访问\n软件上就是通过读写外设地址空间来控制这些外设，对应的地址空间单元映射到外设寄存器\n嵌入式编程本质就是在操作存储器，每一段CPU代码指令都是在读取某个地址空间的单元，高级编程语言就是不断向上封装抽象\nC语言每条语句追溯到汇编都是在读写存储器的地址空间单元 关于内存和编译优化 指针是内存地址的容器 关于i++与++i执行效率的问题，在O0优化的情况下，不同编译器的具体实现是不一样的，执行效率是不能直接比较的\n编译优化会使汇编的指令在执行速度上提高，例如会使用mov去代替ldr，或者将一些简单的函数改为内嵌，以减少函数调用带来的开销\n中断 在微机原理中已有涉及，后面只做简单回顾用\n关于中断 中断的事件一般由硬件触发（实际有硬中断和软中断），会改变程序执行流\nNVIC属于内核外设，专门管理中断\n在cortex-M芯片中，前15项中断向量都一样\n处理器具有向量表重定位功能，通过向量表偏移寄存器(VTOR)来获取向量表的起始地址\n中断触发时，处理器通过中断向量表去获取中断处理函数的入口地址\n中断返回\u0026amp;中断上下文 在阅读中断的汇编时，会发现中断没有保存和恢复上下文的代码，实际上是硬件帮忙实现上述功能\n关于上下文，如程序上的函数调用需要保存上下文，在操作系统中需要处理线程上下文（任务上下文），其本质都在于保存和恢复若干寄存器的值\ncortex-M3M4中断需要入栈保存上下文的8个寄存器 选择保存上述8个寄存器主要是根据arm架构的过程调用标准，C语言的函数实现会改动这些寄存器，为例能让C函数能作为异常（中断）处理函数，中断（异常）机制需要能自动地保存这些寄存器，这些寄存器也被称之为调用者保存寄存器\n处理器恢复上下文，回到原执行流，需要lr寄存器存储异常返回值来记录区分一些工作模式现场，这些信息是恢复中断上下文需要的\n错误处理 介绍arm cortex-M处理器架构如何捕获和记录错误故障\n有专门的寄存器去记录故障，通过查找其对应的地址查看寄存器的位来获取错误信息\n在发生错误时，对应错误寄存器的对应位被置1，同时触发错误中断处理\n程序执行非法指令操作导致系统进入不可恢复的故障状态，系统软件就会介入终止程序执行流，其实现机制是中断\n待续 ","date":"2025-09-04T00:36:07+08:00","permalink":"https://NomadJoeviolet.github.io/p/%E4%BB%8Ecpu%E6%9E%B6%E6%9E%84%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/","title":"从CPU架构到操作系统实现"},{"content":"类的成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样 类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员 注意：成员可以访问任意的成员（无论时public还是protected，private）\n在内部声明并定义 1 2 3 4 5 6 7 8 9 10 class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 double getVolume(void) { return length * breadth * height; } }; 在内部声明，外部定义 在类的外部使用范围解析运算符 :: 定义该函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class complex { public: complex();//默认构造函数 complex(double,double);//初始化构造函数 complex(double);//强制转换构造函数 complex operator + (complex);//运算符重载 complex operator - (complex);//运算符重载 friend istream\u0026amp; operator \u0026gt;\u0026gt; (istream\u0026amp; , complex\u0026amp;);//istream类\u0026gt;\u0026gt;运算符重载 friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; , complex\u0026amp;);//ostream类\u0026lt;\u0026lt;运算符重载 private: double real , imag ; }; //成员函数的类外实现 complex::complex() { real = 0 ;imag = 0 ; } complex::complex(double r , double i ) { real = r ; imag = i ; } complex::complex(double r ) { real = r ; imag = 0 ; } complex complex::operator + (const complex c1) { complex c2 ; c2.real = real+c1.real ; c2.imag = imag+c1.imag ; return c2 ; } complex complex::operator - (const complex c1) { complex c2 ; c2.real = real-c1.real ; c2.imag = imag-c1.imag ; return c2 ; } //友元函数的实现 //实现iostream类的运算符重载 istream\u0026amp; operator \u0026gt;\u0026gt; (istream\u0026amp; input , complex\u0026amp;c ) { input \u0026gt;\u0026gt; c.real \u0026gt;\u0026gt; c.imag ; return input ; } ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; output , complex\u0026amp;c ) { output \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#39;+\u0026#39; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; \u0026#39;i\u0026#39; \u0026lt;\u0026lt; endl ; return output ; } 类的友元函数 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员，尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数\n友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元\n友元函数的定义与声明 如果要声明函数为一个类的友元，需要在类定义中将该函数原型声明，且使用关键字 friend\n例子 1 2 3 4 5 6 7 8 9 10 11 12 13 class Date { public: Date(int ,int ,int );//构造函数 friend void Time::display( Date\u0026amp; );//声明Time类中的display函数是Date类的友元成员函数 private: int month , day , year ; }; //类外的定义实现 void Time::display(Date \u0026amp;D) { cout \u0026lt;\u0026lt; D.month \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; D.day \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; D.year \u0026lt;\u0026lt; endl ;//引用Date类对象的私有数据 cout \u0026lt;\u0026lt; hour \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; minute \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; second \u0026lt;\u0026lt; endl ; } ","date":"2025-09-04T00:32:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/","title":"C++ 成员函数与友元函数"},{"content":"在 C\u0026amp;C++ 中，深拷贝（Deep Copy） 和 浅拷贝（Shallow Copy） 是对象复制的两种根本不同的方式，主要区别在于如何处理指针成员指向的资源。理解它们的区别对内存管理和程序稳定性至关重要。\n关于C的深拷贝与浅拷贝 c语言中的深拷贝和浅拷贝 - 知乎\n推荐博文 c语言中的深拷贝和浅拷贝 - 知乎\nC语言 - 深拷贝与浅拷贝详解_c语言 deepcopy-CSDN博客\n【C++ 深拷贝与浅拷贝详解】_c++浅拷贝和深拷贝-CSDN博客\n【C++ Primer】 浅拷贝和深拷贝的实现 - 知乎\n1. 浅拷贝（Shallow Copy） 原理：仅复制对象的成员值（包括指针的值），不复制指针指向的实际资源。\n结果：原对象和拷贝对象的指针成员指向同一块内存地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Shallow { public: int* data; Shallow(int d) { data = new int(d); // 分配堆内存 } // 编译器生成的默认拷贝构造函数（浅拷贝） Shallow(const Shallow\u0026amp; other) : data(other.data) {} ~Shallow() { delete data; } }; // 使用示例 Shallow obj1(10); Shallow obj2 = obj1; // 浅拷贝：obj2.data 指向 obj1.data 的内存 *obj1.data = 20; // 修改 obj1 cout \u0026lt;\u0026lt; *obj2.data; // 输出 20（obj2 也被修改） // main结束时：obj2 和 obj1 会先后调用析构函数 // 导致同一内存被 delete 两次 → 程序崩溃！ 浅拷贝的核心问题： 悬空指针：一个对象释放资源后，另一个对象的指针失效 重复释放：多个对象尝试释放同一块内存 → 崩溃 数据篡改：通过一个对象修改数据会影响其他对象 2. 深拷贝（Deep Copy） 原理：不仅复制对象成员，还复制指针指向的资源。\n结果：原对象和拷贝对象拥有完全独立的资源副本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Deep { public: int* data; Deep(int d) { data = new int(d); } // 自定义拷贝构造函数（深拷贝） Deep(const Deep\u0026amp; other) { data = new int(*other.data); // 关键：分配新内存并复制值 } // 深拷贝赋值运算符 Deep\u0026amp; operator=(const Deep\u0026amp; other) { if (this != \u0026amp;other) { // 防止自赋值 delete data; // 释放原有资源 data = new int(*other.data); // 创建新副本 } return *this; } ~Deep() { delete data; } }; // 使用示例 Deep obj1(10); Deep obj2 = obj1; // 深拷贝：obj2 拥有独立的内存副本 *obj1.data = 20; // 修改 obj1 cout \u0026lt;\u0026lt; *obj2.data; // 输出 10（obj2 不受影响） // 析构时各自释放独立内存 → 安全 深拷贝的核心优势： 资源独立：每个对象拥有自己的资源副本 安全析构：不会发生重复释放 数据隔离：修改一个对象不影响其他对象 3. 关键对比表 特性 浅拷贝 深拷贝 复制内容 指针值（内存地址） 指针指向的实际数据 资源副本 共享同一份资源 创建独立资源副本 内存开销 小 大（需额外分配内存） 安全性 危险（悬空指针/重复释放） 安全 默认行为 编译器默认生成 需要手动实现 修改影响 影响所有副本 只影响当前对象 适用场景 无资源管理的简单对象 含指针/动态资源的对象 4. 何时需要深拷贝？ 当类满足以下任一条件时必须实现深拷贝：\n包含原始指针成员指向动态分配的内存 管理独占资源（文件句柄、网络连接等） 需要独立副本逻辑（如字符串、容器类） Rule of Three 原则：如果类需要自定义析构函数，则通常也需要自定义拷贝构造函数和拷贝赋值运算符（即深拷贝）。\n5. 现代C++的优化方案 (1) 禁用拷贝 1 2 3 4 5 6 class NonCopyable { public: NonCopyable() = default; NonCopyable(const NonCopyable\u0026amp;) = delete; // 禁用拷贝 NonCopyable\u0026amp; operator=(const NonCopyable\u0026amp;) = delete; }; (2) 使用智能指针（推荐） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;memory\u0026gt; class SafeObject { std::unique_ptr\u0026lt;int\u0026gt; data; // 独占所有权 public: SafeObject(int d) : data(std::make_unique\u0026lt;int\u0026gt;(d)) {} // 不需要自定义拷贝构造/赋值 // unique_ptr 禁止拷贝，但支持移动 }; // shared_ptr 版本（共享所有权，引用计数） class SharedResource { std::shared_ptr\u0026lt;MyResource\u0026gt; res; }; (3) 移动语义（C++11+） 1 2 3 4 5 6 7 8 9 class Movable { int* data; public: // 移动构造函数（转移资源所有权） Movable(Movable\u0026amp;\u0026amp; other) noexcept : data(other.data) { other.data = nullptr; // 置空原对象 } }; 6. 深拷贝的典型应用场景 字符串类：std::string 内部实现深拷贝 容器类：std::vector 复制时深拷贝所有元素 自定义资源管理：数据库连接池、图像缓冲区等 多线程安全：避免共享资源需要深拷贝 总结 概念 本质 解决方案 浅拷贝 复制指针（共享资源） 编译器默认行为 深拷贝 复制资源内容（独立副本） 自定义拷贝构造/赋值运算符 现代实践 避免手动深拷贝 使用智能指针+移动语义 最佳实践：\n优先使用 std::vector, std::string 等已安全实现的容器 用 std::unique_ptr/std::shared_ptr 替代原始指针 遵循 Rule of Zero：通过组合安全类型避免自定义拷贝/析构 对于必须深拷贝的大型对象，考虑添加移动语义优化性能 ","date":"2025-08-20T22:43:07+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","title":"C\u0026C++ 深拷贝与浅拷贝"},{"content":"（stm32之HAL库）UART工作在DMA模式要打开串口中断吗？_hal uart dma-CSDN博客\n10 通用同步异步收发器（USART） - 知乎\n串口简介 串口是串行接口的简称 常用串口：RS232,RS485,USB(Universal Serial Bus)通用串行接口,TTL串口 TTL是Transistor-Transistor Logic的简写，是一种电平逻辑，晶体管-晶体管逻辑\nUSART简介 USART，即通用同步/异步收发传输器（Universal Asynchronous Receiver/Transmitter)，是单片机上的一个外设\nUART遵循异步串行通信协议的，USRT遵循同步串行通信协议 异步不需要统一时钟信号，同步需要统一时钟信号\n一般使用最多的是UART，我们此次学习也是针对UART\nUART通信协议 起始位：发出1位低电平信号，表示开始传输字符 数据位：真正发送的数据，一般为8位（1个字节），常采用ASCII编码，从最低位开始发送 校验位：用于检验接收到的数据是否正确，分为奇校验和偶校验 停止位：一组数据的结束传输的标志。可以是1位、1.5位、2位的高电平 空闲位：空闲时数据线为高电平状态，代表无数据传输 波特率：衡量传输速率的指标。UART通信中波特率等于比特率 UART发送/接收机制 UART发送端口，首先是CPU将数据放入数据发送寄存器，然后发送移位寄存器会将数据从数据发送寄存器 取出进行移位并通过UART_TX发送出去\nUART接收端口，首先是UART_RX接收串行数据至接收移位寄存器，接收移位寄存器将串行数据移位变换为并行数据给数据接收寄存器，再通过APB总线给STM32内部\nUART模式 轮询模式 CPU不断查询发送数据寄存器或者接受数据寄存器导致程序的阻塞\n发送 在UART底层有发送移位寄存器和发送数据寄存器，发送数据时，需要CPU将发送数据寄存器的数据移动至发送移位寄存器，然后UART按照指定的波特率发送数据，CPU则不断查询数据发送寄存器是否空，如果空则需要移动数据进来\n接收 在UART底层有接收移位寄存器和接收数据寄存器，接收数据时，UART按照指定的波特率接收数据至接收移位寄存器，然后数据会存储在接收数据寄存器，CPU则不断查询数据接收寄存器是否有数据，如果有数据，CPU会把寄存器的数据移动至我们用来接收数据的变量的内存里\n当HAL_UART_Receive执行完成，我们就可以知道数据接收完成\n中断模式 使用中断模式时，需要先配置UART的NVIC中断设置\n底层中断实现数据每传送一字节，召回CPU继续运输数据，不需要我们考虑，HAL库底层已经帮我们实现 上层中断实现数据接收完成后的数据处理，通过中断回调函数实现，需要我们自己设计\n发送 CPU将数据送入 发送数据寄存器，然后就去执行其他代码，当发送移位寄存器的数据发送后，发送数据寄存器空，会触发发送数据寄存器空中断，CPU再次将数据送入 发送数据寄存器，然后又去执行其他代码，所有数据发送完成后会触发 传送完成中断，调用HAL_UART_TxCpltCallback中断回调函数\n接收 CPU在处理其他代码，接收移位寄存器将一帧数据移动至 接受数据寄存器后，会触发 接收数据寄存器非空中断，CPU会回来将 接收数据寄存器 的数据移动至我们用来接收数据的变量的内存里，然后又去执行其他代码，所有数据完成后会调用_HAL_UART_RxCpltCallback_中断回调函数处理接收的数据\n而执行HAL_UART_Receive_IT后，我们不能直接对数据继续处理，数据还没接收完成，因为CPU不会进入阻塞态，会去执行其他代码，需要通过HAL_UART_RxCpltCallback回调函数处理接收的数据\nDMA模式 DMA，全称为Direct Memory Access，直接内存访问，本质是将传输数据从一个内存空间搬运至另一个内存空间，可以用来提供外设和内存，内存和外设之间的高速数据传输\nDMA模式中也会有中断参与，在Cube配置中需要开启中断\n发送 在普通的轮询USART中，CPU一直在等待外设发送数据，外设每发送一帧数据，CPU就从内存中移动一帧数据到外设的寄存器\n在中断的USART中，外设每从寄存器中发送一帧数据，就会触发一次发送数据寄存器空中断，使CPU回来将数据从内存搬运至外设的寄存器中\n没有DMA的话，CPU会作为数据发送的中转站，而使用DMA的话，整个数据传输过程不需要CPU的参与，由DMA代理执行，DMA负责将内存数据搬运至外设的传输寄存器\n接收 在普通的轮询USART中，CPU一直在询问外设是否接收完数据，外设接收一帧数据，该位数据由CPU从外设的数据接收寄存器运进内存，CPU再次询问外设是否接收完数据，再运，直至整个数据接收完成\n而在中断USART中，外设每接收一帧数据，触发一次数据接收寄存器非空中断，CPU过来将数据从寄存器搬运至内存，所有数据接收完成后，会调用接收完成中断回调函数（HAL_UART_RxCpltCallback）\n没有DMA的话，CPU会作为数据转运的中转站，而使用DMA的话，整个数据转运过程不需要CPU的参与，由DMA代理执行\nCube配置解析 基础参数配置 Baud Rate：波特率 Word Length：包含校验位在内的数据包长度 Parity：奇偶校验位 Stop Bits：停止位位数 Data Direction：发送和 NVIC配置 如果使用中断模式，需要在NVIC settings开启USARTi global interrupt DMA配置 Add：选择添加USARTi_RX的DMA或者USARTi_TX的DMA Delete：删除对应的DMA Mode：选择normal模式或者circular模式 Data Byte：数据传输的位数 Increment Address：开启地址自增，外设只有一个寄存器，地址固定，不需要开启地址自增，而内存中我们存数据的变量是数组，接受一字节数据后需要往后移，需要开启地址自增 Priority：优先级设置 Direction：方向，固定死的 GPIO配置 一般用来查看引脚的GPIO配置，不需要更改（有特殊需求时，可以按需修改） 在GPIO Settings处可以查看TX和RX的GPIO引脚配置，此处可以看到RX为输入模式，无上拉无下拉\nHAL库UART常用函数 轮询模式 1 2 HAL_UART_Receive(\u0026amp;huart1, rxBuffer, 16 , HAL_MAX_DELAY);//接收 HAL_UART_Transmit(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) , 100 );//发送 中断模式 只能接收一次，接收完成后需要再次开启\n1 2 3 4 5 6 7 HAL_UART_Receive_IT(\u0026amp;huart1, rxBuffer, 16 );//接收 HAL_UART_Transmit_IT(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) );//发送 //回调函数 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { } DMA模式 （stm32之HAL库）UART工作在DMA模式要打开串口中断吗？_hal uart dma-CSDN博客\n1 2 3 4 5 6 7 HAL_UART_Receive_DMA(\u0026amp;huart1, rxBuffer, 16 );//接收 HAL_UART_Transmit_DMA(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) );//发送 //回调函数 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { } HAL库中使用的HAL_UART_Transmit_DMA，HAL_UART_Receive_DMA等都有中断的参与，需要在Cube中开启中断\nDemo 接收定长数据Nomad_violet，同时在主函数中翻转小灯\n轮询实现数据收发 Cube配置 模式选择为异步\n波特率选择115200 Bit/s，其余不动即可\n将PA8配置为GPIO_Output\nGPIO配置保持默认即可\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;string.h\u0026#34; #define rxBufferLen 16 #define txBufferLen 25 uint8_t rxBuffer[rxBufferLen] ; uint8_t txBuffer[txBufferLen] = \u0026#34;to feel,to experience \u0026#34;;// 去感受，去经历「感其生，历其境」 int main(void) { HAL_Init(); SystemClock_Config(); MX_GPIO_Init(); MX_USART1_UART_Init(); while (1) { HAL_UART_Receive(\u0026amp;huart1, rxBuffer, 12 , HAL_MAX_DELAY);//只能接收定长数据 if( !strcmp( (char *)rxBuffer , \u0026#34;Nomad_violet\u0026#34; ) ) {//Nomad_violet 12字节 HAL_UART_Transmit(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) , 100 ); } HAL_GPIO_TogglePin(GPIOA , GPIO_PIN_8 ); } } 中断实现数据收发 Cube配置 配置同上，只需额外开启中断即可\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;string.h\u0026#34; #define rxBufferLen 12 #define txBufferLen 25 uint8_t rxBuffer[rxBufferLen] ; uint8_t txBuffer[txBufferLen] = \u0026#34;to feel,to experience \u0026#34;;// 去感受，去经历「感其生，历其境」 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart == \u0026amp;huart1) { if( !strcmp( (char *)rxBuffer , \u0026#34;Nomad_violet\u0026#34; ) ) { HAL_UART_Transmit(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) , 100 ); } HAL_UART_Receive_IT(\u0026amp;huart1, rxBuffer, rxBufferLen ); } } int main(void) { HAL_Init(); SystemClock_Config(); MX_GPIO_Init(); MX_USART1_UART_Init(); HAL_UART_Receive_IT(\u0026amp;huart1, rxBuffer, rxBufferLen ); while (1) { HAL_GPIO_TogglePin(GPIOA , GPIO_PIN_8 ); HAL_Delay(500); } } ","date":"2025-06-27T14:53:35+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32uart%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/","title":"STM32————UART串口通信"},{"content":"【STM32】HAL库 STM32CubeMX教程七\u0026mdash;PWM输出(呼吸灯)_stm32 hal pwm-CSDN博客\nSTM32CubeIde中互补PWM配置项的详细解读_ch idle state-CSDN博客 基于上述博客以及keyskingSTM32教程写的个人学习文档 【【STM32入门教程】应该是全B站最好的STM32教程了！！】https://www.bilibili.com/video/BV12v4y1y7uV?vd_source=5a0790755035f26a67935abfbfcdfd5b\n定时器简介 HAL库开启定时器的基本函数 开启定时器\n1 2 HAL_TIM_Base_Start(\u0026amp;htim1);//仅开启定时器 HAL_TIM_Base_Start_IT(\u0026amp;htim1);//开启定时器和中断 1 2 HAL_TIM_Base_Stop(\u0026amp;htim1);//关闭定时器 HAL_TIM_Base_Stop_IT(\u0026amp;htim1);//既关闭定时器，同时关闭中断 框架 解释整个TIM外设的构成 计数信号来源 有内部时钟以及外部时钟 内部时钟模式 在f103c8t6中，TIM1是高级定时器，TIM2，TIM3，TIM4是通用计时器\nCubeMX参数配置 Prescaler:预分频，实际分频数是number+1 Counter Mode:计数模式设置 Counter Period:自动重装载计数器计数值 Internal Clock Division:内部时钟预分频 Repetiton Counter:重复计数器 (RCR -8 bits)，属于高级控制寄存器专用寄存器位，利用它可以非常容易控制输出 PWM 的个数，与内部时钟模式无关 auto-reload preload:是否开启影子寄存器模式 还需要开启定时器更新中断\n代码实现 用的PA2作GPIO输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {//中断回调函数 if( htim == \u0026amp;htim1 ) { HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_2); } } int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM1_Init(); /* USER CODE BEGIN 2 */ HAL_TIM_Base_Start_IT(\u0026amp;htim1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 外部时钟模式 【【STM32】动画讲解定时器外部时钟 \u0026amp; 实战传送带测速装置】https://www.bilibili.com/video/BV1N94y1u7Uz?vd_source=5a0790755035f26a67935abfbfcdfd5b\n__HAL_GET_COUNTER(\u0026amp;htim)获取计数值\n外部时钟模式2 在Clock Source处选择\n注意外部时钟的滤波器Clock Filter，输入滤波 输入滤波，极性选择，预分频器\n采样频率等于内部时钟的频率\n一般推荐选择1110（15）\n外部时钟模式1 通过定时器的Slave Mode 进行选择 启用从模式，选择外部时钟模式1 选择Trigger Source时，就是选择什么方式来外部计数 就是选择触发器的来源 TI_ED是双边沿触发，且只能是双边沿触发\n使用外部计数ETR 可以在外部时钟模式1下，Trigger Source选择ETR1 芯片上会有引脚被设置为ETR1\n直接选择外部时钟模式2，引脚上会自动有一个ETR2 关于定时器的事件更新中断 关于定时器中断 计数值到达自动重装载值时，触发更新中断 在Cube中开启global interrupt 关于MX_TIM2_Init()启动时会将中断标志位置1 在MX_TIM2_Init()时，会将定时器更新中断标志位置1，在调用HAL_TIM_Base_Start_IT后，NVIC会检测到更新中断标志位被置1，会立马触发中断\n在HAL_TIM_Base_Start_IT前选择下面两个函数其中一个写上即可 事件更新中断的逻辑 先是NVIC中断向量表查找到TIM2_IRQhandler，在该函数中，调用了HAL_TIM_IRQhandler函数 其中的事件更新处理的代码(HAL库中HAL_TIM_IRQHandler中的处理事件更新中断的代码) 判断标志位，判断是否开启事件更新中断，清零标志位，调用HAL_TIM_PeriodElapsedCallback函数\n定时器的从模式 【【STM32】一看就懂的定时器从模式讲解】https://www.bilibili.com/video/BV1mU421o7vt?vd_source=5a0790755035f26a67935abfbfcdfd5b\n定时器从模式\nReset Mode 复位模式 Gate Mode 门模式 Trigger Mode 触发模式 复位模式 设定为复位模式时\n选取计数信号，计数信号可以时内部时钟，也可以是外部时钟模式2（不是从模式控制器下外部时钟模式1） 触发器的信号，每出现一次，执行一次复位操作（向上计数模式恢复为0，向下计数模式恢复为自动重装载值） 例子：选取计数信号为内部时钟，计数器不断计数，当触发器信号来临时（TI1的TIFP1检测到信号上升沿），则触发一次更新事件，计数器值复位 注意：如果开启定时器的事件更新中断，触发器信号也会触发事件更新中断\n复位模式下的从模式控制器，在接收到触发信号后，就会让计数器重新开始计数，并且会触发定时器更新中断\n如何判断事件更新中断的产生原因 在复位模式中，需要区分事件更新中断是触发信号的复位导致还是自动挡重装载时导致\n从模式收到触发信号后，会设置触发器中断标志位，可以借此来区分中断原因\n使用该函数来获取触发器中断标志位 1 __HAL_TIM_GET_FALG(htim,TIM_FLAG_UPDATE)//可以获取定时器对应标志位的值 TIM_FLAG_TRIGGER是触发器中断标志位\n1 __HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER) 使用上述语句可以获取其标志位 使用时需要注意，HAL库为了方便我们判断，并不会对该标志位清零，所以在获取标志位的值后，需要对其进行清零\n1 2 3 if(__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)==SET) { __HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER); } HAL_TIM_PeriodElapsedCallback回调函数\n1 2 3 4 5 6 7 8 9 10 11 void HAL_TIM_PeriodElapsedCallback( TIM_HandleTypeDef *htim ) { if( htim == \u0026amp;htim2 ) { if( __HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER) == SET ) {//获取触发标志位，用来区分复位引起的中断还是自动重装载引起的中断 __HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER); HAL_UART_Transmit( \u0026amp;huart2 , (uint8_t*)triggerMsg , strlen(triggerMsg) , 100 ); } else { HAL_UART_Transmit( \u0026amp;huart2 , (uint8_t*)updateMsg , strlen(updateMsg) , 100 ); } } } 关于MX_TIM2_Init()启动时会将中断标志位置1 在MX_TIM2_Init()时，会将定时器更新中断标志位置1，在调用HAL_TIM_Base_Start_IT后，NVIC会检测到更新中断标志位被置1，会立马触发中断\n在HAL_TIM_Base_Start_IT前选择下面两个函数其中一个写上即可 事件更新中断的逻辑 先是NVIC中断向量表查找到TIM2_IRQhandler，在该函数中，调用了HAL_TIM2_IRQhandler函数 其中的事件更新处理处的代码(HAL库中HAL_TIM_IRQHandler中的处理事件更新中断的代码) 判断标志位，判断是否开启事件更新中断，清零标志位，调用HAL_TIM_PeriodElapsedCallback函数\n门模式 如果TI1的TI1FP1为上升沿检测，则是当触发信号是高电平时，时钟信号可以正常进入定时器，定时器能正常计数 当触发信号时低电平时，门关闭，时钟信号不能正常进入定时器，定时器停止计数 若将触发器的极性改为检测下降沿的话，门的控制作用则相反 触发器的极性选择 需要注意，在门模式情况下，上升下降沿的时刻，也会将触发器中断标志位置1，但是不会触发事件更新中断（因为没有对计数值进行复位，就不会触发事件更新中断） 触发模式 在检测到设定的边沿后，让定时器开始计数 开始后不能设定停止 触发模式仅能启动定时器，并不能停止计数器计数\n一般配合计时器的单脉冲模式使用 单脉冲模式，是指计数器计数到重装载计数值后，就停止计数（不再循环计数） 一般需要勾选单脉冲模式\n三种模式的总结 Trigger Source 触发源的滤波器设置 在有触发源的时候，对触发源的信号的滤波设置 定时器的输入捕获 软件层面上的模拟 在软件层面检测Echo端的电平高低，进行计时，到那时再极高精度要求的情况则 力不足\n输入捕获的概括 硬件在检测到上升或者下降沿时，就记录计数器值到捕获寄存器\n输入捕获的运行机制 在TI1检测到上升沿时，捕获寄存器立即复制计数器的值 还可以开启输入捕获中断，输入捕获后，启动中断，可以快速处理捕获寄存器上的值\n一个通道只能进行一种边沿检测 捕获的模式 注意：TI3和TI4没有接入从模式控制器中 TI1和TI2是一对，可以相互借用 TI3和TI4是一对，可以相互借用 Cube上的配置 注意设置边沿检测 打开捕获中断 启动，该例子中是需要在CHANNEL4捕获到后进行处理，所以CHANNEL44开启了中断 输入捕获的开启 可能遇到的问题 ![[Pasted image 20250105120132.png]] 用SET_COUNTER来清零一下\n中断回调函数\n1 HAL_TIM_IC_CaptureCallback(htim); 回调函数的代码编写 判断是否是TIM1，判断是否是TIM1的4通道（HAL_TIM_ACTIVE_CHANNEL_4） 再读取指定寄存器的值\n定时器的输出比较模式 较为鸡肋，对这些模式能理解其行为即可\n定时器的PWM 【STM32】HAL库 STM32CubeMX教程七\u0026mdash;PWM输出(呼吸灯)_stm32 hal pwm-CSDN博客\nSTM32CubeIde中互补PWM配置项的详细解读_ch idle state-CSDN博客\nPWM 脉冲宽度调制，用数字信号去模拟 模拟信号 PWM模式 PWM模式1 是 计数器值 小于 比较器值 时输出有效电平 PWM模式2 是 计数器值 大于 比较器值 时输出有效电平 Cube配置 为实现一个呼吸灯，进行以下配置 PWM的频率为1000Hz，最大计数值为1000-1\n基础时钟配置\n预分频器值，计数模式选择（向上计数模式，向下计数模式，中央对齐模式），自动重装载值，内部时钟分频，重复计数器值，是否开启影子寄存器\nPWM配置\nMode：选择PWM模式 Pulse：设置比较寄存器的值 Output compare preload：是否开启影子寄存器 Fast Mode：是否需要输出非常高频的PWM信号 CH Polarity：设置有效电平极性 CH Idle State：空闲时，PWM通道的输出 HAL库PWM常用函数 1 2 3 HAL_TIM_PWM_Start(\u0026amp;htim1,TIM_CHANNEL_1);//开启PWM HAL_TIM_PWM_Stop(\u0026amp;htim1,TIM_CHANNEL_1);//关闭PWM __HAL_TIM_SET_COMPARE(\u0026amp;htim1,TIM_CHANNEL_1,num);//设置比较寄存器的值 使用PWM控制流水灯 PWM的频率为1000Hz，最大计数值为1000-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM1_Init(); /* USER CODE BEGIN 2 */ HAL_TIM_PWM_Start(\u0026amp;htim1,TIM_CHANNEL_1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { for( int i = 0 ; i \u0026lt; 1000 ; ++ i ) { __HAL_TIM_SET_COMPARE(\u0026amp;htim1,TIM_CHANNEL_1,i); HAL_Delay(0); } for( int i = 1000-1 ; i \u0026gt;= 0 ; -- i ) { __HAL_TIM_SET_COMPARE(\u0026amp;htim1,TIM_CHANNEL_1,i); HAL_Delay(0); } /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 编码器的使用 待完成\n","date":"2025-06-26T17:26:06+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32tim%E5%AE%9A%E6%97%B6%E5%99%A8/","title":"STM32————TIM定时器"},{"content":"一文轻松理解内存对齐 - 知乎\n结构体（struct）对齐 规则 1：成员地址 = min(自身对齐值, 有效对齐值) 的倍数\n规则 2：结构体总大小 = 最大成员对齐值的整数倍\n规则 3：成员排列顺序影响最终大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #pragma pack(1)//设置默认对齐数为1 struct S1 { char c1; int i; char c2; }; #pragma pack()//取消设置的默认对齐数，还原为默认 int main() { //输出的结果是什么？ printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct S1)); return 0; } 1 2 3 4 5 6 7 #pragma pack(push, 1)//设置默认对齐数为1 struct MyStruct { char a; int b; double c; }; #pragma pack(pop)//取消设置的默认对齐数，还原为默认 1 2 3 4 5 struct MyStruct { char a; int b; double c; } __attribute__((packed)); ","date":"2025-06-26T15:35:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%9E%81%E7%AE%80%E7%89%88/","title":"C\u0026C++ 内存对齐（极简版）"},{"content":"MDK介绍及其使用 一文教你使用MDK开发工具-CSDN博客\nMDK、KEIL、uVision 之间的区别\nMDK（ Microcontroller Development Kit ），也称 MDK-ARM 、KEIL MDK、KEIL For ARM，都是同一个东西。ARM 公司现在统一使用 MDK-ARM 的称呼，MDK 的设备数据库中有很多厂商的芯片，是专为微控制器开发的一款工具，为满足基于 MCU 进行嵌入式软件开发的工程师需求而设计，支持 ARM7，ARM9，Cortex-M4/M3/M1，Cortex-R0/R3/R4 等 ARM 微控制器内核。KEIL 是公司的名称，有时候也指 KEIL 公司的所有软件开发工具。Keil 公司在2005年被 ARM 公司收购。\nuVision 是 KEIL 公司开发的一个集成开发环境（IDE）。它包括工程管理，源代码编辑，编译设置，下载调试和模拟仿真等功能，uVision 有 uVision2、uVision3、uVision4 和 uVision5 四个版本，目前最新的版本是 uVision5。它提供一个环境，让开发者易于操作。uVision 通用于 KEIL 的开发工具中，例如 MDK，PK51，PK166，DK251等。\narmclang 就是俗称的AC6 armclang是ARM公司提供的一款C/C++编译器，专门用于为ARM架构的处理器生成高性能代码。该编译器通常与ARM的其他工具链一起使用，适合嵌入式系统开发。\n请注意，确保在项目中使用合适的工具和版本，并根据需求查阅最新的文档。\nOpenOCD 跟我一起学OpenOCD(一) - 知乎 (zhihu.com)\nOpenOCD是一个开源的调试/编程工具，主要用于嵌入式系统，它支持多种硬件设备和调试协议，如JTAG和SWD。它通常与GNU工具链结合使用，可以为开发人员提供硬件调试和烧录固件的功能。\nOzone Ozone使用介绍-基础功能 - 开发环境 - 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)\nMinGW mingw 是一个为 Microsoft Windows 平台编译和运行 Unix 程序的工具套装，它提供了类似于 Unix 环境下的编译器、链接器等工具，以便在 Windows 平台上开发使用 GCC（GNU 编译器集合）和其他开源 Unix 工具的软件。\narm-none-eabi-gcc arm-none-eabi-gcc 是一个专为 ARM 架构的嵌入式系统设计的 GCC 编译器版本。它可以生成裸机代码，适用于没有操作系统的应用程序。开发者常用它来编译针对 ARM Cortex 和其他 ARM 设备的软件。\narm-none-eabi-gcc 和 armclang的区别 arm-none-eabi-gcc 和 armclang 是两种不同的编译工具链，主要用于嵌入式系统中基于 ARM 处理器的代码编译。它们之间存在一些关键的区别，以下是它们各自的特点及区别的简要概述：\n开发者和背景：\narm-none-eabi-gcc: 是 GNU 编译器集合（GCC）的一个变体，专门用于 ARM 处理器。这个工具链是开源的，由 GNU 项目支持。 armclang: 是 ARM 公司推出的编译器，属于 ARM Compiler 工具链的一部分。ARM Compiler 6及更高版本基于开源的 LLVM/Clang 技术，但包含许多 ARM 提供的专有优化和扩展。 编译技术和优化：\narm-none-eabi-gcc: 利用 GCC 的优化技术，提供了广泛的架构支持和成熟的优化方法。 armclang: 使用 LLVM 编译技术框架，通常提供更现代的优化策略和更好的代码生成质量，尤其是在 C++ 的高级特性支持方面。 语言支持：\n两者都支持主要的编程语言如 C 和 C++。但是，由于 ARM Compiler 包括来自 LLVM/Clang 的优势，armclang 可能在支持最新 C++ 标准方面有更好的表现。 调试和错误信息：\narmclang 通常提供更详细的错误和警告信息，这可以使调试过程更加高效。 arm-none-eabi-gcc 的错误信息较为传统，但由于广泛使用，网上有大量关于其调试的资源和社区支持。 生态系统和集成：\narm-none-eabi-gcc 由于是开源和免费，被广泛应用于多种开发环境和项目中。其生态系统非常成熟，有大量的第三方库和工具支持。 armclang 尽管集成了许多 ARM 特定的优化，但作为商业产品，可能在使用上不如 GCC 灵活，特别是在版权和许可证管理方面。 性能：\n性能比较并不绝对，依赖于具体的应用场景和代码特性。在某些情况下，armclang 生成的代码运行效率更高，而在其他情况下，arm-none-eabi-gcc 可能表现得更好。 在选择哪一个编译器进行项目开发时，需要考虑多个因素，如团队的熟悉度、项目需求对优化的依赖程度、成本（尤其是 armclang 可能涉及的许可成本）以及与其他工具的兼容性等。\nclangd clangd是llvm项目推出的C++语言服务器，通过LSP(Language Server Protocal)协议向编辑器如vscode/vim/emacs提供语法补全、错误检测、跳转、格式化等等功能。C++的LSP曾经是cquery, ccls, clangd三足鼎立。但是clangd支持clang-tidy实时检查的功能是另外两者不具备的，而且cquery和ccls都是单个开发者主导的项目，clangd背后则是有llvm的背书。目前来看，“姓赵”的clangd在这场c++ lsp赛跑中已经有了不小的领先优势。\nVScode的IntelliSense IntelliSense 是 VS Code 提供的智能代码补全和理解功能，它结合了代码补全、参数信息、快速信息和成员列表等功能，极大地提高了开发效率。\nIntelliSense 的核心组成\n代码补全 (Code Completion) 输入时自动显示建议列表 包含变量、函数、类、方法等 支持模糊匹配 (如输入 fs.rm 可匹配 fs.rmdir) 参数提示 (Parameter Hints) 显示函数参数信息 当前参数位置高亮显示 函数重载时可通过箭头切换 快速信息 (Quick Info) 悬停时显示符号定义 包含文档注释、类型信息等 错误检查 (Error Checking) 实时语法检查 类型错误检测 未定义符号提示 IntelliSense 的工作原理 VS Code 通过以下方式提供 IntelliSense：\n基于词法分析：简单的文本匹配补全 基于语言服务器协议 (LSP)：通过语言服务器获取深度分析 基于 TypeScript/JavaScript 的 TS Server：专为 JS/TS 优化 基于标签 (Tag Parser)：如 C/C++ 扩展使用的方案 交叉编译器 arm 交叉编译器各种gcc 傻傻分不清楚：gnueabi,gnueabhf,none-eaib - 知乎\n交叉编译工具链的命名规范 arch [-vendor] [-os] [-(gnu)eabi]\narch : 架构的意思，如ARM ，MIPS\nvendor： 工具链的提供厂商\nos： 支持的操作系统\neabi：嵌入式应用二进制接口（Embedded Application Binary Interface）\narm gcc还分为 是否支持操作系统 支持操作系统： arm-none-linux-eabi-gcc 不支持操作系统： arm-none-eabi-gcc none表示vendor是none，也就是不属于某一公司的\nABI 和 EABI ABI：二进制应用程序接口(Application Binary Interface (ABI) for the ARM Architecture)。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。\nEABI：嵌入式ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。\n两者主要区别是，ABI是计算机上的，EABI是嵌入式平台上（如ARM，MIPS等）\nninja，make，cmake cmake cmake是一个生成 .ninja 和 .makefile 的工具。cmake只需要用户通过对源码文件的简单描述（就是CMakeLists.txt文件），就能自动生成一个project的makefile文件或者ninja文件，然后就可以通过ninja或者make进行启动编译了，很多IDE都在用cmake作为项目管理工具。\nmake与ninja make功能强大，可以给人看，ninja启动速度快，项目构建速度快，但不是给人看的 可以认为两者同级。\n层级关系 开发者层：编写CMakeLists.txt定义构建规则 生成器层：CMake解析配置，生成底层构建文件 执行器层：Make/Ninja执行具体构建命令 工具链层：编译器(如gcc)、链接器等实际执行编译 ","date":"2025-06-26T15:21:07+08:00","permalink":"https://NomadJoeviolet.github.io/p/%E5%B7%A5%E5%85%B7%E9%93%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E7%9F%A5%E8%AF%86/","title":"工具链的一些杂知识"},{"content":"中断简介 中断定义 CPU执行程序中，由于发生了某种随机的事件(外部或内部)，引起CPU暂时 中断正在运行的程序，转去执行一段特殊的服务程序(称为中断服务程序或 中断处理程序)，以处理该事件，该事件处理完后又返回被中断的程序继续 执行，这一过程称为中断 对于单片机来说\n中断事件发生 产生中断信号 单片机接收到中断信号，停止执行当前函数，跳转至中断处理函数 执行完中断处理函数后，单片机自动跳转回主函数执行被中断处 NVIC NVIC是嵌套向量中断控制器，控制着整个芯片中断相关的功能，它跟内核紧密耦合，是内核里面的一个外设。同时掌控中断优先级和中断向量表。\n中断流程 请求挂起寄存器的改变由外设导致 中断信号传递至NVIC，然后NVIC查找对应中断向量，执行中断处理函数 另外中断处理函数都需要去清除请求挂起寄存器对应位，避免中断处理函数被重复调用 HAL库的中断处理及回调函数实现流程 首先是外设发出中断请求信号，NVIC接收到后会根据中断向量表查询对应中断处理函数的入口，在HAL中是对应外设的外设number_IRQHandler，然后再进入HAL库统一的外设中断处理函数HAL_外设_IRQHandler，再调用对应的回调函数 NVIC嵌套向量中断控制器 NVIC会一直检测某一个中断线是否处于激活状态，当中断处理函数运行完成后，需要在中断处理函数中将请求挂起寄存器对应的位清除为0，避免NVIC一直检测到1，一直重复执行中断处理函数，而这一部分代码，在HAL库写的总IRQHandler中已经完成。\n另外，NVIC对于中断还有中断优先级的设置，stm32f103c8t6中断优先级由NVIC的优先级寄存器里的4位决定。中断优先级分为抢占优先级和响应优先级（它们一起用这4位）\n抢占优先级的级别越高，越能够抢占中断通道，优先执行中断 2. 响应优先级的级别越高，可以优先排队。 中断的优先级，都是数字越小，优先级越高 EXTI外部中断 EXTI外部中断实现 EXTI 可分为两大部分功能，一个是产生中断，另一个是产生事件，这两个功能从硬件上就有所不同。我们的主要关注点是中断。 边沿检测电路用来检测输入的电平信号的高低电平的转换，同时会根据 上升沿/下降沿触发选择寄存器来决定是否向后产生高电平信号 软件中断事件寄存器使用软件来模拟产生一个中断 请求挂起寄存器接收到高电平后会将对应通道的位置1（例如EXTI_9产生高电平进入请求挂起寄存器，则该寄存器会将第9位置1） 最后上面的线路就会进入NVIC(嵌套向量中断控制器) 下面的线路，脉冲发生器作为事件信号送到对应外设，这个脉冲信号可以给其他外设电路使用，比如定时器TIM、模拟数字转换器ADC等等，这样的脉冲信号一般用来触发TIM或者ADC开始转换 产生中断线路目的是把输入信号输入到NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。 产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。 调用流程 以EXTI1为例，下降沿触发，当出现下降沿时，就会触发EXTI5的外部中断，进入EXTI9_5_IRQHandler，在EXTI9_5_IRQHandler中调用HAL_GPIO_EXTI_IRQHandler函数统一处理外部中断，在该函数中对挂起寄存器进行清0操作，并调用HAL_GPIO_EXTI_Callback中断回调函数\n按键实现外部中断控制小灯亮灭 Cube配置 EXTI配置 打开中断\n配置的是下降沿触发，检测下降沿，上拉模式 配置参数解释\n上升沿触发：指的是当引脚电平从低电平(0)转变为高电平(1)时，触发事件 下降沿触发：指的是当引脚电平从高电平(1)转变为低电平(0)时，触发事件 双边沿触发：指的是当引脚的电平发生任何变化（即从低电平到高电平或从高电平到低电平）时，都会触发事件 上拉：指使引脚在未连接（悬空）时默认为 高电平(1) 下拉：指使引脚在未连接（悬空）时默认为 低电平(0) GPIO配置 推挽模式，初始输出为Low低电平\n按键消抖 方式1 1 2 3 4 5 6 7 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {//外部中断回调函数 if( GPIO_Pin == GPIO_PIN_5 ) { //HAL_Delay(10); for( int i = 0 ; i \u0026lt;= 72000*100 ; ++ i );//空循环延时 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_2); } } 方式2 1 2 3 4 5 6 7 8 9 int lastTick = 0 ; void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {//外部中断回调函数 if( GPIO_Pin == GPIO_PIN_5 ) { if( HAL_GetTick()-lastTick \u0026gt; 150 ) { HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_2); lastTick = HAL_GetTick(); } } } 代码实现 1 2 3 4 5 6 7 8 9 int lastTick = 0 ; void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {//外部中断回调函数 if( GPIO_Pin == GPIO_PIN_5 ) { if( HAL_GetTick()-lastTick \u0026gt; 150 ) { HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_2); lastTick = HAL_GetTick(); } } } TIM定时器定时中断 在f103c8t6中，TIM1是高级定时器，TIM2，TIM3，TIM4是通用计时器 下面例子中配置的是TIM1，实现每秒翻转1次小灯亮灭\n调用流程 触发更新中断后进入更新中断服务函数TIM1_UP_IRQHandler，其中调用HAL_TIM_IRQHandler，在该函数中调用了HAL_TIM_PeriodElapsedCallback回调函数\nCubeMX参数配置 使用内部时钟模式\n参数配置如下，实现1s触发一次定时器更新中断\nPrescaker:预分频，实际分频数是number+1 Counter Mode:计数模式设置 Counter Period:自动重装载计数器计数值 Internal Clock Division:内部时钟预分频 Repetiton Counter:重复计数器 (RCR -8 bits)，属于高级控制寄存器专用寄存器位，利用它可以非常容易控制输出 PWM 的个数，与内部时钟模式无关 auto-reload preload:是否开启影子寄存器模式 还需要开启定时器更新中断 代码实现 用的PA2作GPIO输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if( htim == \u0026amp;htim1 ) { HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_2); } } int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM1_Init(); /* USER CODE BEGIN 2 */ HAL_TIM_Base_Start_IT(\u0026amp;htim1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } USART中断 USART的轮询模式会阻塞程序运行，浪费CPU资源\n轮询模式 CPU不断查询发送数据寄存器或者接受数据寄存器导致程序的阻塞\n发送 在UART底层有发送移位寄存器和发送数据寄存器，发送数据时，需要CPU将发送数据寄存器的数据移动至发送移位寄存器，然后UART按照指定的波特率发送数据，CPU则不断查询数据发送寄存器是否空，如果空则需要移动数据进来\n接收 在UART底层有接收移位寄存器和接收数据寄存器，接收数据时，UART按照指定的波特率接收数据至接收移位寄存器，然后数据会存储在接收数据寄存器，CPU则不断查询数据接收寄存器是否有数据，如果有数据，CPU会把寄存器的数据移动至我们用来接收数据的变量的内存里\n当HAL_UART_Receive执行完成，我们就可以知道数据接收完成 中断模式 底层中断实现数据每传送一字节，召回CPU继续运输数据，不需要我们考虑，HAL库底层已经帮我们实现 上层中断实现数据接收完成后的数据处理，通过中断回调函数实现，需要我们自己设计\n发送 CPU将数据送入 发送数据寄存器，然后就去执行其他代码，当发送移位寄存器的数据发送后，发送数据寄存器空，会触发发送数据寄存器空中断，CPU再次将数据送入 发送数据寄存器，然后又去执行其他代码，所有数据发送完成后会触发 传送完成中断，调用HAL_UART_TxCpltCallback中断回调函数 接收 CPU在处理其他代码，接收移位寄存器将一帧数据移动至 接受数据寄存器后，会触发 接收数据寄存器非空中断，CPU会回来将 接收数据寄存器 的数据移动至我们用来接收数据的变量的内存里，然后又去执行其他代码，所有数据完成后会调用_HAL_UART_RxCpltCallback_中断回调函数处理接收的数据 而执行HAL_UART_Receive_IT后，我们不能直接对数据继续处理，数据还没接收完成，因为CPU不会进入阻塞态，会去执行其他代码，需要通过HAL_UART_RxCpltCallback回调函数处理接收的数据\n","date":"2025-06-25T21:48:07+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32%E4%B8%AD%E6%96%AD/","title":"STM32——中断"},{"content":"常见名词 CPU，中央处理单元，Central Processing Unit\nALU，算术逻辑单元，Arithmetic and Logic Units\nCU，控制单元，控制器，Control Unit\nCPU通常由中央处理单元，算术逻辑单元，寄存器组三部分组成\nEU，执行单元，Execution Unit\nBIU，总线接口单元，Bus Interface Unit\nPC，程序计数器，Program Counter\nIR，指令寄存器，Instruction Register\nGR，通用寄存器，General Register\n注意$IO$端口和$IO$接口不是同一个东西\n操作系统知识：程序计数器（pc）、指令寄存器（IR）、通用寄存器（GR）、状态寄存器（SR）、程序状态字PSW_pc和ir-CSDN博客\n特殊运算符和指令 PTR用来指定存储器操作数的字长 Byte PTR[BX]\n所有单操作数指令要求操作数不能是立即数，如果是存储器操作数，需要指定字长\n微型计算机基础概论 微型计算机系统 微型计算机系统 由 硬件系统 和 软件系统 组成 硬件系统 硬件系统 由 微型计算机（主机） 和 外设组成\n微型计算机（主机）由 微处理器（CPU），存储器 ，IO接口 ，总线 组成 外设 就包括键盘，鼠标，显示器，硬盘等 软件系统 软件系统 由 系统软件 和 应用软件 构成\n微型计算机运行流程 微机运行的基本流程为，程序存储在存储器中，按程序流程自动连续取出指令并执行；自动连续的实现是程序计数器 PC 的自增；步骤可概括为取指令、译码、执行。修改 PC 指针的值，可实现程序的顺序执行、跳转、循环、过程调用和中断服务等功能。\n计算机中的数制与编码 十进制D，二进制B，十六进制H，八进制O\n有符号二进制数的表示 最高位是符号位，0表示正号，1表示负号\n原码 数值部分保持不变，最高位是符号位 反码 正数的反码与正数的原码一样 负数的反码 等于 负数原码 数值部分 按位取反 补码 正数的补码与正数的反码和原码一样 负数的补码 的符号位 与 负数原码一致，数值部分等于 负数原码 数值部分取反后再加1\n特殊数-128的补码表示为10000000\n微处理器与总线 CPU中央处理单元 CPU是微型计算机的运算和指挥控制中心 一般由ALU（运算器），CU（控制单元），寄存器组组成 CPU内还有两个独立部件：EU（执行单元）和BIU（总线接口单元） 微处理器主要性能指标 CPU的字长/位数，及其一次性能处理的位数 CPU主频，指的是CPU时钟频率\nCU控制单元 控制器的作用是控制程序的执行，是整个系统的指挥中心 具备以下功能\n指令控制 时序控制 操作控制 EU执行单元 EU负责分析指令（指令译码），执行指令 在工作时不断从BIU的指令队列取指令\nBIU总线接口单元 BIU主要功能是负责CPU与存储器，IO接口之间的信息传送 BIU可以负责取指令，取操作数，写结果 BIU内部有一个指令队列和地址加法器 地址加法器能产生20位的物理地址\nCPU程序执行步骤 从存储器取出下一条指令 指令译码 如果指令需要，从存储器中读取操作数 执行指令（算术逻辑运算，IO操作，数据传输等） 如果需要，写入存储器 核心步骤，取指令，译码指令，执行指令 工作时序 时钟周期：每个时钟脉冲持续的时间 总线周期：通过总线进行一次读或写操作的过程称为一个总线周期，一个总线周期包含多个时钟周期 指令周期：执行一条指令所需的时间，一个指令周期包含多个总线周期 一个基本的总线周期由四个时钟周期构成，若内存或 IO 接口速度较慢，则还会在 T3 后插入 Tw 等待周期。 写操作为例的总线周期 包含4个时钟周期（T1,T2,T3,T4） T1地址输出，T2缓存，T3和T4数据输出\n8088/8086 CPU 8088与8086处理器的区别 8088 外部数据线为8根（8086为16根），为准16位CPU，16 位数据要分两次传送；（ 注意：8088和8086均为16位处理 器，内部数据线均为16位，且地址总线均为20位） 指令预取队列：8088为4字节，8086为6字节\n两者均有两种工作模式，最小工作模式和最大工作模式\n8088/8086指令流水线 采用EU（执行单元）和BIU（总线接口单元）并行工作，可同时取指令，执行指令，分析指令 补充-流水线技术 在指令执行过程中，有几类指令相关影响流水线中指令的执行，使得指令不能在预先设定的执行周期中执行，造成流水线断流 相关问题 结构相关；数据相关；控制相关\n结构相关 当CPU的硬件结构不能够同时支持几条指令的执行时，这几条指令将发生结构相关，比如流水线同时访问同一个存储器\n数据相关 一条指令的执行需要上一条或者上几条指令的执行结果时 ，会造成流水线的断流现象。\n所以，当发生数据相关时，需要尽可能早的把上一条或上几条指令的执行结果 交给相关指令作为操作数。这就需要“内部前推\n控制相关 当指令执行到分支指令或者跳转指令时，将产生控制相关，此时会产生流水线断流。 解决方法：\n阻塞流水线直到确定走向 预测分支是否发生，并给予该预测执行指令 8088/8086内存分段 8088/8086内部结构为16位，为了增大内存管理能力使其能产生20位的物理地址，采用了分段管理方法\n段首地址即段基地址 20位物理地址=段基地址 * 16+段偏移地址 8088/8086内部寄存器 8088/8086内部寄存器分为 通用寄存器（8个），段寄存器（4个），控制寄存器（2个） 通用寄存器 通用寄存器包括 数据寄存器，地址指针寄存器，变址寄存器\n数据寄存器 AX（Accumulator）：累加器，常用于存放算术逻辑运算中的操作数，另外所有的IO指令都是用累加器与外设接口传送信息 BX（Base）：基址寄存器，常用来存放访问内存时的偏移地址（一般和DS一起用DS:[BX]） CX（Count）：计数寄存器，在循环和串操作指令中用作计数器 DX（Data）：数据寄存器，在寄存器间接寻址的IO指令中存放IO端口地址 都可拆分为H，L两个8位寄存器\n在做双字节乘除法运算时，DX与AX可以合起来存一个双字长的数（32位），DX存高16位，AX存低16位\n地址指针寄存器 SP（Stack Pointer）：堆栈指针寄存器，常用来存放 栈顶偏移地址 BP（Base Pointer）：基址指针寄存器，一般也用来存放访问内存时的偏移地址（一般和SS一起用SS:[BP]） BX和BP区别: (1)作为通用寄存器，二者均可用于存放数据；(2)作为基址寄存器，用BX表示 所寻找的数据在 数据段 ；用BP则表示数据在 堆栈段\n变址寄存器 SI（Source Index）：源变址寄存器 DI（Destination Index）：目的变址寄存器 段寄存器 段寄存器，用于存放段基址，即段起始地址的高16位\nCS（Code Segment）：代码段寄存器 SS（Stack Segment）：堆栈段寄存器 DS（Data Segment）：数据段寄存器 ES（Extra Segment）：附加数据段寄存器 控制寄存器 IP（Instruction Pointer）：指令指针寄存器，其内容为下一条要执行指令的偏移地址（CS段中） 标志寄存器 FLAGS：状态寄存器，16位寄存器 状态标志位 CF（Carry Flag）：进位标志位，进行加减运算时，若最高位向前有进位错位，则CF=1 PF（Parity Flag）：奇偶标志位，运算结果低8位中1的个数为偶数，PF=1 AF（Auxiliary Carry Flag）：辅助进位标志位，加减法运算，D3向D4进位时，AF=1 ZF（Zero Flag）：零标志位，运算结果为0时，ZF=1 SF（Sign Flag）：当运算结果最高位为1时，SF=1 OF（Overflow Flag）：当算术结果超出了 带符号数的范围时，即溢出时，OF=1 控制标志位\nTF（Trap Flag）：陷井标志位，也叫跟踪标志位。TF=1时，使CPU处于单步执行指令的工作方式 IF（Interrupt Enable Flag）：中断允许标志位。IF=1使CPU可以响应可屏蔽中断请求 DF（Direction Flag）：方向标志位。在数据串操作时确定操作的方向 IF=1，允许响应可屏蔽中断请求，对应指令：STI IF=0，禁止响应可屏蔽中断请求，对应指令：CLI\nDF=0，串操作指令中的地址是增加方向，对应指令：CLD DF=1，串操作指令中的地址是减少方向，对应指令：STD\nTF=1，CPU按跟踪方式（单步方式）执行程序\n8088外部引脚及其功能 最小模式下的引脚描述\n按功能对引脚进行划分：\n基础工作引脚：$Vcc,GND,CLK(4.77Mhz)$ 地址总线：${AD}0-{AD}7,A_8-A{15},A{16}-A_{19}$ 数据总线：${AD}_0-{AD}_7$ 模式控制引脚：$MN/\\overline{MX}$ 读写控制引脚：$IO/\\overline M,\\overline{RD},\\overline{WR}$ 中断控制引脚：$INTR,NMI,INTA$ 复位：$RESET$ 总线保持请求/响应：$HOLD,HLDA$ 地址锁存信号：$ALE$ 外部就绪信号：$READY$ 测试信号输入：$\\overline {TEST}$ 数据传输方向控制：$DT/\\overline R$ 数据允许信号：$\\overline {DEN}$ 系统状态输出：$\\overline{{SS}_0}$（与$IO/\\overline M,DT/\\overline R$合作） 各引脚具体功能 $A_{16}-A_{19}/S_3-S_6$：地址，状态复用的引脚，三态输出。（分时复用）状态信号中$S_6$恒等于0，$S_5$指示中断允许标志位$IF$的状态，$S_4,S_5$组合指示CPU正在使用的段寄存器\n$A_8-A_{15}$：8位地址信号，三态输出\n${AD}{0}-{AD}{7}$：地址，数据分时复用的双向信号线，三态。当$ALE=1$时，这些引脚上传输的是地址信号，当$\\overline {DEN}=0$时，这些引脚上传输的是数据信号\n$IO/\\overline M$：输入输出/存储器控制信号，三态。该引脚是用来区分当前操作是访问存储器还是访问$IO$端口\n$\\overline {WR}$：写信号输出，三态。当此引脚输出为低电平时，表示CPU正在对存储器或IO端口进行写操作\n$DT/\\overline {R}$：数据传送方向控制信号，三态。高电平时，CPU向存储器或IO端口发送数据；低电平时，CPU从存储器或IO接口接收数据\n$\\overline {DEN}$：数据允许信号，三态。该信号有效时，表示 数据总线 上具有有效信号。它在每次 访问内存或IO接口以及在中断响应期间有效，常用作数据总线驱动信号\n$ALE$：地址锁存信号，三态输出，高电平有效。它为高电平时，表示CPU地址线上有有效地址\n$\\overline {RD}$：读选通信号，三态输出，低电平有效。其有效时，表示CPU正在对存储器或IO接口进行读操作\n$READY$：外部同步控制输入信号，高电平有效。它是由被访问的内存或IO设备所发出的响应信号。它为高电平时，表示存储器或IO设备已经准备好，CPU可以进行数据传送 。CPU在T3的周期采样$READY$信号，若其为低，CPU自动插入等待周期$T_w$\n$INTR$ ：可屏蔽中断请求输入信号，高电平有效。CPU在每条指令的最后一个周期采样该信号，以决定是否进入中断响应周期\n$\\overline {TEST}$：测试信号输入引脚\n$NMI$：非屏蔽中断请求输入信号，上升沿触发。这个引脚上的中断请求信号不能用让软件屏蔽，CPU在当前指令\n$RESET$：系统复位输入信号，高电平有效。\n$\\overline {INTA}$：中断响应信号输出，低电平有效，此信号是CPU对中断请求信号$INTR$ 的响应。 在响应过程中，CPU在$\\overline {INTA}$上连续输出两个负脉冲用作外部中断的中断向量码的读选通信号\n$HOLD$：总线保持请求信号输入，高电平有效。当某一总线主控设备要占用系统总线时，通过此引脚向CPU提出请求\n$HLDA$：总线保持响应信号输出，高电平有效。这是CPU对$HOLD$请求的响应信号。CPU收到$HOLD$信号后，就会对其做出响应，一方面会使CPU的所有三态输出的地址信号，数据信号和对应的控制信号变为高阻态；同时输出一个有效的$HLDA$，表示CPU已放弃对总线的控制。当CPU检测到$HOLD$信号变低后，就立即使$HLDA$变低，同时恢复对总线的控制\n${SS}_0$：系统状态信号输出\n$CLK$： 时钟信号输入引脚\n$Vcc$：5V电源输入引脚\n$GND$：地线\n8088/8086结构功能 外部结构 总线 总线定义 总线是传输信号或信息的公共路径，是遵循同一技术规范的连接与操作方式\n总线特点 公共性，可同时挂在多个设备\n总线分类 按传送的信息类型分类\n数据总线（Data Bus） 地址总线（Address Bus） 控制总线（Control Bus） 按总线的层次结构划分\n前端总线 系统总线 外设总线 总线结构 单总线结构，多总线结构\n总线基本功能 总线上任意时刻只能允许一对设备进行信息交换\n总线传输同步：协调通信双方的传输操作 总线仲裁控制：避免多个设备同时使用总线造成的冲突，确定总线上哪个设备可以占用总线传输数据 出错处理：检错和处理 总线驱动：增加驱动能力 总线的数据传送 1.同步定时的传输方式 用公共的时钟统一各部件数据发送和接收的时机 （严格按节拍进行，不需要握手信号，效率高）\n2.异步定时的传输方式 用控制和状态信号协调各部件数据发送和接收的时机（应答式）\n3.半同步定时的传输方式 允许不同速度的部件协同工作，主控设备可以根据从设备的状态延长总线 时钟周期，但总线周期一定是时钟周期的整数倍\n常用系统总线和外设总线标准 常用的系统总线标准包括：ISA 总线、PCI 总线、PCIE 总线、AGP 总线 常用的外设总线标准包括：SATA 总线、USB 总线、RS485 总线、IDE 总线、RS232 总线\n指令系统 指令：控制计算机完成指定操作并能够被计算机所识别的命令。 指令系统：一台计算机能够识别的所有指令的集合称为该机的指令系统\n指令格式： 操作码 操作数1，操作数2 操作数数量：零操作数指令，单操作数指令，双操作数指令\n指令中操作数类型：立即操作数，寄存器操作数，存储器操作数 寄存器操作数的指令执行速度\u0026gt; 立即数操作数\u0026gt; 存储器操作数\nCISC（Complex Instruction Set Computer），复杂指令系统计算机 RISC（Reduced Instruction Set Computer），精简指令系统计算机\n指令性指令是CPU中实际存在的可执行的语句。指示性语句是用于说明程序结构，变量等的语句，后者在编译过程中执行，编译完成后不再存在\n对于每个指令 指令码的含义 指令对操作数的要求 指令对标志位的影响 指令的功能 寻址方式 立即寻址（Immediate Addressing） 源操作数是立即数，立即数存放在代码段 MOV AX,3102H\n直接寻址（Direct Addressing） 操作数是存储器操作数，存放的地址由指令直接给出 MOV AX,[3102H]\n寄存器寻址（Register Addressing） 操作数为CPU内部寄存器 MOV AX,BX\n寄存器间接寻址（Register Indirect Addressing） 寄存器存放的不是数据本身，而是存放数据的偏移地址 寄存器间接寻址方式中 存放操作数偏移地址 的寄存器只允许是 $SI,DI,BX,BP$，它们也被称为间址寄存器\n选择$SI,DI,BX$作为间址寄存器时，操作数在数据段，段基址由$DS$决定 选择$BP$作为间址寄存器，则操作数在堆栈段，段基地址由$SS$决定 允许段重设 MOV AX,[BX] MOV AX,ES:[SI] 寄存器相对寻址 操作数在内存中的偏址地址由间址寄存器的值加上一个8位或16位的偏移量 MOV AX,DATA[BX] MOV AX,[BX+DATA]\n基址-变址寻址 基址-变址寻址方式由一个基址寄存器存的值和一个变址寄存器存的值 相加得到偏移地址\n不允许出现两个基址寄存器 不允许出现两个变址寄存器 MOV AX,[BX][SI] MOV AX,[SI][BX] MOV AX,[BX+SI] 基址-变址-相对寻址 所寻地址在内存中，偏移地址由一个基址寄存器、一个变址寄存器和数值偏移 量相加给出。其它规定同“基址-变址寻址” MOV AX,DATA[SI][BX] MOV AX,[BX+DATA][SI] MOV AX,[BX+SI+DATA] MOV AX,[BX+SI]DATA MOV AX,[BX]DATA[SI]\n隐含寻址 指令中隐含了部分固定的操作数的地址 MUL BL 把AL与BL相乘的乘积放入AX\n堆栈段 规定由SS指示堆栈段的段基址，堆栈的最低地址 堆栈指针SP始终指向堆栈的顶部（栈顶）。堆栈的最高地址叫栈底 栈的压入指令 PUSH src 栈的弹出指令 POP dest\n操作原则\n操作数为1个字，且只能是寄存器或存储器操作 存放数据从高地址向低地址方向增长 堆栈段位置由SS决定，SP指向栈顶 PUSH压入过程为先减SP再压数据 1 2 3 SP-2 -\u0026gt; SP src高8位-\u0026gt;[SP+1] src低8位-\u0026gt;[SP] POP弹出过程为先弹数据再加SP 1 2 3 [SP]-\u0026gt;dest低8位 [SP+1]-\u0026gt;dest高8位 SP+2-\u0026gt;SP 堆栈主要用途：保护现场\n数据传送指令 数据传送指令的执行均不影响标志位\n一般传送指令MOV MOV dest,src 对操作数要求：\n两个操作数字长相同 两个操作数不能同时为存储器操作数 不能用立即数直接给段寄存器赋值 两个操作数不能同时为段寄存器 IP和CS只作为MOV的源操作数，不做目标操作数 FLAGS整体不能作为操作数 两个操作数不能同时为存储器操作数，原因是存储器不能确定字长，是在存储器中取1个字节还是多个字节，没有限定\n堆栈操作指令PUSH和POP PUSH src POP dest 操作数为1个字，且只能是寄存器或存储器操作，不能是立即数\n交换指令XCHG 功能：交换源地址与目标地址中的内容 XCHG OPRD1,OPRD2\n输入/输出指令IN和OUT 功能：对输入/输出端口进行读写 输入指令IN用于从IO端口读数据到累加器AL（AX）中 输出指令OUT用于把累加器AL（AX）的内容写到IO端口 IO端口寻址\n直接寻址：指令中的IO端口地址为8位 1 2 IN AL/AX,port OUT port,AL/AX 寄存器间接寻址：端口地址为16位，由DX寄存器指定 1 2 IN AL/AX,DX OUT DX,AL/AX 操作原则\n只有AL或AX可以与I/O端口进行数据交换 IO端口地址可以是8位立即数指向的地址（即直接寻址）或由DX保存的16 位地址（即间接寻址） 当端口地址是16位时，只能用DX取给定端口地址 取偏移地址指令LEA （Load Effect Address） 功能：将存储器操作数的16位偏移地址送到指定寄存器 LEA reg16, mem 操作原则\n源操作数必须是存储器操作数，如： LEA BX, BUFFER LEA BX, [SI] 目标操作数必须是16位通用寄存器，最好使用间址寄存器（BX, SI, DI, BP） 源操作数必须是存储器操作数 算数运算指令 不带进位和带进位的加减指令 无符号和有符号的乘除指令\n算术运算指令的执行会影响状态标志位 乘法指令执行结果为相乘数的双倍字长 除法指令被除数是除数的双倍字长\n乘法指令 乘法指令采用隐含寻址，隐含了存放被乘数的累加器AL或AX，以及存放结果的AX或AX，DX\n无符号乘法指令 MUL BYTE PTR[BX] 有符号乘法指令 IMUL OPRD\n除法指令 DIV OPRD 如果$OPRD$是单字节数 意思是$AX/OPRD$ 结果：AL=商，AH=余数 如果$OPRD$是双字节数 意思是$DX,AX/OPRD$ 结果：AX=商，DX=余数\n算数移位指令 非循环移位 算数移位，逻辑移位 左移，右移\n循环移位 分为带进位移位和不带进位移位\n存储器 RAM（Random-Acess Memory）一般可分为SRAM（静态RAM），DRAM（动态RAM） ROM（Read Only Memory）一般可分为 掩膜ROM，一次性可写ROM，EPROM，EEPROM，闪速存储器Flash\n高位地址，选通芯片 低位地址，选芯片的读写单元\n译码，将输入的一组高位地址信号通过变换，产生一个有效的输出信号，用于选中某一个存储器芯片，从而确定了该存储器芯片在内存的地址范围\n全地址译码 用全部高位地址信号作为译码信号，使得存储器芯片的每一个单元都占据一个唯一的内存地址 部分地址译码 用部分高位地址信号作为译码信号，使得被选中存储器芯片占有几组不同的地址范围\nCache高速缓冲器 Cache高速缓冲存储器，Cache是构成内存储器的部件之一，设置Cahce的原因是内存的速度与处理器的工作速度不匹配\n微机中的存储器系统\nCache存储器系统 虚拟存储器系统 Cache存储系统 Cache存储系统主要有Cache高速缓冲器和主内存构成，有硬件系统负责管理 IO系统 输入输出系统 在计算机系统中，通常把处理器和主存储器之外的部分统称为输入/输出系统， 包括输入/输出设备、输入/输出接口和输入/输出软件\nIO接口 IO接口就是外设连接到系统总线上的一组逻辑电路的总称\nIO端口 端口是接口电路中用于缓存数据及控制信息的部件 CPU与I/O接口进行通信实际上是通过I/O接口内部的一组寄存器实现的，这些寄存器通常称为I/O端口（I/O Port）。它包括3种类型：数据端口、状态端口和命令（控制）端口\nIO端口编址方式 分为统一编址和独立编址\nI/O端口与内存单元统一编址，指令及控制信号统一，内存地址资源减少 I/O端口独立编址，内存地址资源充分利用，使用不同的控制信号，能够应用于端口的指令较少 输入接口需要具备数据控制能力，一般采用三态门接口，防止外设的输入影响数据总线，如74LS244\n输出接口需要具备数据锁存能力，一般采用锁存器接口，如74LS273\n基本输入输出方式 1.无条件传送方式 2.查询方式 3.中断方式 4.直接存储器存取方式（DMA）\n中断 CPU执行程序中，由于发生了某种随机的事件(外部或内部)，引起CPU暂时 中断正在运行的程序，转去执行一段特殊的服务程序(称为中断服务程序或 中断处理程序)，以处理该事件，该事件处理完后又返回被中断的程序继续 执行，这一过程称为中断 中断响应过程 可屏蔽外部中断响应过程 通过两个连续的中断响应总线周期获取中断类型码 获取中断向量后并调用中断，服务程序\n内部中断响应过程 无中断响应总线周期 中断类型码固定或由指令（INT n）给出\n主要芯片 1.计数器8253 特殊引脚 CLK——时钟脉冲输入 GATE——门控信号输入 OUT——定时输出 编程方式 控制字直接写入控制寄存器 计数值写入对应计数器 工作方式 总览\n16位减法计数，计数值减为0时输出相应控制信号 输出控制信号的形式可通过软件设置 方式0——计数结束中断 软件启动，不自动重复计数 计时结束输出高电平，输出可以用作中断请求信号\n不自动重复计数是指 每写入一次计数初值只计数一个周期\n方式1——可重复触发的单稳态触发器 硬件启动，不自动重复计数 但是可以通过GATE重复触发计数，当GATE出现上升沿时，下一个CLK的下降沿开始计数 计数结束后，OUT端输出高电平\n方式2——频率发生器 既可以软件启动，也可以硬件启动 自动重复计数，OUT端输出N-1个时钟周期的高电平，1个时钟周期的低电平\n方式3——方波发生器 软硬件启动，自动重复计数 输出对称方波（连续方波） N为偶数，完全对称，N为奇数，正脉冲会长一点\n方式4——软件触发选通 软件启动，不自动重复计数 计数结束输出一个CLK宽度的低电平\n方式5——硬件触发选通 硬件启动，不自动重复计数 波形与方式4一致，计数结束输出一个CLK宽度的低电平\n小结 需要两个写脉冲——两次写操作\n第一次写脉冲写入控制字 第二次写脉冲写入计数初值 能输出连续波形的只有方式2和方式3\n2.可编程并行接口8255 三个端口 A口：支持0，1，2工作方式 B口：支持0，1工作方式 C口，支持0工作方式\n工作方式 方式0——基本输入输出方式 方式1——选通工作方式 方式1输出接口A\n$\\overline {OBF}$：接口输出缓冲器满信号，告诉外设可以从该端口读走信号 $\\overline {ACK}$：外设从端口取走数据，发出响应信号 外设取走信号后，发出$\\overline {ACK}$响应信号，同时使$\\overline {OBF}=1$，同时还会产生一个有效的$INTR$信号\n方式1输入接口A\n$\\overline {{STB}_A}$：外设写入 ${{IBF}_A}$：当输入缓冲器满后，接口发出的高电平有效信号\n方式2——双向传送方式 可以既作为输入口，又作为输出口 只有A口可以工作在此模式下，当A口工作在方式2时，B口可以工作在方式0或1\n控制字 方式控制字：用于确定3个端口的工作方式及数据传送方向 位控制字：仅用于C端口，可设置C口某位的初始状态（高低电平）\nD7=1，方式控制字 D7=0，位控制字\n3.DA转换芯片DAC0832 差动输出，双缓冲\n工作方式 单缓冲工作方式 双缓冲工作方式 4.AD转换芯片ADC0809 5.可编程中断控制器8259A 特殊引脚 $INT$：接CPU的中断请求引脚 $\\overline {INTA}$：接CPU的中断响应引脚 $A0$：8259A内部寄存器选择信号 $CAS0-CAS2$：多个8259级联引脚时使用，级联控制线 $\\overline {SP}$：在非缓冲模式下，用来指定8259A是从片还是主片，$\\overline {SP}$=1的8259是主片\n内部结构 工作过程 工作方式 中断优先方式与中断嵌套 （1）固定优先级方式 （2）循环优先级方式\n屏蔽中断源的方式 普通屏蔽方式：对IMR某位置1，则屏蔽该位对应的中断请求\n级联工作方式 （1）主片、从片有不同的地址 （2）主片、从片分别进行编程\n8259A的编程 初始化编程 初始化命令字ICW1（初始化字）：单片/多片级联、电平/边沿触发 初始化命令字ICW2（中断向量码）：给CPU提供中断向量 注意：例如，写入ICW1，端口地址为20H，写入ICW2时，端口地址为21H\n初始化命令字ICW3（级联控制字）：指出哪个引脚进行了级联 初始化命令字ICW4（中断结束方式字）：给出8259A结束中断处理的方式\n操作方式编程 操作命令字OCW1（中断屏蔽字）：某位为1则该引脚中断被屏蔽 操作命令字OCW2（中断结束和优先级循环）：指定优先级顺序和中断结束方式 操作命令字OCW3（屏蔽方式和状态读出控制字）：设置特殊屏蔽、查询方式\n","date":"2025-06-24T23:16:11+08:00","permalink":"https://NomadJoeviolet.github.io/p/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/","title":"微机原理"},{"content":"STM32F103C8T6 的 CAN 控制器和 CAN 收发器 1. CAN 控制器 STM32F103C8T6 内置 CAN 控制器：该芯片内置了 bxCAN（Basic Extended CAN）控制器，支持 CAN 2.0A 和 2.0B 协议 功能： 数据帧的封装与解析 错误检测与处理 总线仲裁 位定时与同步 引脚： CAN_RX（PA11）：接收数据 CAN_TX（PA12）：发送数据 2. CAN 收发器 STM32F103C8T6 没有内置 CAN 收发器：CAN 收发器负责将 CAN 控制器的逻辑信号转换为 CAN 总线的差分信号（CAN_H 和 CAN_L），反之亦然 需要外接 CAN 收发器：常见的 CAN 收发器包括 TJA1050、MCP2551 等 功能： 将 CAN 控制器的逻辑信号转换为差分信号 提供电气隔离（部分型号） 保护 CAN 控制器免受总线电气干扰 总结 CAN 控制器：STM32F103C8T6 内置了 CAN 控制器，支持 CAN 2.0A 和 2.0B 协议 CAN 收发器：STM32F103C8T6 没有内置 CAN 收发器，需外接（如 TJA1050 或 MCP2551） 连接方式 CAN 控制器：通过 CAN_RX（PA11）和 CAN_TX（PA12）与 CAN 收发器连接。 CAN 收发器：将 CAN_H 和 CAN_L 连接到 CAN 总线 示例电路 STM32F103C8T6： PA11（CAN_RX） → CAN 收发器的 RXD PA12（CAN_TX） → CAN 收发器的 TXD CAN 收发器（如 TJA1050）： CAN_H 和 CAN_L 连接到 CAN 总线 总结 STM32F103C8T6 内置 CAN 控制器，但需外接 CAN 收发器 才能实现完整的 CAN 通信功能 ","date":"2025-06-24T23:11:52+08:00","permalink":"https://NomadJoeviolet.github.io/p/can%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8Ccan%E6%94%B6%E5%8F%91%E5%99%A8/","title":"CAN控制器和CAN收发器"},{"content":"STM32H743-梳理ADC模数转换器在CubeMX上的配置_overrun behaviour-CSDN博客（写的很好，很详细）\nSTM32-HAL库-ADC学习 - 曲杨 - 博客园\nADC定义 模数转换器(Analog to Digital Converter,ADC) 模拟信号-\u0026gt;数字信号转换器\n通过对输入的模拟信号进行测量，将其分级转换为数字信号\nSTM32单片机中的ADC 一般计算采用一下逻辑方式进行转换\n1 2 3 4 5 6 7 if( V\u0026gt;V_ref_low \u0026amp;\u0026amp; V\u0026lt;V_ref_high ) { return (V-V_ref_low)/(V_ref_high-V_ref_low) * (2\u0026lt;\u0026lt;X-1); //归一化，再按照配置的x进行转换 } else { return erro ; } STM32单片机中的ADC，x一般是12，也可以是其他数值 一般情况下，参考电压为0V，参考高电压为3.3V\n分辨率与精度 分辨率与位数有关，精度与性能有关，位数越高，分辨率越高，性能越高，波动越小，精度越强 ADC位数为12位，则分辨率是1/4096\n使用时PLCK频率控制在36MHz以内，不然ADC模块的精度会大幅降低\nSTM32CubeMX配置 这里以STM32C8T6为例\nx即Resolution 12bits( 15ADC时钟周期 )（看芯片型号，有的需要配置） 数据选择右对齐，得到的数据就是转换后的值 Mode选择Independent mode Scan Conversion Mode（扫描转换模式），会采集ADC开启的所有通道，按顺序采集所有通道 Continuous Conversion Mode（连续转换模式），可以在使能ADC时自动开始采集，而非手动采集 Discontinuous Conversion Mode（间断采集模式），可以在一轮采集完成后暂停等待指令控制下一轮采集\nNumber Of Discontinuous Conversions（单次转换次数）此参数定义每次触发后ADC执行的转换次数，每次转换完都需要HAL_ADC_GetValue来获取值。 如果它设为2，且ADC1使能了通道1，2，5，7的话，那么第一次触发ADC1采样时，就会采样通道1与通道2的值，再一次触发ADC1采样的话，就会采样通道5与通道7值，如此类推。\nADC_Regular_ConversionMode 可以配置每个通道的采集顺序和采样时间\n代码使用 1.开始采集\n1 HAL_ADC_Start(\u0026amp;hadc2); 2.采集后转换\n1 HAL_ADC_PollForConversion(\u0026amp;hadc2,20);//地址，等待时间 关于多数据通道采集 ADC_value[1]对应rank_1的通道的值，第一次采集rank1通道 ADC_value[2]对应rank_2的通道的值，第一次采集rank2通道 rank指在ADC_Regular_ConversionMode中的rank设置\n1 2 3 4 5 6 7 for( int t = 1 ; t \u0026lt;= 10 ; ++ t ) { for( int i = 0 ; i \u0026lt; 2 ; ++ i ) { HAL_ADC_Start(\u0026amp;hadc2); HAL_ADC_PollForConversion(\u0026amp;hadc2,20);//采集后转换 AD_value[i] += HAL_ADC_GetValue(\u0026amp;hadc2) ;//采集十次，平均值处理 } } 检测 1 2 3 if(HAL_IS_BIT_SET( HAL_ADC_GetState(\u0026amp;hadc2),HAL_ADC_STATE_REG_EOC) ) {//检测是否正常采集 ADC_value += HAL_ADC_GetValue(\u0026amp;hadc2); } 关于Number Of Discontinuous Conversions 在STM32CubeMX中，Number Of Discontinuous Conversions（单次转换次数）是ADC（模数转换器）的一个配置选项，主要用于控制ADC在**非连续采样模式（Discontinuous Mode）**下的转换行为。以下是详细解释和使用方法：\n1. 功能含义 作用：\n当ADC配置为非连续模式（Discontinuous Mode）时，此参数定义每次触发后ADC执行的转换次数。 例如，设置为3，则每次触发ADC后，会自动连续完成3次转换（无需额外触发信号）。 若设置为1，则每次触发仅执行1次转换（等同于标准单次模式）。 应用场景：\n适用于需要分组采样的场景，例如： 周期性触发ADC，但每次触发需采集多个通道的数据。 降低CPU干预频率（通过一次触发完成多次转换）。 2. 配置步骤（STM32CubeMX） 启用Discontinuous Mode： 在ADC配置界面，勾选 Discontinuous Mode（通常在Parameter Settings选项卡中）。 此时，Number Of Discontinuous Conversions选项会生效。 设置转换次数： 输入需要的转换次数（取值范围取决于型号，通常为1~8）。 该值必须 ≤ 总启用通道数（例如，若启用5个通道，最多可设置为5）。 配置触发源： 选择触发方式（如定时器触发、外部引脚触发等）。 每次触发信号到来时，ADC会自动完成设定的转换次数。 3. 工作流程示例 硬件环境： ADC通道：CH0、CH1、CH2 配置：Discontinuous Mode + Number Of Discontinuous Conversions = 2 行为： 触发信号到来（如定时器溢出）。 ADC自动连续转换2个通道（例如CH0→CH1）。 转换完成后产生中断/DMA请求。 下次触发时，继续从下一个通道开始（CH2→CH0，依此类推）。 在该配置下（Discontinuous Mode + Number Of Discontinuous Conversions = 2），每次触发后ADC会连续转换2个通道（例如CH0→CH1），因此你需要调用两次 HAL_ADC_GetValue(\u0026amp;hadc2) 来分别读取这两个通道的转换结果。以下是具体说明和注意事项：\n1. 数据读取方式 方法一：轮询模式（Polling） 每次触发后，需手动读取两次ADC值：\n1 2 3 4 5 6 7 8 HAL_ADC_Start(\u0026amp;hadc2); // 启动ADC（或通过触发信号启动） //开启一次，采集两次 if (HAL_ADC_PollForConversion(\u0026amp;hadc2, timeout) == HAL_OK) {//采集后第一次转换 uint32_t ch0_value = HAL_ADC_GetValue(\u0026amp;hadc2); // 读取CH0结果 } if (HAL_ADC_PollForConversion(\u0026amp;hadc2, timeout) == HAL_OK) {//采集后第二次转换 uint32_t ch1_value = HAL_ADC_GetValue(\u0026amp;hadc2); // 读取CH1结果 } 注意：每次调用 HAL_ADC_GetValue() 会返回最后一次完成的转换结果，因此需按顺序读取。 方法二：中断模式（Interrupt） 在ADC转换完成中断中读取：\n1 2 3 4 5 6 void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) { if (hadc == \u0026amp;hadc2) { uint32_t ch0_value = HAL_ADC_GetValue(\u0026amp;hadc2); // 第一次转换结果（CH0） uint32_t ch1_value = HAL_ADC_GetValue(\u0026amp;hadc2); // 第二次转换结果（CH1） } } 关键点：在中断回调中需连续读取两次，顺序由ADC的Rank配置决定。 方法三：DMA模式（推荐） 若启用DMA，ADC会自动将多次转换结果存入指定数组，无需手动调用 HAL_ADC_GetValue()：\n1 2 uint32_t adc_results[2]; // 存储2次转换结果 HAL_ADC_Start_DMA(\u0026amp;hadc2, adc_results, 2); // 启动DMA传输 结果存储：\nadc_results[0] → CH0的值，adc_results[1] → CH1的值（顺序由Rank决定）。 4. 注意事项 与连续模式（Continuous Mode）的区别： 连续模式：ADC无限循环转换所有启用通道，无需触发。 非连续模式：需外部触发，且每次触发仅转换设定的次数。 DMA配合： 建议启用DMA，以高效搬运多组转换结果（尤其是高频触发场景）。 DMA缓冲区大小需 ≥ 转换次数 × 通道数。 通道顺序： 转换顺序由Rank（在ADC配置中定义）决定，而非通道编号。 总结 Number Of Discontinuous Conversions 是ADC非连续模式下每次触发的转换次数。 关键配置：启用Discontinuous Mode → 设置转换次数 → 配置触发源。 优势：灵活控制采样节奏，减少CPU负担，适合分组采样需求。 ","date":"2025-06-24T22:44:59+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32adc%E6%A8%A1%E5%9D%97/","title":"STM32————ADC模块"},{"content":"视频推荐： 【c/cpp程序编译过程】https://www.bilibili.com/video/BV1JM4m127y7?vd_source=5a0790755035f26a67935abfbfcdfd5b\n文章推荐： 详解C/C++代码的预处理、编译、汇编、链接全过程 - 知乎 (zhihu.com) C++ 预编译，编译，汇编，链接 - Suarezz - 博客园 (cnblogs.com) C/C++编译链接 - 知乎 (zhihu.com)(进阶)\n关于编译器与不同系统的文件 一般编译器可以分为前端和后端，前端主要负责 语义分析，后端主要负责 代码生成\nLinux macOS Windows 可执行文件 .out或/ .out或/ .exe 目标文件 .o .o .obj 静态库 .a .a .lib 动态库 .so .dylib .dll GCC负责编译，生成各类库和目标文件，然后调用外部链接器进行链接然后生成可执行文件\nLLVM同时有编译器和链接器（例如：armclang和armlink）\n运行程序的运行阶段，是让加载器将最后生成的可执行文件放到内存中\nGCC、GNU、gcc与g++ GNU：一个操作系统，具体内容不重要，感兴趣可以参考：\nGCC、GNU到底啥意思？_一只杨阳羊的博客-CSDN博客​blog.csdn.net/qq_43617936/article/details/104504992\nGCC：GNU Compiler Collection（GNU编译器集合）的缩写，可以理解为一组GNU操作系统中的编译器集合，可以用于编译C、C++、Java、Go、Fortan、Pascal、Objective-C等语言 gcc：GCC（编译器集合）中的GNU C Compiler(C 编译器) g++：GCC（编译器集合）中的GNU C++ Compiler(C++ 编译器) 简单来说，gcc调用了GCC中的C Compiler，而g++调用了GCC中的C++ Compiler 对于 *.c 和 *.cpp 文件，gcc分别当作 c 和 cpp文件编译，而g++则统一当作cpp文件编译\n![[Pasted image 20241126223616.png]]\nGDB(gdb) GDB（gdb）全称“GNU symbolic debugger”，是 Linux 下常用的程序调试器。 为了能够使用 gdb 调试，需要在代码编译的时候加上-g，如\n1 g++ -g -o test test.cpp 常用指令 ![[Pasted image 20241027090624.png]]\n编译过程 ![[Pasted image 20241027085312.png]]\n![[Pasted image 20241027092346.png]]\nstep1. 预处理 ![[Pasted image 20241026230159.png]] 命令：\n1 g++ -E test.cpp -o test.i 作用：\n去掉注释 预处理指令替换（ifndef ，宏定义等） include 导入的头文件替换 预处理实例对比 .cpp 文件 ![[Pasted image 20241026230758.png]]\n预处理后的 .i 文件\n还有替换的\n1 #include\u0026lt;iostream\u0026gt; 被省略了，替换的内容有3万多行\n翻到最下面查看\n![[Pasted image 20241026230952.png]]\n具体解释 预处理，顾名思义就是编译前的一些准备工作\n预编译把一些#define的宏定义完成文本替换，然后将#include的文件里的内容复制到.cpp文件里，如果.h文件里还有.h文件，就递归展开。在预处理这一步，代码注释直接被忽略，不会进入到后续的处理中，所以注释在程序中不会执行\nstep2. 编译阶段 ![[Pasted image 20241027001928.png]]\n命令：\n1 g++ -S test.i -o test.s 对 .i 文件进行编译 也可以对 .cpp 文件进行编译\n1 g++ -S test.cpp -o test.s 作用：\n翻译成汇编语言 检查代码报错 具体解释 编译只是把我们写的代码转为汇编代码，它的工作是检查词法和语法规则，所以，如果程序没有词法或则语法错误，那么不管逻辑是怎样错误的，都不会报错。\n编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程\nstep3. 汇编阶段 ![[Pasted image 20241027002224.png]] 命令：\n1 g++ -c test.s -o test.o 作用：\n将 .s 文件，汇编成二进制文件（二进制文件不可执行） step4. 链接阶段 ![[Pasted image 20241027002618.png]]\n命令：\n1 gcc test.o -o test 作用：\n将目标文件 .o和库文件链接 具体解释：C语言代码经过编译以后，并没有生成最终的可执行文件（.exe 文件），而是生成了一种叫做目标文件（Object File）的中间文件（或者说临时文件）。目标文件也是二进制形式的，它和可执行文件的格式是一样的。对于 Visual C++，目标文件的后缀是.obj；对于 GCC，目标文件的后缀是.o。这就是一开始所说的编译完一堆.obj和.o文件的来源。\n目标文件经过链接（Link）以后才能变成可执行文件。既然目标文件和可执行文件的格式是一样的，为什么还要再链接一次呢，因为编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。链接（Link）其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做链接器（Linker）。\nC++程序编译的时候其实只识别.cpp文件。每个cpp文件都会分别编译一次，生成一个.o或者.obj文件。这个时候，链接器除了将目标文件和系统组件组合起来，还需要将编译器生成的多个.o或者.obj文件组合起来。\ng++自动链接了系统组件，我们只需要把自定义函数的目标文件与main.o链接即可\n链接的其他过程 C/C++编译链接 - 知乎 (zhihu.com)(进阶)\n合并段 ![[Pasted image 20241027092742.png]]\n调整段偏移 ![[Pasted image 20241027092757.png]]\n多文件g++编译指令 ![[Pasted image 20241027222011.png]]\n1 g++ src/cmake_leran.cpp tools/hello.cpp -I includes -o cmake_leran src/cmake_leran.cpp tools/hello.cpp 是在指定当前目录下哪些源文件需要编译 -I includes 是 库文件所在的目录\n![[Pasted image 20241126230718.png]]\n杂谈 关于库文件 ![[Pasted image 20241126224636.png]]\n![[Pasted image 20241126224803.png]]\n关于可执行文件 ![[Pasted image 20241126225616.png]]\n关于C与C++联合生成可执行文件 在C++中，告诉编译器以C的标准进行编译 C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //关键字 extern \u0026#34;C\u0026#34; //example #include\u0026lt;iostream\u0026gt; using namespace std; extern \u0026#34;C\u0026#34; void func() { //用 extern\u0026#34;C\u0026#34;修饰 } extern \u0026#34;C\u0026#34; void func(int v) {//用 extern\u0026#34;C\u0026#34;修饰 } int main() {\treturn 0; } 1 2 3 4 5 6 7 8 9 10 11 12 //如果当前文件为cpp文件，就会告诉编译器按C语言方式编译和链接 //如果不是cpp文件，则会被略过 #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif \u0026lt;被调用内容\u0026gt; #ifdef __cplusplus } #enddif 如果编译器是 C++ 编译器，__cplusplus 宏会被定义，extern \u0026ldquo;C\u0026rdquo; 块将会被包含，这告诉编译器按照 C 语言的规则来处理函数名称，而不是 C++ 的规则。这样做的目的是为了保持与已经存在的 C 代码库的兼容性，特别是当使用 C++ 编写新代码时。\n__cplusplus宏定义作用 在 C++ 中，__cplusplus 是一个预定义的宏，它用于确定正在使用的 C++ 标准的版本。这个宏的存在使得 C++ 代码能够以标准 C 形式输出，即以 C 的形式被调用，这对于跨平台编程和与 C 语言的兼容性至关重要。\n宏的定义和使用 __cplusplus 宏通常在编写涉及 C 和 C++ 混合编程的头文件时使用。当 C++ 代码需要被 C 编译器调用时，使用这个宏可以确保 C++ 中的名称修饰（name mangling）不会发生，从而允许 C 代码安全地调用 C++ 函数。例如：\n1 2 3 4 5 6 7 8 9 #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif // C++ 函数声明 #ifdef __cplusplus } #endif ![[Pasted image 20241213212614.png]]\n在这个例子中，如果编译器是 C++ 编译器，__cplusplus 宏会被定义，extern \u0026ldquo;C\u0026rdquo; 块将会被包含，这告诉编译器按照 C 语言的规则来处理函数名称，而不是 C++ 的规则。这样做的目的是为了保持与已经存在的 C 代码库的兼容性，特别是当使用 C++ 编写新代码时。\n宏的值 __cplusplus 宏的值表示 C++ 标准的版本，例如：\nC++98 标准：199711L C++11 标准：201103L C++14 标准：201402L C++17 标准：201703L C++20 标准：202002L 不同的编译器，如 GCC、Clang 或 Visual C++，都遵循这些标准，并在编译时定义相应的 __cplusplus 值。这个宏的值可以用来确定编译器支持的 C++ 版本，从而在编写代码时做出相应的兼容性处理。 实际应用 在实际应用中，__cplusplus 宏确保了 C++ 代码可以与 C 代码无缝集成。例如，如果有一个用 C 语言编写的库，它的头文件是 f.h，产生的库文件是 f.lib，那么在 C++ 中使用这个库文件时，需要这样写：\n1 2 3 extern \u0026#34;C\u0026#34; { #include \u0026#34;f.h\u0026#34; } 这样，C++ 编译器就会知道如何正确地链接和调用 C 语言编写的函数。如果没有使用 __cplusplus 宏，可能会出现链接错误，因为 C++ 编译器和 C 编译器对函数名称的处理方式不同。\n总结来说，__cplusplus 宏是 C++ 语言为了兼容 C 语言和支持混合编程而提供的一个重要工具。它允许开发者在保持 C++ 功能的同时，确保代码能够在不同的编程环境中正确运行。\n关于extern关键字 C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客 ![[Pasted image 20241213212619.png]]\n","date":"2025-06-24T22:30:22+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","title":"C\u0026C++ 编译过程"},{"content":"STM32 hal库串口空闲中断最新用法 - STM32团队 ST意法半导体中文论坛\n（非常详细）【STM32】 DMA原理，步骤超细详解，一文看懂DMA-CSDN博客\nSTM32CubeIDE HAL库DMA与UART不定长数据接收实现：空闲中断详解-物联沃-IOTWORD物联网\nSTM32 hal库串口空闲中断最新用法_stm32hal库串口空闲中断-CSDN博客\nHAL库 串口空闲中断+DMA接收不定长数据 详解及踩坑_hal库串口空闲中断-CSDN博客\n（写的非常好，非常有助于提升底层理解）（stm32之HAL库）UART工作在DMA模式要打开串口中断吗？_hal uart dma-CSDN博客\nDMA DMA，全称为Direct Memory Access，直接内存访问，本质是将传输数据从一个内存空间搬运至另一个内存空间，可以用来提供外设和内存，内存和外设之间的高速数据传输\n在HAL库中直接使用的HAL_UART_Transmit_DMA，HAL_UART_Receive_DMA，HAL_UARTEx_ReceiveToIdle_DMA等都有中断的参与，需要在Cube中开启中断\n对具体底层原理和DMA模式实现底层与中断模式底层实现区别感兴趣可参考以下博客 （stm32之HAL库）UART工作在DMA模式要打开串口中断吗？_hal uart dma-CSDN博客\nUSART发送 在普通的轮询USART中，CPU一直在等待外设发送数据，外设每发送一帧数据，CPU就从内存中移动一帧数据到外设的寄存器\n在中断的USART中，外设每从寄存器中发送一帧数据，就会触发一次发送数据寄存器空中断，使CPU回来将一帧数据从内存搬运至外设的寄存器中\nUSART的DMA发送 没有DMA的话，CPU会作为数据发送的中转站，而使用DMA的话，整个数据传输过程不需要CPU的参与，由DMA代理执行，DMA负责将内存数据搬运至外设的传输寄存器\n在整个数据发送过半时会触发一个传输过半中断，所有数据传输完成后会调用传输完成中断回调函数（HAL_UART_TxCpltCallback）\n1 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) HAL_UART_Transmit_DMA的传输完成中断回调函数HAL_UART_TxCpltCallback以及传输过半中断回调函数HAL_UART_TxHalfCpltCallback（这两个回调函数在HAL_UART_Transmit_IT中同样有）\nDMA发送注意事项 在传输的过程中，当传输一半的数据后，半传输标志(HTIF)被置1，当设置了允许半传输中断位(HTIE)时，将产生一个中断请求。在数据传输结束后，传输完成标志(TCIF)被置1，当设置了允许传输完成中断位 (TCIE)时，将产生一个中断请求\n会触发的三个中断，传输完成中断，传输过半中断，错误中断 在stm32f1xx_hal_uart.c的HAL_UART_Transmit_DMA函数中可以查看到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) { . . . /* Set the UART DMA transfer complete callback */ huart-\u0026gt;hdmatx-\u0026gt;XferCpltCallback = UART_DMATransmitCplt; /* Set the UART DMA Half transfer complete callback */ huart-\u0026gt;hdmatx-\u0026gt;XferHalfCpltCallback = UART_DMATxHalfCplt; /* Set the DMA error callback */ huart-\u0026gt;hdmatx-\u0026gt;XferErrorCallback = UART_DMAError; . . . } } USART接收 在普通的轮询USART中，CPU一直在询问外设是否接收完数据，外设接收一帧数据，该位数据由CPU从外设的数据接收寄存器运进内存，CPU再次询问外设是否接收完数据，再运，直至整个数据接收完成\n而在中断USART中，外设每接收一帧数据，触发一次数据接收寄存器非空中断，CPU过来将数据从寄存器搬运至内存，所有数据接收完成后，会调用接收完成中断回调函数（HAL_UART_RxCpltCallback）\nUSART的DMA接收 没有DMA的话，CPU会作为数据转运的中转站，而使用DMA的话，整个数据转运过程不需要CPU的参与，由DMA代理执行\n在整个数据接收过半时会触发一个传输过半中断，所有数据接收完成后会调用传输完成中断回调函数（HAL_UART_RxCpltCallback）\n1 HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) HAL_UART_Receive_DMA的接收完成中断回调函数HAL_UART_RxCpltCallback以及接收过半中断回调函数HAL_UART_RxHalfCpltCallback（这两个回调函数在HAL_UART_Receive_IT中同样有）\nDMA接收注意事项 同DMA发送，类比即可\nHAL库USART使用DMA 如果USART串口的DMA出现错误，会调用HAL_UART_ErrorCallback\nDMA发送 1 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) 会触发中断，对应回调函数为\nHAL_UART_TxCpltCallback HAL_UART_TxHalfCpltCallback DMA接收 1 HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) 会触发的中断，对应的回调函数为\nHAL_UART_RxCpltCallback HAL_UART_RxHalfCpltCallback DMA模式 normal模式 以接收为例 单次接收，接收至数据上限，完成整个固定数据接收后停止，再次接收需要再次开启HAL_UART_Receive_DMA ，需要软件显式重启，触发接收过半和接收完成中断\nsummary：单次传输，完成后停止，需要软件显式重启，接收过半和接收完成中断\ncircular模式 以接收为例 无限循环，接收至数据上限一半，触发接收过半中断，接受至数据上限，触发接收完成中断，同时会硬件自动重启，接收完成中断会调用对应的接收完成中断回调函数\nsummary：无限循环，硬件自动重启，接收过半和接收完成中断\n空闲中断 空闲中断定义 空闲中断（IDLE Interrupt） 是UART通信中的一种特殊中断类型，它在检测到UART接收线路连续空闲超过1个字节传输时间时触发的中断。\u0026ldquo;空闲\u0026quot;指线路保持逻辑1状态（高电平），线上无数据传输\nHAL库自带的空闲中断实现 使用的是HAL库提供的拓展函数，同时都需要在Cube中开启中断\n1 2 //在阻塞模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen, uint32_t Timeout); 1 2 //在中断模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 1 2 //在DMA模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 1 2 //使用空闲中断时的接收回调函数 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size); 在触发空闲中断，接收完成中断都会调用HAL_UARTEx_RxEventCallback回调函数，需要注意的是在F103c8t6单片机以及其他st系列单片机上，使用HAL_UARTEx_ReceiveToIdle_DMA时，接收过半中断也会去调用该回调函数\n接收过半中断的处理 STM32CubeIDE HAL库DMA与UART不定长数据接收实现：空闲中断详解-物联沃-IOTWORD物联网 HAL_UARTEx_RecceiveToIdle_DMA会调用UART_Start_Receive_DMA(huart, pData, Size)函数，该函数会把DMA中断传输完成，半传输，传输错误全部开启\n1 __HAL_DMA_ENABLE_IT(DMA_IT_TC | DMA_IT_HC | DMA_IT_TE) UART_Start_Receive_DMA(huart, pData, Size) 设置接收数组缓存到达数组一半时会执行下面的回调函数\n1 2 /* Set the UART DMA Half transfer complete callback */ huart-\u0026gt;hdmarx-\u0026gt;XferHalfCpltCallback = UART_DMARxHalfCplt; 在DMA的中断处理函数中，会调用huart-\u0026gt;hdmarx-\u0026gt;XferHalfCpltCallback，此处即UART_DMARxHalfCplt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma) { uint32_t flag_it = hdma-\u0026gt;DmaBaseAddress-\u0026gt;ISR; uint32_t source_it = hdma-\u0026gt;Instance-\u0026gt;CCR; /* Half Transfer Complete Interrupt management ******************************/ if (((flag_it \u0026amp; (DMA_FLAG_HT1 \u0026lt;\u0026lt; hdma-\u0026gt;ChannelIndex)) != RESET) \u0026amp;\u0026amp; ((source_it \u0026amp; DMA_IT_HT) != RESET)) { ...... if(hdma-\u0026gt;XferHalfCpltCallback != NULL) { /* Half transfer callback */ hdma-\u0026gt;XferHalfCpltCallback(hdma); } ...... } ...... } 而UART_DMARxHalfCplt会调用HAL_UARTEx_RxEventCallback\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma) { UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)-\u0026gt;Parent; /* Initialize type of RxEvent that correspond to RxEvent callback execution; In this case, Rx Event type is Half Transfer */ huart-\u0026gt;RxEventType = HAL_UART_RXEVENT_HT; /* Check current reception Mode : If Reception till IDLE event has been selected : use Rx Event callback */ if (huart-\u0026gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE) { #if (USE_HAL_UART_REGISTER_CALLBACKS == 1) /*Call registered Rx Event callback*/ huart-\u0026gt;RxEventCallback(huart, huart-\u0026gt;RxXferSize / 2U); #else /*Call legacy weak Rx Event callback*/ HAL_UARTEx_RxEventCallback(huart, huart-\u0026gt;RxXferSize / 2U); #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ } else { /* In other cases : use Rx Half Complete callback */ #if (USE_HAL_UART_REGISTER_CALLBACKS == 1) /*Call registered Rx Half complete callback*/ huart-\u0026gt;RxHalfCpltCallback(huart); #else /*Call legacy weak Rx Half complete callback*/ HAL_UART_RxHalfCpltCallback(huart); #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ } } 为了避免接收过半中断的调用，需要使用下面的语句\n1 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx,DMA_IT_HT);//关闭dma接收半满中断函数，这样我们在接收一组数据时就不会触发半满中断，dma就可以正常接收一组数据 另外在UART_DMAReceiveCplt函数中也调用了HAL_UARTEx_RxEventCallback函数\n1 static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma) DMA+空闲中断的实现接收不定长数据 方式1 自定义DMA+空闲中断\n前置内容 需要自己写的宏定义\n1 2 #define __HAL_DMA_SET_COUNTERT(__HANDLE__,__COUNTER__) ((__HANDLE__)-\u0026gt;Instance-\u0026gt;CNDTR = (uint16_t)(__COUNTER__)) //重新设定计数值 1 2 //用法 __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); 用到的宏定义\n1 2 __HAL_DMA_GET_COUNTER(huart-\u0026gt;hdmarx) //获取剩余未传输的计数值 用到的关于中断的操作\n1 2 3 4 5 6 7 8 9 10 __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx)//关闭DMA __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx)//开启DMA //清除空闲标志位 __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1) //开启空闲中断 __HAL_UART_ENABLE_IT(\u0026amp;huart1 , UART_IT_IDLE ) //关闭空闲中断 __HAL_UART_DISABLE_IT(\u0026amp;huart1, UART_IT_IDLE ) 代码实现 1 2 3 #define rxBufferLen 10 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; 1 2 3 4 5 void UART_InitDMAReceive() { __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1);//清除空闲中断标志位 __HAL_UART_ENABLE_IT(\u0026amp;huart1 , UART_IT_IDLE );//使能空闲中断 HAL_UART_Receive_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//开启DMA接收 } 需要关闭DMA才能重设DMA的COUNTER\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //自定义的DMA空闲中断回调函数 void UART_DMAIdleCallback(UART_HandleTypeDef *huart) { if (huart == \u0026amp;huart1 ) { __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//失能DMA int datalen = rxBufferLen - __HAL_DMA_GET_COUNTER(huart-\u0026gt;hdmarx); for(int i=0;i\u0026lt;datalen;i++) { char temp = rxBuffer[i]; txBuffer[i] = (temp \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; temp \u0026lt;= \u0026#39;z\u0026#39;) ? temp-32:temp; } HAL_UART_Transmit_DMA(\u0026amp;huart1,(uint8_t*)txBuffer,datalen); __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen);//重置DMA计数 __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//使能DMA } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void USART1_IRQHandler(void) { /* USER CODE BEGIN USART1_IRQn 0 */ /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(\u0026amp;huart1); /* USER CODE BEGIN USART1_IRQn 1 */ //触发空闲中断后，会进入中断请求处理函数 if (__HAL_UART_GET_FLAG(\u0026amp;huart1 , UART_FLAG_IDLE) != RESET ) {//在此判断是否为空闲中断 __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1);//清除空闲中断标志位 __HAL_UART_DISABLE_IT(\u0026amp;huart1, UART_IT_IDLE);//失能空闲中断 UART_DMAIdleCallback(\u0026amp;huart1);//调用自定义中断回调函数 __HAL_UART_ENABLE_IT(\u0026amp;huart1, UART_IT_IDLE);//使能空闲中断 } /* USER CODE END USART1_IRQn 1 */ } 关于normal和circular在方式1的空闲中断实现的区别 normal模式 在上述空闲中断实现中，如果使用normal模式，需要注意接收的数据一定不能超过rxBufferLen，一旦超过，DMA接收就会终止\n执行流程是，触发空闲中断，进入USART1_IRQHandler，再进入自定义空闲中断，在里面重新设置了DMA的计数值（指针也会重新设置，重新指向rxBuffer[0]），最开始开启的HAL_UART_Receive_DMA始终没有接收完 完整的数据，就不会关闭，一直接收\n但如果接收的数据超过rxBufferLen，会触发接收过半和接收完成中断（对应回调函数没使用，约等于空函数），同时HAL_UART_Receive_DMA会结束，需要软件显式重启\n例如：rxBufferlen=10，发送12345678910，会回复1234567891，随后DMA终止，再发送数据无回复\ncircular模式 在上述空闲中断实现中，如果使用circular模式，则接收的数据可以超过rxBufferLen，超过后，DMA接收会自动重启\n执行流程是，触发空闲中断，进入USART1_IRQHandler，再进入自定义空闲中断，在里面重新设置了DMA的计数值（指针也会重新设置，重新指向rxBuffer[0]），就算接收数据超过rxBufferLen，HAL_UART_Receive_DMA也会重新启动\n但是需要注意，如果达到rxBufferLen,会触发接收过半和接收完成中断，然后硬件重启，重新回到rxBufferLen[0]的位置读数据，直至发生空闲中断\n例如：rxBufferlen=10，发送12345678910，会回复0，随后DMA仍然正常工作\n方式2 使用HAL库提供的拓展空闲中断，使用normal模式\n该方式下的空闲中断回调函数为HAL_UARTEx_RxEventCallback ，需要注意接收过半中断也会调用HAL_UARTEx_RxEventCallback的问题，在每次开启HAL_UARTEx_ReceiveToIdle_DMA后都需要关闭接收过半中断\n1 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx,DMA_IT_HT);//关闭dma接收半满中断函数，这样我们在接收一组数据时就不会触发半满中断，dma就可以正常接收一组数据 注意需要添加\n1 2 3 extern UART_HandleTypeDef huart1; extern DMA_HandleTypeDef hdma_usart1_rx; extern DMA_HandleTypeDef hdma_usart1_tx; 当接收数据超过rxBufferLen时，接收完成中断函数会调用HAL_UARTEx_RxEventCallback回调函数，然后重新开启接收\n例如：rxBufferLen=10，接收12345678910，发送1234567891（就是因为接收完成中断导致），后面DMA空闲中断接收正常开启\n代码实现 1 2 3 4 5 6 7 extern UART_HandleTypeDef huart1; extern DMA_HandleTypeDef hdma_usart1_rx; extern DMA_HandleTypeDef hdma_usart1_tx; #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; 1 2 3 4 void Init_IdleDMA(void) {//初始化，开启DMA空闲中断接收 HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } 1 2 3 4 5 6 7 8 9 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//normal模式，接受一次后需要重新开启 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } //Init_IdldeDMA(); } 关于normal和circular在方式2下的空闲中断实现的区别 normal模式 方式2中，在数据接收过半，接收完成，空闲时会触发对应中断，最后调用HAL_UARTEx_RxEventCallback回调函数，在回调函数中软件显式重启HAL_UARTEx_ReceiveToIdle_DMA\ncircular模式 方式2中，若使用circular模式，则数据会一直积累，到达rxBufferLen时，会硬件重启，同时也会有数据接收过半，接收完成，空闲时会触发对应中断，最后调用HAL_UARTEx_RxEventCallback回调函数\n例如： (1)关闭接收过半中断 rxBufferLen=10，接收123，发送123， 再接收456，发送123456， 再接收78910，会先发送1234567891（接收完成），再发送0（空闲中断）， 再接收111213，发送0111213\n(2)未关闭接收过半中断 rxBufferLen=10，接收123，发送123， 再接收123，会先发送12312（接收过半中断），再发送123123空闲中断， 再接收12345，会先发送1231231234（接收完成中断），再发送5空闲中断\n方式3 使用HAL库提供的空闲中断，但是使用circular模式实现\n在circuar要想实现一帧一帧不定长数据的接收主要需要考虑的就是如何实现在接收完一帧后让DMA的计数值重置\n实现原理 关闭 要实现DMA计数值的重置，需要使用HAL_UART_DMAStop(\u0026amp;huart1)函数将DMA关闭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart) { uint32_t dmarequest = 0x00U; /* The Lock is not implemented on this API to allow the user application to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback(): when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() */ /* Stop UART DMA Tx request if ongoing */ dmarequest = HAL_IS_BIT_SET(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAT); if ((huart-\u0026gt;gState == HAL_UART_STATE_BUSY_TX) \u0026amp;\u0026amp; dmarequest) { ATOMIC_CLEAR_BIT(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAT); /* Abort the UART DMA Tx channel */ if (huart-\u0026gt;hdmatx != NULL) { HAL_DMA_Abort(huart-\u0026gt;hdmatx); } UART_EndTxTransfer(huart); } /* Stop UART DMA Rx request if ongoing */ dmarequest = HAL_IS_BIT_SET(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAR); if ((huart-\u0026gt;RxState == HAL_UART_STATE_BUSY_RX) \u0026amp;\u0026amp; dmarequest) { ATOMIC_CLEAR_BIT(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAR); /* Abort the UART DMA Rx channel */ if (huart-\u0026gt;hdmarx != NULL) { HAL_DMA_Abort(huart-\u0026gt;hdmarx); } UART_EndRxTransfer(huart); } return HAL_OK; } 其中会调用HAL_DMA_Abort(huart-\u0026gt;hdmatx)，但都不会重置DMA的计数值\n开启 在关闭DMA后，需要HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen)重新开启DMA以及空闲中断\n在HAL_UARTEx_ReceiveToIdle_DMA中，会进行判断if (huart-\u0026gt;RxState == HAL_UART_STATE_READY) ，判断RxState是否为HAL_UART_STATE_READY，如果是，则说明uart没有开启，但是是在预备状态，随后会去调用UART_Start_Receive_DMA(huart, pData, Size)开启uart以及DMA\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { HAL_StatusTypeDef status; /* Check that a Rx process is not already ongoing */ if (huart-\u0026gt;RxState == HAL_UART_STATE_READY) { if ((pData == NULL) || (Size == 0U)) { return HAL_ERROR; } /* Set Reception type to reception till IDLE Event*/ huart-\u0026gt;ReceptionType = HAL_UART_RECEPTION_TOIDLE; huart-\u0026gt;RxEventType = HAL_UART_RXEVENT_TC; status = UART_Start_Receive_DMA(huart, pData, Size); /* Check Rx process has been successfully started */ if (huart-\u0026gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE) { __HAL_UART_CLEAR_IDLEFLAG(huart); ATOMIC_SET_BIT(huart-\u0026gt;Instance-\u0026gt;CR1, USART_CR1_IDLEIE); } else { /* In case of errors already pending when reception is started, Interrupts may have already been raised and lead to reception abortion. (Overrun error for instance). In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */ status = HAL_ERROR; } return status; } else { return HAL_BUSY; } } 在UART_Start_Receive_DMA中会将uart的RxState设置为HAL_UART_STATE_BUSY_RX，中间还会去调用HAL_DMA_Start_IT\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { uint32_t *tmp; huart-\u0026gt;pRxBuffPtr = pData; huart-\u0026gt;RxXferSize = Size; huart-\u0026gt;ErrorCode = HAL_UART_ERROR_NONE; huart-\u0026gt;RxState = HAL_UART_STATE_BUSY_RX; ...... HAL_DMA_Start_IT(huart-\u0026gt;hdmarx, (uint32_t)\u0026amp;huart-\u0026gt;Instance-\u0026gt;DR, *(uint32_t *)tmp, Size); ...... } 在HAL_DMA_Start_IT会调用DMA_SetConfig去对DMA计数值等进行重置\n1 2 3 4 5 6 7 HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength) { ...... /* Configure the source, destination address and the data length \u0026amp; clear flags*/ DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength); ...... } 原理总结 1.HAL_UARTEx_ReceiveToIdle_DMA如果判断出huart-\u0026gt;RxState == HAL_UART_STATE_READY会调用UART_Start_Receive_DMA\n2.UART_Start_Receive_DMA会调用HAL_DMA_Start_IT，同时会将RxState修改为BUSY huart-\u0026gt;RxState = HAL_UART_STATE_BUSY_RX\n3.HAL_DMA_Start_IT会调用DMA_SetConfig进行DMA计数值等的重置\n而使用HAL_UART_DMAStop可以保证在回调函数处理数据时停止DMA接收，保证数据不会被覆盖，同时可以将huart-\u0026gt;RxState状态设置为HAL_UART_STATE_READY，随后再次开启DMA空闲中断接收就能重置DMA计数值\n从而实现非定长数据的接收\n代码实现 同样注意，需要关闭接收过半中断\n1 2 3 4 5 6 7 8 extern UART_HandleTypeDef huart1; extern DMA_HandleTypeDef hdma_usart1_rx; extern DMA_HandleTypeDef hdma_usart1_tx; #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; 1 2 3 4 5 //初始化 void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } 1 2 3 4 5 6 7 8 9 10 11 12 //回调函数 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { HAL_UART_DMAStop(\u0026amp;huart1);//不会改变DMA的计数值 memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); memset(txBuffer, 0, Size); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//如果是normal模式，接受一次后需要重新开启，如果关闭了DMA，也需要重新启动 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } } 实验检验 我们设置cnt_i去记录AL_UART_DMAStop(\u0026amp;huart1)前后以及HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen)前后的DMA计数值变化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { uint32_t cnt_1 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); HAL_UART_DMAStop(\u0026amp;huart1);//不会改变DMA的计数值 uint32_t cnt_2 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); memset(txBuffer, 0, Size); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//如果是normal模式，接受一次后需要重新开启，如果关闭了DMA，也需要重新启动 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 uint32_t cnt_3 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); sprintf(txBuffer, \u0026#34;\\ncnt_1=%d cnt_2=%d cnt_3=%d\\n\u0026#34;, cnt_1,cnt_2,cnt_3); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, sizeof(txBuffer), 10); } } 实验结果\n1 2 3 4 输入：123456789101112131415161718192021 输出：123456789101112131415161718192021 cnt_1=479 cnt_2=479 cnt_3=512 证明我们在重启DMA空闲中断时实现了DMA计数值重置\n方式4 再仔细想一想，在circuar要想实现一帧一帧不定长数据的接收主要需要考虑的就是如何实现在接收完一帧后让DMA的计数值重置，也就是说没有必要为此使用HAL_UART_DMAStop再重启DMA空闲中断接收\n如何优化呢，结合方式1的实现就可以得到答案\n1 2 3 __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #define __HAL_DMA_SET_COUNTERT(__HANDLE__,__COUNTER__) ((__HANDLE__)-\u0026gt;Instance-\u0026gt;CNDTR = (uint16_t)(__COUNTER__)) //重新设定计数值 extern UART_HandleTypeDef huart1; extern DMA_HandleTypeDef hdma_usart1_rx; extern DMA_HandleTypeDef hdma_usart1_tx; #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) { if (huart == \u0026amp;huart1 ) { __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER } } ","date":"2025-06-18T19:52:33+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32dma%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD/","title":"STM32——DMA使用与空闲中断"},{"content":"基于菜鸟教程写的个人笔记\nstatic定义 static是C/C++中常用的修饰符，控制变量的存储方式和可见性\nstatic-前置-空间分配 在函数内部定义的变量，当程序执行到其定义处时没编译器会为它在栈上分配空间，函数在栈上分配的空间再次函数结束时会释放掉\n如果想将函数中此变量的值保存至下一次调用：\n（1）将该变量定义为全局变量，但带来许多缺点，例如破坏了此变量的访问范围（在此函数中定义的变量，不仅仅只受此函数的控制）\n（2）使用static关键词修饰\n静态数据的存储 全局（静态）存储区：分为 DATA 段和 BSS 段 DATA 段（全局初始化区）存放初始化的全局变量和静态变量 BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量 程序运行结束时自动释放 BSS段在程序执行前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。\n在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。\n在C/C++中static的作用 General （1）在修饰变量时，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放 （2）static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能被其他文件调用，即使是extern外部声明也不可以 （3）static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0 （4）static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用 （5）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰 （6）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）\n关于静态变量与普通变量 静态全局变量 （1）静态变量都在全局数据区分配内存 （2）未经初始化的静态全局变量会被程序自动初始化为0 （3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的\n（1）全局变量和全局静态变量的区别\n1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。 2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。 静态局部变量 （1）该变量在全局数据区分配内存 （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，及以后的函数调用不会再进行初始化 （3）静态局部变量一般在声明处初始化，如果没有显示初始化，会被程序自动初始化为0 （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束\n一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。\nstatic用法 在C++中 static在类中的作用： 被 static 修饰的变量、被 static 修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变\n在 C++ 中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存\n静态成员的定义或声明要加个关键 static。静态成员可以通过双冒号来使用 即 \u0026lt;类名\u0026gt;::\u0026lt;静态成员名\u0026gt;\n结论：\n不能通过类名来调用类的非静态成员函数，可以通过类的对象调用静态成员函数和非静态成员函数 类的静态成员函数不可以使用类的非静态函数 在类的非静态成员函数中可以使用类的静态成员（函数，变量），非静态成员函数在调用静态成员变量时，静态成员变量必须在使用前初始化 因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员函数必须在类实例化对象后才有内存空间\n类的静态成员变量必须先初始化再使用 一些解释： 1）静态方法能不能引用非静态资源？不能，实例化对象的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。 2）静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。 3）非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是实例化对象之后才产生的，那么属于类的内容它都认识\nSummary:\n（1）静态成员函数中不能调用非静态成员 （2）非静态成员函数中可以调用静态成员。因为静态成员属于类本身，在类的对象产生之前就已经存在了，所以在非静态成员函数中是可以调用静态成员的 （3）静态成员变量使用前必须先初始化(如 int MyClass::m_nNumber = 0;)，否则会在 linker 时出错 静态数据成员 （1）静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变 （2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间 （3）静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0 （4）静态数据成员既可以通过对象名引用，也可以通过类名引用 静态成员函数 （1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员 （2）非静态成员函数有 this 指针，而静态成员函数没有 this 指针 （3）静态成员函数主要用来f访问静态数据成员而不能访问非静态成员 ","date":"2025-01-13T16:24:31+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-statiic/","title":"C\u0026C++ Statiic"},{"content":"【关于C和C++混合编程中编译和链接的问题】https://www.bilibili.com/video/BV1Zm4y1E7nm?vd_source=5a0790755035f26a67935abfbfcdfd5b extern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园 C++\u0026ndash;名字修饰_c++的函数名修饰是在哪个阶段进行的-CSDN博客 C/C++ 函数签名与名字修饰（符号修饰）-CSDN博客 C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n符号修饰 在C/C++中，一个程序要运行起来，需要经历以下几个阶段：预处理、编译、汇编、链接。\n名字修饰（Name Mangling）是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过一定算法，重新修饰为一个全局唯一的名称。\n由于C++和C的名字修饰规则不同（不同操作系统下的编译器的名字修饰方式也会不同），导致C++可以支持函数重载，而C不支持函数重载\n可以简单理解，c++中支持函数重载，c语言不支持函数重载，这造成了c++和c语言的函数名解析不同（名字修饰/符号修饰）。c语言函数名就是函数名，c++的函数名是函数名+参数组合起来的。\nC与C++符号修饰的实例 extern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园 （直接copy自该博客）\n比如，函数void func(double a) 在C和C++中的编译阶段函数名称会被解析成什么呢？\n在C语言中，由于没有名称修饰，所以在编译时函数名称仍然是func，不会因为参数类型或数量而改变。\n在C++中，由于名称修饰的存在，函数名称在编译阶段会被编译器转换成一个包含函数原型信息的唯一标识符。通常会涉及函数返回类型、参数类型以及参数数量。以GCC(GNU Compiler Collection)为例，func(double a)会被转换成_Z4funcd ，这里：\n_Z：是GCC用来表示修饰名称的前缀 4：表示函数名称func的的字符数 d：是double类型的编码 因此，用c++的方式去寻找c语言的符号是无法寻找到的。extern \u0026quot;C\u0026quot;为何可以做到？\nextern \u0026quot;C\u0026quot;的作用就是修改了符号表的生成方式，将c++符号的生成方式换成了c的生成方式。\n即c库中生成的符号是c编译器的符号， 因此c语言可以直接链接。而c++程序需要使用extern \u0026quot;C\u0026quot;让编译器使用c的符号命名方式去进行链接，这样才能找到对应的符号。\nextern \u0026ldquo;C\u0026rdquo; C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n看这一篇就够了 看实例\ncpp调用c，cpp编译时会有C++的符号修饰，导致链接C库的函数找不到，需要用extern \u0026ldquo;C\u0026quot;告诉g++编译器以C语言的风格进行编译 c调用cpp（不涉及C++的类和成员函数），设计一个C的接口，接口的实现在cpp中，接口函数内部去使用C++的特性 c中调用c++成员函数，需要一个接口函数 arm-none-eabi的符号修饰 在嵌入式开发中，arm-none-eabi 工具链（针对 ARM 架构的裸机 / 嵌入式交叉编译工具）的符号修饰（Name Mangling） 主要由编译器（通常是 GCC）根据语言特性（C/C++）和目标 ABI（应用程序二进制接口）决定，目的是生成唯一的符号名，以支持函数重载、命名空间、类型信息等特性。\n1. C 语言的符号修饰 C 语言不支持函数重载和命名空间，因此符号修饰非常简单，通常仅在函数名前添加下划线（_），或直接使用原函数名，具体取决于目标 ABI（如 ARM 的 APCS、EABI 等）。\n示例：\nC 函数 void foo(int a) 经过 arm-none-eabi-gcc 编译后，符号通常为 foo 这也是为什么在汇编中调用 C 函数时，通常需要引用带下划线的符号 2. C++ 的符号修饰（命名粉碎） C++ 支持函数重载、类、命名空间、模板等特性，因此需要更复杂的符号修饰规则（称为 “命名粉碎”），以确保每个重载函数 / 方法生成唯一的符号。arm-none-eabi-g++ 遵循 GCC 的 C++ 符号修饰规则，基本格式为：\n_Z[命名空间/类前缀][函数名长度][函数名][参数类型编码]\n关键规则解析： _Z：固定前缀，标识 C++ 符号。 命名空间 / 类：若函数属于命名空间或类，会在前缀中编码（如 N 表示命名空间开始，E 表示结束）。 函数名长度：紧跟在命名空间 / 类之后，用数字表示函数名的字符数。 参数类型编码：用简写字母表示参数类型（如 i=int，f=float，p= 指针，v=void 等）。 示例： 全局函数 void foo(int)\n修饰后符号：_Z3fooi\n解析：_Z（C++ 符号） + 3（foo 长度为 3） + foo（函数名） + i（参数 int）。 重载函数 void foo(float)\n修饰后符号：_Z3foof（参数 f 表示 float，与上例区分）。 类成员函数 class A { void bar(double); }\n修饰后符号：_ZN1A3barEd\n解析：_Z + N（类 / 命名空间开始） + 1A（类名 A 长度为 1） + 3bar（函数名 bar 长度为 3） + E（类结束） + d（参数 double）。 命名空间内函数 namespace ns { int add(int, int); }\n修饰后符号：_ZN2ns3addii\n解析：_Z + N（命名空间开始） + 2ns（命名空间 ns 长度为 2） + 3add（函数名 add 长度为 3） + E（命名空间结束） + ii（两个 int 参数）。 3. C 和 C++ 混合编程的符号兼容 当 C++ 代码调用 C 函数（或反之）时，需使用 extern \u0026quot;C\u0026quot; 声明，以禁用 C++ 的符号修饰，确保链接时匹配 C 风格的符号。\n示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // C头文件（需兼容C++） #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif void c_function(int a); // C函数，符号为 _c_function #ifdef __cplusplus } #endif // C++代码中调用 void cpp_func() { c_function(10); // 正确引用C符号 _c_function } ``` ","date":"2025-01-13T16:17:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E7%9A%84%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0/","title":"C++ 的名字修饰（符号修饰）"},{"content":"作用 如果一个变量被const修饰，那么它的值就不能再被改变\nconst的优点 （1）可以保护被修饰的东西，防止意外修改，增强程序的健壮性\n（2）编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高\nconst修饰局部变量 1 2 const int n=5; int const n=5; 这两种写法是一样的，都是表示变量n的值不能被改变了，需要注意的是，用const修饰变量时，一定要给变脸初始化，否则之后就不能再进行赋值\nconst 修饰指针 1.常量指针 常量指针是指针指向的内容是常量，可以有一下两种定义方式\n1 2 const int * n; int const * n; 注意： （1）常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的\n（2）常量指针指向的值不能改变，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址\n2.指针常量 指针常量是指指针本身是个常量，不能再指向其他的地址\n1 int *const n; 需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改\n3.指向常量的常指针 指向常量的常指针是以上两种的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值\n1 const int* const p; const修饰函数的参数 1.防止修改指针指向的内容\n1 void StringCopy(char *strDestination, const char *strSource); 其中 strSource 是输入参数，strDestination 是输出参数 给 strSource 加上 const 修饰后，如果函数体内的语句试图改动 strSource 的内容，编译器将指出错误\n2.防止修改指针指向的地址\n1 void swap ( int * const p1 , int * const p2 ) 指针p1和指针p2指向的地址都不能修改\n","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-const/","title":"C\u0026C++ const"},{"content":"基于菜鸟教程写的个人笔记\n存储类 存储类定义了C程序中变量/函数的存储位置，生命周期，作用域\nauto register static extern 1.auto存储类 auto存储类是所有局部变量默认的存储类 定义在函数中的变量都默认为auto存储类 它们在函数开始时被创建，在函数结束时被销毁\n1 2 3 4 { int month ; auto int month ; } auto只能修饰局部变量\n2.register存储类 register存储类用于定义存储在寄存器上，而不是RAM中的局部变量 register存储类定义存储在寄存器，变量访问速度更快，不能直接地取地址（因为它存储在RAM中）\n1 2 3 { register int miles ； } 寄存器一般用于需要快速访问的变量\n3.static存储类 （1）static作用于局部变量 a.使局部变量在程序生命周期内都存在，不需要每次进入和离开其作用域（函数）的时候创建（重新分配内存）和销毁。 b.使用static修饰局部变量可以在函数调用之间保持局部变量的值\nstatic作用的变量，静态局部变量存储在静态（全局）存储区\n（2）static作用于全局变量 当static修饰全局变量时，会使变量的作用域限制在声明它的文件内\n（3）静态变量的特性 静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; /* 函数声明 */ void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main() { while (count--) { func1(); } return 0; } void func1(void) { /* \u0026#39;thingy\u0026#39; 是 \u0026#39;func1\u0026#39; 的局部变量 - 只初始化一次 * 每次调用函数 \u0026#39;func1\u0026#39; \u0026#39;thingy\u0026#39; 值不会被重置。 */ static int thingy=5; thingy++; printf(\u0026#34; thingy 为 %d ， count 为 %d\\n\u0026#34;, thingy, count); } 实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置\n当上面的代码被编译和执行时，它会产生下列结果：\n1 2 3 4 5 6 7 8 9 10 thingy 为 6 ， count 为 9 thingy 为 7 ， count 为 8 thingy 为 8 ， count 为 7 thingy 为 9 ， count 为 6 thingy 为 10 ， count 为 5 thingy 为 11 ， count 为 4 thingy 为 12 ， count 为 3 thingy 为 13 ， count 为 2 thingy 为 14 ， count 为 1 thingy 为 15 ， count 为 0 4.extern存储类 extern存储类用于定义在其他文件中声明的全局变量或函数 当使用extern关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义\nextern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n第一个文件 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; extern int count; void write_extern(void) { printf(\u0026#34;count is %d\\n\u0026#34;, count); } 结果 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：\n1 $ gcc main.c support.c 这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：\n1 count is 5 ","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/c%E5%AD%98%E5%82%A8%E7%B1%BB/","title":"C存储类"}]