[{"content":"【台大机器人学之运动学——林沛群（含课件+书籍）】https://www.bilibili.com/video/BV1v4411H7ez?vd_source=5a0790755035f26a67935abfbfcdfd5b\n第一章 Rotation Matrix旋转矩阵 旋转矩阵 Rotation Matrix旋转矩阵的三个作用 ![](Pasted image 20241105142701.png)\n旋转作用 ![[Pasted image 20241105143357.png]]\n旋转矩阵与转角 ![[Pasted image 20241105143756.png]]\n拆解成【三次旋转连乘】需要注意 1.多次旋转需要明确先后顺序 2.旋转转轴也需要明确定义，是对【固定不动】的旋转轴旋转，还是对【旋转的frame当下所在】的旋转轴旋转\n两个拆解方式 1.对方向【固定不动】的旋转轴旋转：Fixed angles 2.对【旋转的frame当下所在】的旋转轴旋转：Euler angles\n第二章 Rotation Matrix 与转角与Transformation Matrix Fixed Angles，Euler Angles，mapping，operator\nFixed Angles 1.由angles推算R ![[Pasted image 20241105144652.png]] ![[Pasted image 20241105145127.png]] 此处是先转X，再转Y，最后转Z\n旋转示例 ![[Pasted image 20241105150243.png]] ![[Pasted image 20241106084710.png]]\n转动顺序不同，最后的矩阵也不同\n2.由R推算angles 已知R，推算角度angles，如何让旋转到R的姿态 ![[Pasted image 20241106085113.png]]\n角度不是90度时，有唯一解 ![[Pasted image 20241106085420.png]]\n注意，使用的时 Atan2 函数，Atan2函数能判别角度所在象限，解出的角度范围为-180-+180度 ![[Pasted image 20241106085952.png]]\n角度是90度时，有很多解（多解） 这是其中的一组特解，取$\\alpha=0$，方便后续计算\n![[Pasted image 20241106090307.png]]\nEuler Angles 以被转动的系统的转轴去做旋转\nZ-Y-X Euler Angles .由angles推算R ![[Pasted image 20241106091748.png]] ![[Pasted image 20241106092619.png]] ![[Pasted image 20241106093611.png]]\n将欧拉角下的旋转可以看作Fixed angles的转动 不同在于，欧拉角转动顺序为Z-Y-X，Fixed Angles转动顺序为X-Y-Z ![[Pasted image 20241106100822.png]] 欧拉角的正转=Fixed Angles的反转\n欧拉角旋转也与顺序有关 ![[Pasted image 20241106094202.png]]\nZ-Y-Z Euler Angles .由angles推算R ![[Pasted image 20241205151139.png]] 反算的公式，注意多解的情况 ![[Pasted image 20241205151227.png]] ![[Pasted image 20241205151403.png]] Z-Y-Z的欧拉角旋转，同样可以做到Z-Y-X欧拉角旋转同样的效果 例子 ![[Pasted image 20241205151647.png]]\n两者的旋转 旋转矩阵与欧拉角之间的转换_旋转矩阵转欧拉角-CSDN博客 外旋，外在旋转 ![[Pasted image 20241106225626.png]]\n内旋，内在旋转 ![[Pasted image 20241106225555.png]]\n![[Pasted image 20241106225654.png]]\nRotation Matrix与转角小结 ![[Pasted image 20241205152335.png]] fixed angle与euler angles有12种表达方式 第一个转角，3个选择 第二个转角，2个选择（与第一个转角不同） 第三个转角，2个选择（与第二个转角不同） 12 = 3 * 2 * 2\nAngle-axis表达法 ![[Pasted image 20241205152717.png]]\nQuaternion表达法 ![[Pasted image 20241205152753.png]]\nTransformation Matrix Mapping 刚体状态的表达 ![[Pasted image 20241205153237.png]] ![[Pasted image 20241205153303.png]] 将移动和转动整合在一起描述 ![[Pasted image 20241205153344.png]] ![[Pasted image 20241205153516.png]]\n验证其正确性 仅有移动时 ![[Pasted image 20241205153803.png]] 仅有转动时 ![[Pasted image 20241205153919.png]] 移动和转动混合 先转动使B_frame变为A_frame，再进行移动 ![[Pasted image 20241205154134.png]] ![[Pasted image 20241205154254.png]]\nExample ![[Pasted image 20241205155035.png]]\nOperator $_{B}^{A}T$除了Mapping之外，也可当Operator，对向量（或点）进行移动或旋转 先转动再移动 ![[Pasted image 20241205155842.png]]\n![[Pasted image 20241205160142.png]] Operator示例 ![[Pasted image 20241205161307.png]] 相对运动，反相移动frame ![[Pasted image 20241205161546.png]] ![[Pasted image 20241205161902.png]]\n正向，先转动，再移动 反向理解，对frame先转动，在转动后的frame进行移动\nTransformation Matrix用法小结 ![[Pasted image 20241205163326.png]] ![[Pasted image 20241205163347.png]]\n连续运算及其法则 T的mapping ![[Pasted image 20241205164054.png]] ![[Pasted image 20241205164557.png]]\nT中旋转：1）fixed angle 2）euler angle 旋转方式不同，T的连续运算法则不同 ![[Pasted image 20241205170138.png]]\n![[Pasted image 20241205170555.png]]\n反矩阵 ![[Pasted image 20241205164853.png]]\n![[Pasted image 20241205165140.png]] ![[Pasted image 20241205165738.png]]\n第三章 机械手臂的顺向运动学 运动学与动力学 运动学，讨论运动状态本身，没有连结到产生运动的力 ![[Pasted image 20241205224953.png]] ![[Pasted image 20241205225048.png]] 动力学，讨论力/力矩如何产生运动 ![[Pasted image 20241205225206.png]] 目前只讨论机械臂的运动学\n机械臂 几何描述 ![[Pasted image 20241205225328.png]] 机械臂的描述方式 ![[Pasted image 20241205230503.png]] 机械臂刚体部分link表示 转轴用axis表示\n描述方式 两个转轴，一个杆 ![[Pasted image 20241206133449.png]] 多个转轴，多个杆，还需要两个参数 ![[Pasted image 20241206134314.png]]\n![[Pasted image 20241206134635.png]]\n杆件上建立frame 普通杆件 ![[Pasted image 20241206141907.png]] 地杆（axis0-link0） 相当于地杆是一个绝对静止的坐标系（frame） ![[Pasted image 20241206143432.png]] 末端杆 ![[Pasted image 20241206144557.png]]\nDH 表达法 ![[Pasted image 20241206144541.png]] Axis_i的$\\alpha_i$，为顺时针转动，$\\alpha_i$为负值 x轴指向眼睛 试想如何定义x_y坐标系的旋转，实际上z轴指向眼睛，结合之前euler-angle的内容理解\nLink-Transformation 每次移动都是基于当前坐标系，所以是类似于Euler-Angle的操作方法 ![[Pasted image 20241206151000.png]] 拆解每一个动作 ![[Pasted image 20241206151954.png]] 合并为一个Transformation-Matrix ![[Pasted image 20241206152205.png]] 连续 ![[Pasted image 20241206152343.png]]\nExample z轴方向与转轴方向一致 例1 ![[Pasted image 20241206153229.png]] 例2 ![[Pasted image 20241206160020.png]] 例3 ![[Pasted image 20241206155936.png]] 例4 ![[Pasted image 20241206160534.png]] 例5 ![[Pasted image 20241206171332.png]] 例6 【台大机器人学之运动学——林沛群（含课件+书籍）】https://www.bilibili.com/video/BV1v4411H7ez?p=25\u0026amp;vd_source=5a0790755035f26a67935abfbfcdfd5b\n很常见的架构，前三轴移动，后三轴转动 队内使用的2024国赛工程使用的架构 ![[Pasted image 20241206192332.png]] 后三轴共轴，方便inverse求解 z1，z2共平面，x共轴，方便处理 ![[Pasted image 20241206202207.png]] 所有轴建立frame后 ![[Pasted image 20241206202329.png]] 解算部分 ![[Pasted image 20241206203155.png]] ![[Pasted image 20241206203235.png]]\n应用的例子 forward kinematics正向运动学 inverse kinematics逆向运动学 ![[Pasted image 20241206172044.png]] 考虑具体的驱动装置，如何转换到关节的坐标系 ![[Pasted image 20241206172637.png]]\n一些应用，关于轮模式和腿模式 轮腿切换 ![[Pasted image 20241206172802.png]] 轮腿的模式切换 ![[Pasted image 20241206172946.png]] 中间的换算，关节和马达 ![[Pasted image 20241206173822.png]]\nDH表达方式小结 Denavit-Hartenberg表达方式 注意：从上到下有严格的操作顺序 ![[Pasted image 20241206185157.png]] ![[Pasted image 20241206185309.png]] 上面的表达方式为Craig version\n另外的一个表达方式：DH表示法Standard version ![[Pasted image 20241206185741.png]] ![[Pasted image 20241206191938.png]]\nCraig方式还要加上末端点在最后一个joit下的坐标移动 ![[Pasted image 20241206192200.png]]\n第四章 逆向运动学 求解的概念 ![[Pasted image 20241206204531.png]] ![[Pasted image 20241206205529.png]] ![[Pasted image 20241206205539.png]] ![[Pasted image 20241206205554.png]\n![[Pasted image 20241206210124.png]] ![[Pasted image 20241206211803.png]]\n多解问题 ![[Pasted image 20241207193421.png]] 非线性方程 ![[Pasted image 20241207193444.png]]\nExample:PUMA的多解引言 [[机器人学#第三章 机械手臂的顺向运动学#Example]]例6\n![[Pasted image 20241207193651.png]] ![[Pasted image 20241207193926.png]] ![[Pasted image 20241207194830.png]]\n求解方法 ![[Pasted image 20241207195952.png]]\n求解例题的方法 几何解法 ![[Pasted image 20241207200424.png]] 有了$\\Phi$角，和目标x，y，反解角度 ![[Pasted image 20241207200456.png]] ![[Pasted image 20241207201241.png]]\n具体运算的例子 ![[Pasted image 20241207201647.png]]\n代数解法 ![[Pasted image 20241209110024.png]] ![[Pasted image 20241209110310.png]] ![[Pasted image 20241209112718.png]] ![[Pasted image 20241209113138.png]]\nPieper\u0026rsquo;s Solution 【台大机器人学之运动学——林沛群（含课件+书籍）】https://www.bilibili.com/video/BV1v4411H7ez?p=30\u0026amp;vd_source=5a0790755035f26a67935abfbfcdfd5b\n![[Pasted image 20241209113820.png]]\n位置 $\\theta_1$是基座yaw轴旋转角度 ![[Pasted image 20241209115724.png]] joint0 -\u0026gt; joint1 只有$\\theta$角的旋转，$\\alpha$的旋转为0，没有a和d的位移 所以joint0 -\u0026gt; joint1 只有坐标系的旋转，有$x^2+y^2+z^2=g_1^2+g_2^2+g_3^2$ ![[Pasted image 20241209120126.png]] ![[Pasted image 20241209121335.png]] ![[Pasted image 20241209121928.png]] 一层一层，分离变量去求解\n姿态 最后的姿态$_6^0R=_3^0R _6^3R$，反解位置时已经得出$R_3^0$，则在末端的姿态下需要的转动为$_6^3R=_3^0R^{-1}_6^{0}R$ ![[Pasted image 20241209130853.png]] ![[Pasted image 20241209130835.png]] 相当于是在将x-y-z的三个坐标系，换到一个Euler-Angle的x-y-z坐标系中，每次的转动是在绕Euler-Angle的x轴，y轴，z轴，需要进行一定的矫正\n[[机器人学#Z-Y-Z Euler Angles .由angles推算R]] ![[Pasted image 20241209132708.png]] 第6个坐标系的y轴有误，应该是画反了\n其他人的笔记参考 ![[Pasted image 20241210170822.png]]\n物件取放任务 ![[Pasted image 20241209145556.png]] ![[Pasted image 20241209145736.png]] ![[Pasted image 20241209150257.png]] ![[Pasted image 20241209150443.png]] ![[Pasted image 20241209151114.png]] ![[Pasted image 20241209151504.png]]\n第五章 轨迹规划 引言 ![[Pasted image 20241209153623.png]] 轨迹 最好的轨迹是连续的 ![[Pasted image 20241209214452.png]] 在轨迹的点上加上姿态的要求 ![[Pasted image 20241209215002.png]]\nJoint-space下的轨迹规划 【台大机器人学之运动学——林沛群（含课件+书籍）】https://www.bilibili.com/video/BV1v4411H7ez?p=34\u0026amp;vd_source=5a0790755035f26a67935abfbfcdfd5b\n本质就是对关节的旋转角度做规划 3个自由度的移动，3个自由度的转动 ![[Pasted image 20241209215316.png]] ![[Pasted image 20241209220007.png]] ![[Pasted image 20241209220509.png]] 换到$D_x,D_y,D_z$下，主要是检测轨迹中手臂有没有撞到什么东西\nCartesian-space的轨迹规划 计算量大，许多个笛卡尔坐标系的坐标点要IK（逆解算） ![[Pasted image 20241209221710.png]] ![[Pasted image 20241209222334.png]]\nCubic-Polynominals 要保证前后的位置和速度相连 ![[Pasted image 20241210162158.png]] 更高次的轨迹规划 ![[Pasted image 20241210162306.png]]\n位置条件两个方程，加上求导后的速度条件提供两个方程 ![[Pasted image 20241210162844.png]] ![[Pasted image 20241210165344.png]]\n如何选择速度条件 （1）前后速度变号处的（角度增加，后面变为减少） ![[Pasted image 20241210165736.png]]\n例子 ![[Pasted image 20241210170446.png]]\n多端Cubic-Polynommials 让加速度也连续 放弃在前后速度变号处的via-point的速度为零以及速度取平均的方式，改为让加速度也连续 ![[Pasted image 20241210170441.png]] ![[Pasted image 20241210171907.png]] ![[Pasted image 20241210172123.png]] ![[Pasted image 20241210172242.png]]\nGeneral-Cubic-Polynomials 所有点的位置，速度，加速度连续 ![[Pasted image 20241210231911.png]] n+1个点，n条线段需要规划，有4n个未知数，所以需要4n个方程\n关于4n个方程式的生成 （1）位置条件，对于n段的规划，每一段的两个端点都是有一个边界条件，有2n个方程 （2）速度条件，有n-1个via-point，每个point有速度和加速度连续的条件 前一个规划的末端求导等于后一段规划的起始求导 前一段的函数，后一段的函数，连续 n-1个via-point速度连续，有n-1个方程 n-1个via-point加速度连续，有n-1个方程 （3）对初始点和末端点的起始条件设定\n![[Pasted image 20241210232905.png]] （3）对起始点和末端点的起始条件设定 ![[Pasted image 20241210234441.png]]\n路径规划示例 ![[Pasted image 20241211001214.png]] 在Cartesian-space下的路径规划 ![[Pasted image 20241211001200.png]] ![[Pasted image 20241211001718.png]] 对x，y，$\\theta$三个数做关于t的规划 ![[Pasted image 20241211001910.png]] ![[Pasted image 20241211002009.png]]\n在Joint-space下做轨迹规划并求解 ![[Pasted image 20241211093307.png]] ![[Pasted image 20241211093614.png]] ![[Pasted image 20241211093709.png]] ![[Pasted image 20241211094033.png]]\n第六章 Lineaar Function with Parabolic Blends Lineaar Function with Parabolic Blends 缓加速，匀速，缓减速 ![[Pasted image 20241211144239.png]] ![[Pasted image 20241211144847.png]] 2式有错误，应该是角度的二阶导 ![[Pasted image 20241211145423.png]] ![[Pasted image 20241211150115.png]] ![[Pasted image 20241211150627.png]]\n多段Lineaar Function with Parabolic Blends ![[Pasted image 20241211151907.png]] ![[Pasted image 20241211151921.png]] ![[Pasted image 20241211151945.png]] 注意这里对时间的定义 ![[Pasted image 20241211152050.png]]\n中间段的轨迹设定 ![[Pasted image 20241211152727.png]] 速度 ![[Pasted image 20241211225332.png]] 加速度 ![[Pasted image 20241211225315.png]]\n头尾段的设计 头需要往后移一点 ![[Pasted image 20241211153733.png]] 尾需要往前移一点 ![[Pasted image 20241211154740.png]]\nLineaar Function with Parabolic Blends注解 【台大机器人学之运动学——林沛群（含课件+书籍）】https://www.bilibili.com/video/BV1v4411H7ez?p=45\u0026amp;vd_source=5a0790755035f26a67935abfbfcdfd5b\n关于加速度 考虑实际中的多个因素的分析，针对加速度 ![[Pasted image 20241211160106.png]] 要考虑每个关节所需要的力，科氏力，重力（动力学部分） ![[Pasted image 20241211160322.png]] 电机提供扭矩，提供力 状态的维持（重力），关节高速旋转（向心力，科氏力），加速度的加减（M），都需要电机提供力 如果维持一个状态的重力过大，电机就可能没有足够的力去运动，去做旋转\n关于Lineaar Function with Parabolic Blends中为经过via-point的问题 如果必须严格通过via-point的话（在via-point上要执行一些工作），在via-point附近添加几个点，让原来必须经过的via-point在直线上 ![[Pasted image 20241211162003.png]]\n求解规划轨迹的某一时刻的位置 ![[Pasted image 20241211162923.png]]\nCartesian-space下轨迹几何极限 ![[Pasted image 20241211165237.png]]\nRevisit the RRR Manipulator ![[Pasted image 20241211170132.png]] ![[Pasted image 20241211175012.png]] ![[Pasted image 20241211175927.png]]\n第七章 机械臂轨迹规划实例 Capstone example PUMA机械臂 ![[Pasted image 20241211192247.png]] ![[Pasted image 20241211192338.png]] ![[Pasted image 20241211193907.png]]\n设定 ![[Pasted image 20241211212219.png]] ![[Pasted image 20241211213101.png]] 从cup的坐标系转换到手臂末端的坐标系 注意$^6_CT^{-1}$，在$^6T$坐标系下沿着Z轴移动206 导致$^0_6T_i$的Transformation-Matrix的移动向量的x，y，z与C相对于World-Frame的不同 ![[Pasted image 20241211213343.png]] ![[Pasted image 20241211224115.png]]\n轨迹规划：方法：Lineaar Function with Parabolic Blends 在Cartesian-space下的规划 ![[Pasted image 20241211225442.png]] ![[Pasted image 20241212174427.png]] 由此去求出加速度 ![[Pasted image 20241212173712.png]] ![[Pasted image 20241212174827.png]]\n做IK逆运算时 ![[Pasted image 20241212175110.png]] 找出该点的(x,y,z)坐标，由此求出前三轴的姿态 这也是前面轨迹规划时，找机械臂末端点求解的点 ![[Pasted image 20241212175121.png]] 前三轴的轨迹规划是在规划位置 后三轴的轨迹规划是在规划最后的末端点的姿态\n位置 ![[Pasted image 20241212175050.png]] ![[Pasted image 20241212180157.png]] ![[Pasted image 20241212180626.png]]\n姿态 ![[Pasted image 20241212181758.png]] 有R3的姿态，但要开始姿态的转换，需要先转到与R4同方向的姿态\n逆向求解Euler-angle的Z-Y-Z $\\alpha$ ,$\\beta$,$\\gamma$\n![[Pasted image 20241213140036.png]]\nEuler-angle的Z-Y-Z $\\alpha$ ,$\\beta$,$\\gamma$ 去对应4，5，6转轴的$\\theta_1$,$\\theta_2$,$\\theta_3$ ![[Pasted image 20241213140130.png]] ![[Pasted image 20241213140728.png]] ![[Pasted image 20241213140835.png]] ![[Pasted image 20241213141202.png]] ![[Pasted image 20241213141354.png]] ![[Pasted image 20241213141508.png]]\n在Joint-space下的规划 ![[Pasted image 20241213143801.png]] ![[Pasted image 20241213144521.png]] ![[Pasted image 20241213144642.png]] ![[Pasted image 20241213144742.png]] ![[Pasted image 20241213145339.png]]\n注解 主要内容：\n刚体运动状态的描述 顺向运动学 逆向运动学 轨迹规划 ![[Pasted image 20241213194945.png]] 轨迹规划可拓展 ![[Pasted image 20241213195805.png]] ![[Pasted image 20241213200018.png]] ![[Pasted image 20241213203641.png]] ![[Pasted image 20241213204605.png]] 冗余自由度的作用 ![[Pasted image 20241213204710.png]]\n完结撒花\n视频的勘误 繁体到简体翻译 目前投影片错误皆已修正，但因影片处理较费时，麻烦大家先对照勘误表。如果还有其他错误敬请指教。 “4-4 物件取放任务”：\n影片13:43-15:03桌子座标标示原点错误，长度250应由桌子原点起算。可以参考7:55-13:42的标示方法。（投影片在p28, 30, 31） 影片16:18-17:21 r=1.68498214e5修正为168813.18。（投影片 p33） 后三轴Euler angle的计算还有其他细节须注意，请见下方补充。 关于本週教材及作业内容，Example及Quiz中的手臂构型由于后三轴相交于一点，得以独立拆解成两部分计算，可注意以下几点： 【前三轴】 手臂IK本身具有多重解且计算细节多，建议搭配FK确认是计算错误抑或只是求到另一组解。 以教材中的Example来说，前三轴共有四组解：(21.8, -52.2, 2.5), (21.8, 47.1, 164.0), (201.7, 126.9, 15.2), (201.7, -121.1, 151.3)，关于这四组解的构型，可以参考投影片p7，或者影片“4-2_多重解1”1:34-4:42。 至于Quiz部分请依照题目要求的角度限制作答。关于不同解法的补充如下： Pieper’s solution Pieper’s solution方程式较複杂且非线性程度高，建议使用MATLAB或其他软体计算。以MATLAB的solve为例，因其对非线性方程式之处理能力较有限，建议参考影片“4-2_多重解 3 Example 2”9:22-end或投影片 p18，将三角函数用subs指令替换成多项式，进行后续计算。 另外，由于列式时将部分距离及三角函数取平方，可能会算出反向距离的解，请搭配FK确认排除。 几何法 使用几何法则须想像出手臂到达该点的姿态，才能列出所有的可行解。列式时请注意手臂的offset项 ","date":"2025-01-08T18:09:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/","title":"机器人学"},{"content":"作用 如果一个变量被const修饰，那么它的值就不能再被改变\nconst的优点 （1）可以保护被修饰的东西，防止意外修改，增强程序的健壮性\n（2）编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高\nconst修饰局部变量 1 2 const int n=5; int const n=5; 这两种写法是一样的，都是表示变量n的值不能被改变了，需要注意的是，用const修饰变量时，一定要给变脸初始化，否则之后就不能再进行赋值\nconst 修饰指针 1.常量指针 常量指针是指针指向的内容是常量，可以有一下两种定义方式\n1 2 const int * n; int const * n; 注意： （1）常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的\n（2）常量指针指向的值不能改变，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址\n2.指针常量 指针常量是指指针本身是个常量，不能再指向其他的地址\n1 int *const n; 需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改\n3.指向常量的常指针 指向常量的常指针是以上两种的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值\n1 const int* const p; const修饰函数的参数 1.防止修改指针指向的内容\n1 void StringCopy(char *strDestination, const char *strSource); 其中 strSource 是输入参数，strDestination 是输出参数 给 strSource 加上 const 修饰后，如果函数体内的语句试图改动 strSource 的内容，编译器将指出错误\n2.防止修改指针指向的地址\n1 void swap ( int * const p1 , int * const p2 ) 指针p1和指针p2指向的地址都不能修改\n","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-const/","title":"C\u0026C++ const"},{"content":"基于菜鸟教程写的个人笔记\n存储类 存储类定义了C程序中变量/函数的存储位置，生命周期，作用域\nauto register static extern 1.auto存储类 auto存储类是所有局部变量默认的存储类 定义在函数中的变量都默认为auto存储类 它们在函数开始时被创建，在函数结束时被销毁\n1 2 3 4 { int month ; auto int month ; } auto只能修饰局部变量\n2.register存储类 register存储类用于定义存储在寄存器上，而不是RAM中的局部变量 register存储类定义存储在寄存器，变量访问速度更快，不能直接地取地址（因为它存储在RAM中）\n1 2 3 { register int miles ； } 寄存器一般用于需要快速访问的变量\n3.static存储类 （1）static作用于局部变量 a.使局部变量在程序生命周期内都存在，不需要每次进入和离开其作用域（函数）的时候创建（重新分配内存）和销毁。 b.使用static修饰局部变量可以在函数调用之间保持局部变量的值\nstatic作用的变量，静态局部变量存储在静态（全局）存储区\n（2）static作用于全局变量 当static修饰全局变量时，会使变量的作用域限制在声明它的文件内\n（3）静态变量的特性 静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; /* 函数声明 */ void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main() { while (count--) { func1(); } return 0; } void func1(void) { /* \u0026#39;thingy\u0026#39; 是 \u0026#39;func1\u0026#39; 的局部变量 - 只初始化一次 * 每次调用函数 \u0026#39;func1\u0026#39; \u0026#39;thingy\u0026#39; 值不会被重置。 */ static int thingy=5; thingy++; printf(\u0026#34; thingy 为 %d ， count 为 %d\\n\u0026#34;, thingy, count); } 实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置\n当上面的代码被编译和执行时，它会产生下列结果：\n1 2 3 4 5 6 7 8 9 10 thingy 为 6 ， count 为 9 thingy 为 7 ， count 为 8 thingy 为 8 ， count 为 7 thingy 为 9 ， count 为 6 thingy 为 10 ， count 为 5 thingy 为 11 ， count 为 4 thingy 为 12 ， count 为 3 thingy 为 13 ， count 为 2 thingy 为 14 ， count 为 1 thingy 为 15 ， count 为 0 4.extern存储类 extern存储类用于定义在其他文件中声明的全局变量或函数 当使用extern关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义\nextern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n第一个文件 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; extern int count; void write_extern(void) { printf(\u0026#34;count is %d\\n\u0026#34;, count); } 结果 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：\n1 $ gcc main.c support.c 这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：\n1 count is 5 ","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/c%E5%AD%98%E5%82%A8%E7%B1%BB/","title":"C存储类"}]