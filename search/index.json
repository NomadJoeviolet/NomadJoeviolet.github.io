[{"content":"STM32 hal库串口空闲中断最新用法 - STM32团队 ST意法半导体中文论坛 （非常详细）【STM32】 DMA原理，步骤超细详解，一文看懂DMA-CSDN博客 STM32CubeIDE HAL库DMA与UART不定长数据接收实现：空闲中断详解-物联沃-IOTWORD物联网 STM32 hal库串口空闲中断最新用法_stm32hal库串口空闲中断-CSDN博客 HAL库 串口空闲中断+DMA接收不定长数据 详解及踩坑_hal库串口空闲中断-CSDN博客\nDMA DMA，全称为Direct Memory Access，直接内存访问，本质是将传输数据从一个内存空间搬运至另一个内存空间，可以用来提供外设和内存，内存和外设之间的高速数据传输\nUSART发送 在普通的轮询USART中，CPU一直在等待外设发送数据，外设每发送一字节，CPU就从内存中移动一字节数据到外设的寄存器\n在中断的USART中，外设每从寄存器中发送一字节数据，就会触发一次发送数据寄存器空中断，使CPU回来将数据从内存搬运至外设的寄存器中\nUSART的DMA发送 没有DMA的话，CPU会作为数据发送的中转站，而使用DMA的话，整个数据传输过程不需要CPU的参与，由DMA代理执行，DMA负责将内存数据搬运至外设的传输寄存器\n在整个数据发送过半时会触发一个传输过半中断，所有数据传输完成后会调用传输完成中断回调函数（HAL_UART_TxCpltCallback）\n1 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) HAL_UART_Transmit_DMA的传输完成中断回调函数HAL_UART_TxCpltCallback以及传输过半中断回调函数HAL_UART_TxHalfCpltCallback\nDMA发送注意事项 在传输的过程中，当传输一半的数据后，半传输标志(HTIF)被置1，当设置了允许半传输中断位(HTIE)时，将产生一个中断请求。在数据传输结束后，传输完成标志(TCIF)被置1，当设置了允许传输完成中断位 (TCIE)时，将产生一个中断请求\n会触发的三个中断，传输完成中断，传输过半中断，错误中断 在stm32f1xx_hal_uart.c的HAL_UART_Transmit_DMA函数中可以查看到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) { . . . /* Set the UART DMA transfer complete callback */ huart-\u0026gt;hdmatx-\u0026gt;XferCpltCallback = UART_DMATransmitCplt; /* Set the UART DMA Half transfer complete callback */ huart-\u0026gt;hdmatx-\u0026gt;XferHalfCpltCallback = UART_DMATxHalfCplt; /* Set the DMA error callback */ huart-\u0026gt;hdmatx-\u0026gt;XferErrorCallback = UART_DMAError; . . . } } USART接收 在普通的轮询USART中，CPU一直在询问外设是否接收完数据，外设接收一字节数据，该位数据由CPU从外设的接收数据寄存器运进内存，CPU再次询问外设是否接收完数据，再运，直至整个数据结束完成\n而在中断USART中，外设每接收一字节数据，触发一次数据接收寄存器非空中断，CPU过来将数据从寄存器搬运至内存，所有数据接收完成后，会调用接收完成中断回调函数（HAL_UART_RxCpltCallback）\nUSART的DMA接收 没有DMA的话，CPU会作为数据转运的中转站，而使用DMA的话，整个数据转运过程不需要CPU的参与，由DMA代理执行\n在整个数据接收过半时会触发一个传输过半中断，所有数据接收完成后会调用传输完成中断回调函数（HAL_UART_RxCpltCallback）\n1 HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) HAL_UART_Receive_DMA的接收完成中断回调函数HAL_UART_RxCpltCallback以及接收过半中断回调函数HAL_UART_RxHalfCpltCallback\nDMA接收注意事项 同DMA发送，类比即可\nHAL库USART使用DMA 如果USART串口的DMA出现错误，会调用HAL_UART_ErrorCallback\nDMA发送 1 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) 会触发中断\nHAL_UART_TxCpltCallback HAL_UART_TxHalfCpltCallback DMA接收 1 HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) 会触发的中断\nHAL_UART_RxCpltCallback HAL_UART_RxHalfCpltCallback DMA模式 normal模式 以接收为例 单次接收，接收至数据上限，完成整个固定数据接收后停止，再次接收需要再次开启HAL_UART_Receive_DMA ，需要软件显式重启，触发接收过半和接收完成中断\nsummary：单次传输，完成后停止，需要软件显式重启，接收过半和接收完成中断\ncircular模式 以接收为例 无限循环，接收至数据上限一半，触发接收过半中断，接受至数据上限，触发接收完成中断，同时会硬件自动重启，接收完成中断会调用``\nsummary：无限循环，硬件自动重启，接收过半和接收完成中断\n说明 空闲中断 空闲中断定义 空闲中断（IDLE Interrupt） 是UART通信中的一种特殊中断类型，它在检测到UART接收线路连续空闲超过1个字节传输时间时触发的中断。\u0026ldquo;空闲\u0026quot;指线路保持逻辑1状态（高电平），线上无数据传输\nHAL库自带的空闲中断实现 1 2 //在阻塞模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen, uint32_t Timeout); 1 2 //在中断模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 1 2 //在DMA模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 1 2 //使用空闲中断时的接收回调函数 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size); 在触发空闲中断，接收完成中断都会调用HAL_UARTEx_RxEventCallback回调函数，需要注意的是在F103c8t6单片机上，使用HAL_UARTEx_ReceiveToIdle_DMA时，接收过半中断也会去调用该回调函数\n接收过半中断的处理 STM32CubeIDE HAL库DMA与UART不定长数据接收实现：空闲中断详解-物联沃-IOTWORD物联网 HAL_UARTEx_RecceiveToIdle_DMA会调用UART_Start_Receive_DMA(huart, pData, Size)函数，该函数会把DMA中断传输完成，半传输，传输错误全部开启\n1 __HAL_DMA_ENABLE_IT(DMA_IT_TC | DMA_IT_HC | DMA_IT_TE) UART_Start_Receive_DMA(huart, pData, Size) 设置接收数组缓存到达数组一半时会执行下面的回调函数\n1 2 /* Set the UART DMA Half transfer complete callback */ huart-\u0026gt;hdmarx-\u0026gt;XferHalfCpltCallback = UART_DMARxHalfCplt; 而UART_DMARxHalfCplt会调用HAL_UARTEx_RxEventCallback\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma) { UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)-\u0026gt;Parent; /* Initialize type of RxEvent that correspond to RxEvent callback execution; In this case, Rx Event type is Half Transfer */ huart-\u0026gt;RxEventType = HAL_UART_RXEVENT_HT; /* Check current reception Mode : If Reception till IDLE event has been selected : use Rx Event callback */ if (huart-\u0026gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE) { #if (USE_HAL_UART_REGISTER_CALLBACKS == 1) /*Call registered Rx Event callback*/ huart-\u0026gt;RxEventCallback(huart, huart-\u0026gt;RxXferSize / 2U); #else /*Call legacy weak Rx Event callback*/ HAL_UARTEx_RxEventCallback(huart, huart-\u0026gt;RxXferSize / 2U); #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ } else { /* In other cases : use Rx Half Complete callback */ #if (USE_HAL_UART_REGISTER_CALLBACKS == 1) /*Call registered Rx Half complete callback*/ huart-\u0026gt;RxHalfCpltCallback(huart); #else /*Call legacy weak Rx Half complete callback*/ HAL_UART_RxHalfCpltCallback(huart); #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ } } 为了避免接收过半中断的调用，需要使用下面的语句\n1 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx,DMA_IT_HT);//关闭dma接收半满中断函数，这样我们在接收一组数据时就不会触发半满中断，dma就可以正常接收一组数据 另外在UART_DMAReceiveCplt函数中也调用了HAL_UARTEx_RxEventCallback函数\n1 static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma) DMA+空闲中断的实现接收不定长数据 方式1 自定义DMA+空闲中断\n前置内容 需要自己写的宏定义\n1 2 #define __HAL_DMA_SET_COUNTERT(__HANDLE__,__COUNTER__) ((__HANDLE__)-\u0026gt;Instance-\u0026gt;CNDTR = (uint16_t)(__COUNTER__)) //重新设定计数值 1 2 //用法 __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); 用到的宏定义\n1 2 __HAL_DMA_GET_COUNTER(huart-\u0026gt;hdmarx) //获取剩余未传输的计数值 用到的关于中断的操作\n1 2 3 4 5 6 7 8 9 10 __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx)//关闭DMA __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx)//开启DMA //清除空闲标志位 __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1) //开启空闲中断 __HAL_UART_ENABLE_IT(\u0026amp;huart1 , UART_IT_IDLE ) //关闭空闲中断 __HAL_UART_DISABLE_IT(\u0026amp;huart1, UART_IT_IDLE ) 代码实现 1 2 3 #define rxBufferLen 10 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; 1 2 3 4 5 void UART_InitDMAReceive() { __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1);//清除空闲中断标志位 __HAL_UART_ENABLE_IT(\u0026amp;huart1 , UART_IT_IDLE );//使能空闲中断 HAL_UART_Receive_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//开启DMA接收 } 需要关闭DMA才能重设DMA的COUNTER\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //自定义的DMA空闲中断回调函数 void UART_DMAIdleCallback(UART_HandleTypeDef *huart) { if (huart == \u0026amp;huart1 ) { __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//失能DMA int datalen = rxBufferLen - __HAL_DMA_GET_COUNTER(huart-\u0026gt;hdmarx); for(int i=0;i\u0026lt;datalen;i++) { char temp = rxBuffer[i]; txBuffer[i] = (temp \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; temp \u0026lt;= \u0026#39;z\u0026#39;) ? temp-32:temp; } HAL_UART_Transmit_DMA(\u0026amp;huart1,(uint8_t*)txBuffer,datalen); __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen);//重置DMA计数 __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//使能DMA } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void USART1_IRQHandler(void) { /* USER CODE BEGIN USART1_IRQn 0 */ /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(\u0026amp;huart1); /* USER CODE BEGIN USART1_IRQn 1 */ //触发空闲中断后，会进入中断请求处理函数 if (__HAL_UART_GET_FLAG(\u0026amp;huart1 , UART_FLAG_IDLE) != RESET ) {//在此判断是否为空闲中断 __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1);//清除空闲中断标志位 __HAL_UART_DISABLE_IT(\u0026amp;huart1, UART_IT_IDLE);//失能空闲中断 UART_DMAIdleCallback(\u0026amp;huart1);//调用自定义中断回调函数 __HAL_UART_ENABLE_IT(\u0026amp;huart1, UART_IT_IDLE);//使能空闲中断 } /* USER CODE END USART1_IRQn 1 */ } 关于normal和circular在方式1的空闲中断实现的区别 normal模式 在上述空闲中断实现中，如果使用normal模式，需要注意接收的数据一定不能超过rxBufferLen，一旦超过，DMA接收就会终止\n执行流程是，触发空闲中断，进入USART1_IRQHandler，再进入自定义空闲中断，在里面重新设置了DMA的计数值（指针也会重新设置，重新指向rxBuffer[0]），最开始开启的HAL_UART_Receive_DMA始终没有接收完 完整的数据，就不会关闭，一直接收\n但如果接收的数据超过rxBufferLen，会触发接收过半和接收完成中断（对应回调函数没使用，约等于空函数），同时HAL_UART_Receive_DMA会结束，需要软件显式重启\n例如：rxBufferlen=10，发送12345678910，会回复1234567891，随后DMA终止，再发送数据无回复\ncircular模式 在上述空闲中断实现中，如果使用circular模式，则接收的数据可以超过rxBufferLen，超过后，DMA接收会自动重启\n执行流程是，触发空闲中断，进入USART1_IRQHandler，再进入自定义空闲中断，在里面重新设置了DMA的计数值（指针也会重新设置，重新指向rxBuffer[0]），就算接收数据超过rxBufferLen，HAL_UART_Receive_DMA也会重新启动\n但是需要注意，如果达到rxBufferLen,会触发接收过半和接收完成中断，然后硬件重启，重新回到rxBufferLen[0]的位置读数据，直至发生空闲中断\n例如：rxBufferlen=10，发送12345678910，会回复0，随后DMA仍然正常工作\n方式2 使用HAL库提供的空闲中断，使用normal模式\n该方式下的空闲中断回调函数为HAL_UARTEx_RxEventCallback ，需要注意接收过半中断也会调用HAL_UARTEx_RxEventCallback的问题，在每次开启HAL_UARTEx_ReceiveToIdle_DMA后都需要关闭接收过半中断\n1 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx,DMA_IT_HT);//关闭dma接收半满中断函数，这样我们在接收一组数据时就不会触发半满中断，dma就可以正常接收一组数据 当接收数据超过rxBufferLen时，接收完成中断函数会调用HAL_UARTEx_RxEventCallback回调函数，然后重新开启接收\n例如：rxBufferLen=10，接收12345678910，发送1234567891（就是因为接收完成中断导致），后面DMA空闲中断接收正常开启\n代码实现 1 2 3 4 void Init_IdleDMA(void) {//初始化，开启DMA空闲中断接收 HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } 1 2 3 4 5 6 7 8 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//normal模式，接受一次后需要重新开启 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } } 关于normal和circular在方式2下的空闲中断实现的区别 normal模式 方式2中，在数据接收过半，接收完成，空闲时会触发对应中断，最后调用HAL_UARTEx_RxEventCallback回调函数，在回调函数中软件显式重启HAL_UARTEx_ReceiveToIdle_DMA\ncircular模式 方式2中，若使用circular模式，则数据会一直积累，到达rxBufferLen时，会硬件重启，同时也会有数据接收过半，接收完成，空闲时会触发对应中断，最后调用HAL_UARTEx_RxEventCallback回调函数\n例如： (1)关闭接收过半中断 rxBufferLen=10，接收123，发送123， 再接收456，发送123456， 再接收78910，会先发送1234567891（接收完成），再发送0（空闲中断）， 再接收111213，发送0111213\n(2)未关闭接收过半中断 rxBufferLen=10，接收123，发送123， 再接收123，会先发送12312（接收过半中断），再发送123123空闲中断， 再接收12345，会先发送1231231234（接收完成中断），再发送5空闲中断\n方式3 使用HAL库提供的空闲中断，但是使用circular模式实现\n在circuar要想实现一帧一帧不定长数据的接收主要需要考虑的就是如何实现在接收完一帧后让DMA的计数值重置\n实现原理 关闭 要实现DMA计数值的重置，需要使用HAL_UART_DMAStop(\u0026amp;huart1)函数将DMA关闭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart) { uint32_t dmarequest = 0x00U; /* The Lock is not implemented on this API to allow the user application to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback(): when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() */ /* Stop UART DMA Tx request if ongoing */ dmarequest = HAL_IS_BIT_SET(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAT); if ((huart-\u0026gt;gState == HAL_UART_STATE_BUSY_TX) \u0026amp;\u0026amp; dmarequest) { ATOMIC_CLEAR_BIT(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAT); /* Abort the UART DMA Tx channel */ if (huart-\u0026gt;hdmatx != NULL) { HAL_DMA_Abort(huart-\u0026gt;hdmatx); } UART_EndTxTransfer(huart); } /* Stop UART DMA Rx request if ongoing */ dmarequest = HAL_IS_BIT_SET(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAR); if ((huart-\u0026gt;RxState == HAL_UART_STATE_BUSY_RX) \u0026amp;\u0026amp; dmarequest) { ATOMIC_CLEAR_BIT(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAR); /* Abort the UART DMA Rx channel */ if (huart-\u0026gt;hdmarx != NULL) { HAL_DMA_Abort(huart-\u0026gt;hdmarx); } UART_EndRxTransfer(huart); } return HAL_OK; } 其中会调用HAL_DMA_Abort(huart-\u0026gt;hdmatx)，但都不会重置DMA的计数值\n开启 在关闭DMA后，需要HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen)重新开启DMA以及空闲中断\n在HAL_UARTEx_ReceiveToIdle_DMA中，会进行判断if (huart-\u0026gt;RxState == HAL_UART_STATE_READY) ，判断RxState是否为HAL_UART_STATE_READY，如果是，则说明uart没有开启，但是是在预备状态，随后会去调用UART_Start_Receive_DMA(huart, pData, Size)开启uart以及DMA\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { HAL_StatusTypeDef status; /* Check that a Rx process is not already ongoing */ if (huart-\u0026gt;RxState == HAL_UART_STATE_READY) { if ((pData == NULL) || (Size == 0U)) { return HAL_ERROR; } /* Set Reception type to reception till IDLE Event*/ huart-\u0026gt;ReceptionType = HAL_UART_RECEPTION_TOIDLE; huart-\u0026gt;RxEventType = HAL_UART_RXEVENT_TC; status = UART_Start_Receive_DMA(huart, pData, Size); /* Check Rx process has been successfully started */ if (huart-\u0026gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE) { __HAL_UART_CLEAR_IDLEFLAG(huart); ATOMIC_SET_BIT(huart-\u0026gt;Instance-\u0026gt;CR1, USART_CR1_IDLEIE); } else { /* In case of errors already pending when reception is started, Interrupts may have already been raised and lead to reception abortion. (Overrun error for instance). In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */ status = HAL_ERROR; } return status; } else { return HAL_BUSY; } } 在UART_Start_Receive_DMA中会将uart的RxState设置为HAL_UART_STATE_BUSY_RX，中间还会去调用HAL_DMA_Start_IT\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { uint32_t *tmp; huart-\u0026gt;pRxBuffPtr = pData; huart-\u0026gt;RxXferSize = Size; huart-\u0026gt;ErrorCode = HAL_UART_ERROR_NONE; huart-\u0026gt;RxState = HAL_UART_STATE_BUSY_RX; ...... HAL_DMA_Start_IT(huart-\u0026gt;hdmarx, (uint32_t)\u0026amp;huart-\u0026gt;Instance-\u0026gt;DR, *(uint32_t *)tmp, Size); ...... } 在HAL_DMA_Start_IT会调用DMA_SetConfig去对DMA计数值等进行重置\n1 2 3 4 5 6 7 HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength) { ...... /* Configure the source, destination address and the data length \u0026amp; clear flags*/ DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength); ...... } 原理总结 1.HAL_UARTEx_ReceiveToIdle_DMA如果判断出huart-\u0026gt;RxState == HAL_UART_STATE_READY会调用UART_Start_Receive_DMA\n2.UART_Start_Receive_DMA会调用HAL_DMA_Start_IT，同时会将RxState修改为BUSY huart-\u0026gt;RxState = HAL_UART_STATE_BUSY_RX\n3.HAL_DMA_Start_IT会调用DMA_SetConfig进行DMA计数值等的重置\n而使用HAL_UART_DMAStop可以保证在回调函数处理数据时停止DMA接收，保证数据不会被覆盖，同时可以将huart-\u0026gt;RxState状态设置为HAL_UART_STATE_READY，随后再次开启DMA空闲中断接收就能重置DMA计数值\n从而实现非定长数据的接收\n代码实现 同样注意，需要关闭接收过半中断\n1 2 3 #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; 1 2 3 4 5 //初始化 void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } 1 2 3 4 5 6 7 8 9 10 11 12 //回调函数 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { HAL_UART_DMAStop(\u0026amp;huart1);//不会改变DMA的计数值 memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); memset(txBuffer, 0, Size); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//如果是normal模式，接受一次后需要重新开启，如果关闭了DMA，也需要重新启动 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } } 实验检验 我们设置cnt_i去记录AL_UART_DMAStop(\u0026amp;huart1)前后以及HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen)前后的DMA计数值变化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { uint32_t cnt_1 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); HAL_UART_DMAStop(\u0026amp;huart1);//不会改变DMA的计数值 uint32_t cnt_2 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); memset(txBuffer, 0, Size); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//如果是normal模式，接受一次后需要重新开启，如果关闭了DMA，也需要重新启动 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 uint32_t cnt_3 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); sprintf(txBuffer, \u0026#34;\\ncnt_1=%d cnt_2=%d cnt_3=%d\\n\u0026#34;, cnt_1,cnt_2,cnt_3); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, sizeof(txBuffer), 10); } } 实验结果\n1 2 3 4 输入：123456789101112131415161718192021 输出：123456789101112131415161718192021 cnt_1=479 cnt_2=479 cnt_3=512 证明我们在重启DMA空闲中断时实现了DMA计数值重置\n方式4 再仔细想一想，在circuar要想实现一帧一帧不定长数据的接收主要需要考虑的就是如何实现在接收完一帧后让DMA的计数值重置，也就是说没有必要为此使用HAL_UART_DMAStop再重启DMA空闲中断接收\n如何优化呢，结合方式1的实现就可以得到答案\n1 2 3 __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define __HAL_DMA_SET_COUNTERT(__HANDLE__,__COUNTER__) ((__HANDLE__)-\u0026gt;Instance-\u0026gt;CNDTR = (uint16_t)(__COUNTER__)) //重新设定计数值 #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) { if (huart == \u0026amp;huart1 ) { __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER } } ","date":"2025-06-18T19:52:33+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32dma_idle_it/","title":"STM32DMA_IDLE_IT"},{"content":"基于菜鸟教程写的个人笔记\nstatic定义 static是C/C++中常用的修饰符，控制变量的存储方式和可见性\nstatic-前置-空间分配 在函数内部定义的变量，当程序执行到其定义处时没编译器会为它在栈上分配空间，函数在栈上分配的空间再次函数结束时会释放掉\n如果想将函数中此变量的值保存至下一次调用：\n（1）将该变量定义为全局变量，但带来许多缺点，例如破坏了此变量的访问范围（在此函数中定义的变量，不仅仅只受此函数的控制）\n（2）使用static关键词修饰\n静态数据的存储 全局（静态）存储区：分为 DATA 段和 BSS 段 DATA 段（全局初始化区）存放初始化的全局变量和静态变量 BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量 程序运行结束时自动释放 BSS段在程序执行前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。\n在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。\n在C/C++中static的作用 General （1）在修饰变量时，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放 （2）static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能被其他文件调用，即使是extern外部声明也不可以 （3）static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0 （4）static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用 （5）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰 （6）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）\n关于静态变量与普通变量 静态全局变量 （1）静态变量都在全局数据区分配内存 （2）未经初始化的静态全局变量会被程序自动初始化为0 （3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的\n（1）全局变量和全局静态变量的区别\n1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。 2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。 静态局部变量 （1）该变量在全局数据区分配内存 （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，及以后的函数调用不会再进行初始化 （3）静态局部变量一般在声明处初始化，如果没有显示初始化，会被程序自动初始化为0 （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束\n一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。\nstatic用法 在C++中 static在类中的作用： 被 static 修饰的变量、被 static 修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变\n在 C++ 中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存\n静态成员的定义或声明要加个关键 static。静态成员可以通过双冒号来使用 即 \u0026lt;类名\u0026gt;::\u0026lt;静态成员名\u0026gt;\n结论：\n不能通过类名来调用类的非静态成员函数，可以通过类的对象调用静态成员函数和非静态成员函数 类的静态成员函数不可以使用类的非静态函数 在类的非静态成员函数中可以使用类的静态成员（函数，变量），非静态成员函数在调用静态成员变量时，静态成员变量必须在使用前初始化 因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员函数必须在类实例化对象后才有内存空间\n类的静态成员变量必须先初始化再使用 一些解释： 1）静态方法能不能引用非静态资源？不能，实例化对象的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。 2）静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。 3）非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是实例化对象之后才产生的，那么属于类的内容它都认识\nSummary:\n（1）静态成员函数中不能调用非静态成员 （2）非静态成员函数中可以调用静态成员。因为静态成员属于类本身，在类的对象产生之前就已经存在了，所以在非静态成员函数中是可以调用静态成员的 （3）静态成员变量使用前必须先初始化(如 int MyClass::m_nNumber = 0;)，否则会在 linker 时出错 静态数据成员 （1）静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变 （2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间 （3）静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0 （4）静态数据成员既可以通过对象名引用，也可以通过类名引用 静态成员函数 （1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员 （2）非静态成员函数有 this 指针，而静态成员函数没有 this 指针 （3）静态成员函数主要用来f访问静态数据成员而不能访问非静态成员 ","date":"2025-01-13T16:24:31+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-statiic/","title":"C\u0026C++ Statiic"},{"content":"【关于C和C++混合编程中编译和链接的问题】https://www.bilibili.com/video/BV1Zm4y1E7nm?vd_source=5a0790755035f26a67935abfbfcdfd5b\nextern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园\nC++\u0026ndash;名字修饰_c++的函数名修饰是在哪个阶段进行的-CSDN博客\nC/C++ 函数签名与名字修饰（符号修饰）-CSDN博客\nC/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n符号修饰 在C/C++中，一个程序要运行起来，需要经历以下几个阶段：预处理、编译、汇编、链接。\n名字修饰（Name Mangling）是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过一定算法，重新修饰为一个全局唯一的名称。\n由于C++和C的名字修饰规则不同（不同操作系统下的编译器的名字修饰方式也会不同），导致C++可以支持函数重载，而C不支持函数重载\n可以简单理解，c++中支持函数重载，c语言不支持函数重载，这造成了c++和c语言的函数名解析不同（名字修饰/符号修饰）。c语言函数名就是函数名，c++的函数名是函数名+参数组合起来的。\nC与C++符号修饰的实例 extern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园 （直接copy自该博客）\n比如，函数void func(double a) 在C和C++中的编译阶段函数名称会被解析成什么呢？\n在C语言中，由于没有名称修饰，所以在编译时函数名称仍然是func，不会因为参数类型或数量而改变。\n在C++中，由于名称修饰的存在，函数名称在编译阶段会被编译器转换成一个包含函数原型信息的唯一标识符。通常会涉及函数返回类型、参数类型以及参数数量。以GCC(GNU Compiler Collection)为例，func(double a)会被转换成_Z4funcd ，这里：\n_Z：是GCC用来表示修饰名称的前缀 4：表示函数名称func的的字符数 d：是double类型的编码 因此，用c++的方式去寻找c语言的符号是无法寻找到的。extern \u0026quot;C\u0026quot;为何可以做到？\nextern \u0026quot;C\u0026quot;的作用就是修改了符号表的生成方式，将c++符号的生成方式换成了c的生成方式。\n即 c库中生成的符号是c编译器的符号， 因此c语言可以直接链接。而c++程序需要使用extern \u0026quot;C\u0026quot;让编译器使用c的符号命名方式去进行链接，这样才能找到对应的符号。\nextern \u0026ldquo;C\u0026rdquo; C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n看这一篇就够了 看实例\ncpp调用c，cpp编译时会有C++的符号修饰，导致链接C库的函数找不到，需要用extern \u0026ldquo;C\u0026quot;告诉g++编译器以C语言的风格进行编译 c调用cpp（不涉及C++的类和成员函数），设计一个C的接口，接口的实现在cpp中，接口函数内部去使用C++的特性 c中调用c++成员函数，需要一个接口函数 ","date":"2025-01-13T16:17:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E7%9A%84%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0/","title":"C++ 的名字修饰（符号修饰）"},{"content":"作用 如果一个变量被const修饰，那么它的值就不能再被改变\nconst的优点 （1）可以保护被修饰的东西，防止意外修改，增强程序的健壮性\n（2）编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高\nconst修饰局部变量 1 2 const int n=5; int const n=5; 这两种写法是一样的，都是表示变量n的值不能被改变了，需要注意的是，用const修饰变量时，一定要给变脸初始化，否则之后就不能再进行赋值\nconst 修饰指针 1.常量指针 常量指针是指针指向的内容是常量，可以有一下两种定义方式\n1 2 const int * n; int const * n; 注意： （1）常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的\n（2）常量指针指向的值不能改变，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址\n2.指针常量 指针常量是指指针本身是个常量，不能再指向其他的地址\n1 int *const n; 需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改\n3.指向常量的常指针 指向常量的常指针是以上两种的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值\n1 const int* const p; const修饰函数的参数 1.防止修改指针指向的内容\n1 void StringCopy(char *strDestination, const char *strSource); 其中 strSource 是输入参数，strDestination 是输出参数 给 strSource 加上 const 修饰后，如果函数体内的语句试图改动 strSource 的内容，编译器将指出错误\n2.防止修改指针指向的地址\n1 void swap ( int * const p1 , int * const p2 ) 指针p1和指针p2指向的地址都不能修改\n","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-const/","title":"C\u0026C++ const"},{"content":"基于菜鸟教程写的个人笔记\n存储类 存储类定义了C程序中变量/函数的存储位置，生命周期，作用域\nauto register static extern 1.auto存储类 auto存储类是所有局部变量默认的存储类 定义在函数中的变量都默认为auto存储类 它们在函数开始时被创建，在函数结束时被销毁\n1 2 3 4 { int month ; auto int month ; } auto只能修饰局部变量\n2.register存储类 register存储类用于定义存储在寄存器上，而不是RAM中的局部变量 register存储类定义存储在寄存器，变量访问速度更快，不能直接地取地址（因为它存储在RAM中）\n1 2 3 { register int miles ； } 寄存器一般用于需要快速访问的变量\n3.static存储类 （1）static作用于局部变量 a.使局部变量在程序生命周期内都存在，不需要每次进入和离开其作用域（函数）的时候创建（重新分配内存）和销毁。 b.使用static修饰局部变量可以在函数调用之间保持局部变量的值\nstatic作用的变量，静态局部变量存储在静态（全局）存储区\n（2）static作用于全局变量 当static修饰全局变量时，会使变量的作用域限制在声明它的文件内\n（3）静态变量的特性 静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; /* 函数声明 */ void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main() { while (count--) { func1(); } return 0; } void func1(void) { /* \u0026#39;thingy\u0026#39; 是 \u0026#39;func1\u0026#39; 的局部变量 - 只初始化一次 * 每次调用函数 \u0026#39;func1\u0026#39; \u0026#39;thingy\u0026#39; 值不会被重置。 */ static int thingy=5; thingy++; printf(\u0026#34; thingy 为 %d ， count 为 %d\\n\u0026#34;, thingy, count); } 实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置\n当上面的代码被编译和执行时，它会产生下列结果：\n1 2 3 4 5 6 7 8 9 10 thingy 为 6 ， count 为 9 thingy 为 7 ， count 为 8 thingy 为 8 ， count 为 7 thingy 为 9 ， count 为 6 thingy 为 10 ， count 为 5 thingy 为 11 ， count 为 4 thingy 为 12 ， count 为 3 thingy 为 13 ， count 为 2 thingy 为 14 ， count 为 1 thingy 为 15 ， count 为 0 4.extern存储类 extern存储类用于定义在其他文件中声明的全局变量或函数 当使用extern关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义\nextern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n第一个文件 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; extern int count; void write_extern(void) { printf(\u0026#34;count is %d\\n\u0026#34;, count); } 结果 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：\n1 $ gcc main.c support.c 这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：\n1 count is 5 ","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/c%E5%AD%98%E5%82%A8%E7%B1%BB/","title":"C存储类"}]