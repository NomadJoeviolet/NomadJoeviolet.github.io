[{"content":"（stm32之HAL库）UART工作在DMA模式要打开串口中断吗？_hal uart dma-CSDN博客\n10 通用同步异步收发器（USART） - 知乎\n串口简介 串口是串行接口的简称 常用串口：RS232,RS485,USB(Universal Serial Bus)通用串行接口,TTL串口 TTL是Transistor-Transistor Logic的简写，是一种电平逻辑，晶体管-晶体管逻辑\nUSART简介 USART，即通用同步/异步收发传输器（Universal Asynchronous Receiver/Transmitter)，是单片机上的一个外设\nUART遵循异步串行通信协议的，USRT遵循同步串行通信协议\n异步不需要统一时钟信号，同步需要统一时钟信号\n一般使用最多的是UART，我们此次学习也是针对UART\nUART通信协议 起始位：发出1位低电平信号，表示开始传输字符 数据位：真正发送的数据，一般为8位（1个字节），常采用ASCII编码，从最低位开始发送 校验位：用于检验接收到的数据是否正确，分为奇校验和偶校验 停止位：一组数据的结束传输的标志。可以是1位、1.5位、2位的高电平 空闲位：空闲时数据线为高电平状态，代表无数据传输 波特率：衡量传输速率的指标。UART通信中波特率等于比特率 UART发送/接收机制 UART发送端口，首先是CPU将数据放入数据发送寄存器，然后发送移位寄存器会将数据从数据发送寄存器 取出进行移位并通过UART_TX发送出去\nUART接收端口，首先是UART_RX接收串行数据至接收移位寄存器，接收移位寄存器将串行数据移位变换为并行数据给数据接收寄存器，再通过APB总线给STM32内部\nUART模式 轮询模式 CPU不断查询发送数据寄存器或者接受数据寄存器导致程序的阻塞\n发送 在UART底层有发送移位寄存器和发送数据寄存器，发送数据时，需要CPU将发送数据寄存器的数据移动至发送移位寄存器，然后UART按照指定的波特率发送数据，CPU则不断查询数据发送寄存器是否空，如果空则需要移动数据进来\n接收 在UART底层有接收移位寄存器和接收数据寄存器，接收数据时，UART按照指定的波特率接收数据至接收移位寄存器，然后数据会存储在接收数据寄存器，CPU则不断查询数据接收寄存器是否有数据，如果有数据，CPU会把寄存器的数据移动至我们用来接收数据的变量的内存里\n当HAL_UART_Receive执行完成，我们就可以知道数据接收完成\n中断模式 使用中断模式时，需要先配置UART的NVIC中断设置\n底层中断实现数据每传送一字节，召回CPU继续运输数据，不需要我们考虑，HAL库底层已经帮我们实现 上层中断实现数据接收完成后的数据处理，通过中断回调函数实现，需要我们自己设计\n发送 CPU将数据送入 发送数据寄存器，然后就去执行其他代码，当发送移位寄存器的数据发送后，发送数据寄存器空，会触发发送数据寄存器空中断，CPU再次将数据送入 发送数据寄存器，然后又去执行其他代码，所有数据发送完成后会触发 传送完成中断，调用HAL_UART_TxCpltCallback中断回调函数\n接收 CPU在处理其他代码，接收移位寄存器将一帧数据移动至 接受数据寄存器后，会触发 接收数据寄存器非空中断，CPU会回来将 接收数据寄存器 的数据移动至我们用来接收数据的变量的内存里，然后又去执行其他代码，所有数据完成后会调用_HAL_UART_RxCpltCallback_中断回调函数处理接收的数据\n而执行HAL_UART_Receive_IT后，我们不能直接对数据继续处理，数据还没接收完成，因为CPU不会进入阻塞态，会去执行其他代码，需要通过HAL_UART_RxCpltCallback回调函数处理接收的数据\nDMA模式 DMA，全称为Direct Memory Access，直接内存访问，本质是将传输数据从一个内存空间搬运至另一个内存空间，可以用来提供外设和内存，内存和外设之间的高速数据传输\nDMA模式中也会有中断参与，在Cube配置中需要开启中断\n发送 在普通的轮询USART中，CPU一直在等待外设发送数据，外设每发送一帧数据，CPU就从内存中移动一帧数据到外设的寄存器\n在中断的USART中，外设每从寄存器中发送一帧数据，就会触发一次发送数据寄存器空中断，使CPU回来将数据从内存搬运至外设的寄存器中\n没有DMA的话，CPU会作为数据发送的中转站，而使用DMA的话，整个数据传输过程不需要CPU的参与，由DMA代理执行，DMA负责将内存数据搬运至外设的传输寄存器\n接收 在普通的轮询USART中，CPU一直在询问外设是否接收完数据，外设接收一帧数据，该位数据由CPU从外设的数据接收寄存器运进内存，CPU再次询问外设是否接收完数据，再运，直至整个数据接收完成\n而在中断USART中，外设每接收一帧数据，触发一次数据接收寄存器非空中断，CPU过来将数据从寄存器搬运至内存，所有数据接收完成后，会调用接收完成中断回调函数（HAL_UART_RxCpltCallback）\n没有DMA的话，CPU会作为数据转运的中转站，而使用DMA的话，整个数据转运过程不需要CPU的参与，由DMA代理执行\nCube配置解析 基础参数配置 Baud Rate：波特率 Word Length：包含校验位在内的数据包长度 Parity：奇偶校验位 Stop Bits：停止位位数 Data Direction：发送和 NVIC配置 如果使用中断模式，需要在NVIC settings开启USARTi global interrupt DMA配置 Add：选择添加USARTi_RX的DMA或者USARTi_TX的DMA Delete：删除对应的DMA Mode：选择normal模式或者circular模式 Data Byte：数据传输的位数 Increment Address：开启地址自增，外设只有一个寄存器，地址固定，不需要开启地址自增，而内存中我们存数据的变量是数组，接受一字节数据后需要往后移，需要开启地址自增 Priority：优先级设置 Direction：方向，固定死的 GPIO配置 一般用来查看引脚的GPIO配置，不需要更改（有特殊需求时，可以按需修改） 在GPIO Settings处可以查看TX和RX的GPIO引脚配置，此处可以看到RX为输入模式，无上拉无下拉\nHAL库UART常用函数 轮询模式 1 2 HAL_UART_Receive(\u0026amp;huart1, rxBuffer, 16 , HAL_MAX_DELAY);//接收 HAL_UART_Transmit(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) , 100 );//发送 中断模式 只能接收一次，接收完成后需要再次开启\n1 2 3 4 5 6 7 HAL_UART_Receive_IT(\u0026amp;huart1, rxBuffer, 16 );//接收 HAL_UART_Transmit_IT(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) );//发送 //回调函数 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { } DMA模式 （stm32之HAL库）UART工作在DMA模式要打开串口中断吗？_hal uart dma-CSDN博客\n1 2 3 4 5 6 7 HAL_UART_Receive_DMA(\u0026amp;huart1, rxBuffer, 16 );//接收 HAL_UART_Transmit_DMA(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) );//发送 //回调函数 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { } HAL库中使用的HAL_UART_Transmit_DMA，HAL_UART_Receive_DMA等都有中断的参与，需要在Cube中开启中断\nDemo 接收定长数据Nomad_violet，同时在主函数中翻转小灯\n轮询实现数据收发 Cube配置 模式选择为异步\n波特率选择115200 Bit/s，其余不动即可\n将PA8配置为GPIO_Output\nGPIO配置保持默认即可\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026#34;string.h\u0026#34; #define rxBufferLen 16 #define txBufferLen 25 uint8_t rxBuffer[rxBufferLen] ; uint8_t txBuffer[txBufferLen] = \u0026#34;to feel,to experience \u0026#34;;// 去感受，去经历「感其生，历其境」 int main(void) { HAL_Init(); SystemClock_Config(); MX_GPIO_Init(); MX_USART1_UART_Init(); while (1) { HAL_UART_Receive(\u0026amp;huart1, rxBuffer, rxBufferLen , HAL_MAX_DELAY); if( !strcmp( (char *)rxBuffer , \u0026#34;Nomad_violet\u0026#34; ) ) { HAL_UART_Transmit(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) , 100 ); } HAL_GPIO_TogglePin(GPIOA , GPIO_PIN_8 ); HAL_Delay(500); } } 中断实现数据收发 Cube配置 配置同上，只需额外开启中断即可\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;string.h\u0026#34; #define rxBufferLen 16 #define txBufferLen 25 uint8_t rxBuffer[rxBufferLen] ; uint8_t txBuffer[txBufferLen] = \u0026#34;to feel,to experience \u0026#34;;// 去感受，去经历「感其生，历其境」 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart == \u0026amp;huart1) { if( !strcmp( (char *)rxBuffer , \u0026#34;Nomad_violet\u0026#34; ) ) { HAL_UART_Transmit(\u0026amp;huart1 , txBuffer , sizeof(txBuffer) , 100 ); } HAL_UART_Receive_IT(\u0026amp;huart1, rxBuffer, rxBufferLen ); } } int main(void) { HAL_Init(); SystemClock_Config(); MX_GPIO_Init(); MX_USART1_UART_Init(); HAL_UART_Receive_IT(\u0026amp;huart1, rxBuffer, rxBufferLen ); while (1) { HAL_GPIO_TogglePin(GPIOA , GPIO_PIN_8 ); HAL_Delay(500); } } ","date":"2025-06-27T14:53:35+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32uart%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/","title":"STM32————UART串口通信"},{"content":"【STM32】HAL库 STM32CubeMX教程七\u0026mdash;PWM输出(呼吸灯)_stm32 hal pwm-CSDN博客\nSTM32CubeIde中互补PWM配置项的详细解读_ch idle state-CSDN博客 基于上述博客以及keyskingSTM32教程写的个人学习文档 【【STM32入门教程】应该是全B站最好的STM32教程了！！】https://www.bilibili.com/video/BV12v4y1y7uV?vd_source=5a0790755035f26a67935abfbfcdfd5b\n定时器简介 HAL库开启定时器的基本函数 开启定时器\n1 2 HAL_TIM_Base_Start(\u0026amp;htim1);//仅开启定时器 HAL_TIM_Base_Start_IT(\u0026amp;htim1);//开启定时器和中断 1 2 HAL_TIM_Base_Stop(\u0026amp;htim1);//关闭定时器 HAL_TIM_Base_Stop_IT(\u0026amp;htim1);//既关闭定时器，同时关闭中断 框架 解释整个TIM外设的构成 计数信号来源 有内部时钟以及外部时钟 内部时钟模式 在f103c8t6中，TIM1是高级定时器，TIM2，TIM3，TIM4是通用计时器\nCubeMX参数配置 Prescaler:预分频，实际分频数是number+1 Counter Mode:计数模式设置 Counter Period:自动重装载计数器计数值 Internal Clock Division:内部时钟预分频 Repetiton Counter:重复计数器 (RCR -8 bits)，属于高级控制寄存器专用寄存器位，利用它可以非常容易控制输出 PWM 的个数，与内部时钟模式无关 auto-reload preload:是否开启影子寄存器模式 还需要开启定时器更新中断\n代码实现 用的PA2作GPIO输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {//中断回调函数 if( htim == \u0026amp;htim1 ) { HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_2); } } int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM1_Init(); /* USER CODE BEGIN 2 */ HAL_TIM_Base_Start_IT(\u0026amp;htim1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 外部时钟模式 【【STM32】动画讲解定时器外部时钟 \u0026amp; 实战传送带测速装置】https://www.bilibili.com/video/BV1N94y1u7Uz?vd_source=5a0790755035f26a67935abfbfcdfd5b\n__HAL_GET_COUNTER(\u0026amp;htim)获取计数值\n外部时钟模式2 在Clock Source处选择\n注意外部时钟的滤波器Clock Filter，输入滤波 输入滤波，极性选择，预分频器\n采样频率等于内部时钟的频率\n一般推荐选择1110（15）\n外部时钟模式1 通过定时器的Slave Mode 进行选择 启用从模式，选择外部时钟模式1 选择Trigger Source时，就是选择什么方式来外部计数 就是选择触发器的来源 TI_ED是双边沿触发，且只能是双边沿触发\n使用外部计数ETR 可以在外部时钟模式1下，Trigger Source选择ETR1 芯片上会有引脚被设置为ETR1\n直接选择外部时钟模式2，引脚上会自动有一个ETR2 关于定时器的事件更新中断 关于定时器中断 计数值到达自动重装载值时，触发更新中断 在Cube中开启global interrupt 关于MX_TIM2_Init()启动时会将中断标志位置1 在MX_TIM2_Init()时，会将定时器更新中断标志位置1，在调用HAL_TIM_Base_Start_IT后，NVIC会检测到更新中断标志位被置1，会立马触发中断\n在HAL_TIM_Base_Start_IT前选择下面两个函数其中一个写上即可 事件更新中断的逻辑 先是NVIC中断向量表查找到TIM2_IRQhandler，在该函数中，调用了HAL_TIM_IRQhandler函数 其中的事件更新处理的代码(HAL库中HAL_TIM_IRQHandler中的处理事件更新中断的代码) 判断标志位，判断是否开启事件更新中断，清零标志位，调用HAL_TIM_PeriodElapsedCallback函数\n定时器的从模式 【【STM32】一看就懂的定时器从模式讲解】https://www.bilibili.com/video/BV1mU421o7vt?vd_source=5a0790755035f26a67935abfbfcdfd5b\n定时器从模式\nReset Mode 复位模式 Gate Mode 门模式 Trigger Mode 触发模式 复位模式 设定为复位模式时\n选取计数信号，计数信号可以时内部时钟，也可以是外部时钟模式2（不是从模式控制器下外部时钟模式1） 触发器的信号，每出现一次，执行一次复位操作（向上计数模式恢复为0，向下计数模式恢复为自动重装载值） 例子：选取计数信号为内部时钟，计数器不断计数，当触发器信号来临时（TI1的TIFP1检测到信号上升沿），则触发一次更新事件，计数器值复位 注意：如果开启定时器的事件更新中断，触发器信号也会触发事件更新中断\n复位模式下的从模式控制器，在接收到触发信号后，就会让计数器重新开始计数，并且会触发定时器更新中断\n如何判断事件更新中断的产生原因 在复位模式中，需要区分事件更新中断是触发信号的复位导致还是自动挡重装载时导致\n从模式收到触发信号后，会设置触发器中断标志位，可以借此来区分中断原因\n使用该函数来获取触发器中断标志位 1 __HAL_TIM_GET_FALG(htim,TIM_FLAG_UPDATE)//可以获取定时器对应标志位的值 TIM_FLAG_TRIGGER是触发器中断标志位\n1 __HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER) 使用上述语句可以获取其标志位 使用时需要注意，HAL库为了方便我们判断，并不会对该标志位清零，所以在获取标志位的值后，需要对其进行清零\n1 2 3 if(__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)==SET) { __HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER); } HAL_TIM_PeriodElapsedCallback回调函数\n1 2 3 4 5 6 7 8 9 10 11 void HAL_TIM_PeriodElapsedCallback( TIM_HandleTypeDef *htim ) { if( htim == \u0026amp;htim2 ) { if( __HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER) == SET ) {//获取触发标志位，用来区分复位引起的中断还是自动重装载引起的中断 __HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER); HAL_UART_Transmit( \u0026amp;huart2 , (uint8_t*)triggerMsg , strlen(triggerMsg) , 100 ); } else { HAL_UART_Transmit( \u0026amp;huart2 , (uint8_t*)updateMsg , strlen(updateMsg) , 100 ); } } } 关于MX_TIM2_Init()启动时会将中断标志位置1 在MX_TIM2_Init()时，会将定时器更新中断标志位置1，在调用HAL_TIM_Base_Start_IT后，NVIC会检测到更新中断标志位被置1，会立马触发中断\n在HAL_TIM_Base_Start_IT前选择下面两个函数其中一个写上即可 事件更新中断的逻辑 先是NVIC中断向量表查找到TIM2_IRQhandler，在该函数中，调用了HAL_TIM2_IRQhandler函数 其中的事件更新处理处的代码(HAL库中HAL_TIM_IRQHandler中的处理事件更新中断的代码) 判断标志位，判断是否开启事件更新中断，清零标志位，调用HAL_TIM_PeriodElapsedCallback函数\n门模式 如果TI1的TI1FP1为上升沿检测，则是当触发信号是高电平时，时钟信号可以正常进入定时器，定时器能正常计数 当触发信号时低电平时，门关闭，时钟信号不能正常进入定时器，定时器停止计数 若将触发器的极性改为检测下降沿的话，门的控制作用则相反 触发器的极性选择 需要注意，在门模式情况下，上升下降沿的时刻，也会将触发器中断标志位置1，但是不会触发事件更新中断（因为没有对计数值进行复位，就不会触发事件更新中断） 触发模式 在检测到设定的边沿后，让定时器开始计数 开始后不能设定停止 触发模式仅能启动定时器，并不能停止计数器计数\n一般配合计时器的单脉冲模式使用 单脉冲模式，是指计数器计数到重装载计数值后，就停止计数（不再循环计数） 一般需要勾选单脉冲模式\n三种模式的总结 Trigger Source 触发源的滤波器设置 在有触发源的时候，对触发源的信号的滤波设置 定时器的输入捕获 软件层面上的模拟 在软件层面检测Echo端的电平高低，进行计时，到那时再极高精度要求的情况则 力不足\n输入捕获的概括 硬件在检测到上升或者下降沿时，就记录计数器值到捕获寄存器\n输入捕获的运行机制 在TI1检测到上升沿时，捕获寄存器立即复制计数器的值 还可以开启输入捕获中断，输入捕获后，启动中断，可以快速处理捕获寄存器上的值\n一个通道只能进行一种边沿检测 捕获的模式 注意：TI3和TI4没有接入从模式控制器中 TI1和TI2是一对，可以相互借用 TI3和TI4是一对，可以相互借用 Cube上的配置 注意设置边沿检测 打开捕获中断 启动，该例子中是需要在CHANNEL4捕获到后进行处理，所以CHANNEL44开启了中断 输入捕获的开启 可能遇到的问题 ![[Pasted image 20250105120132.png]] 用SET_COUNTER来清零一下\n中断回调函数\n1 HAL_TIM_IC_CaptureCallback(htim); 回调函数的代码编写 判断是否是TIM1，判断是否是TIM1的4通道（HAL_TIM_ACTIVE_CHANNEL_4） 再读取指定寄存器的值\n定时器的输出比较模式 较为鸡肋，对这些模式能理解其行为即可\n定时器的PWM 【STM32】HAL库 STM32CubeMX教程七\u0026mdash;PWM输出(呼吸灯)_stm32 hal pwm-CSDN博客\nSTM32CubeIde中互补PWM配置项的详细解读_ch idle state-CSDN博客\nPWM 脉冲宽度调制，用数字信号去模拟 模拟信号 PWM模式 PWM模式1 是 计数器值 小于 比较器值 时输出有效电平 PWM模式2 是 计数器值 大于 比较器值 时输出有效电平 Cube配置 为实现一个呼吸灯，进行以下配置 PWM的频率为1000Hz，最大计数值为1000-1\n基础时钟配置\n预分频器值，计数模式选择（向上计数模式，向下计数模式，中央对齐模式），自动重装载值，内部时钟分频，重复计数器值，是否开启影子寄存器\nPWM配置\nMode：选择PWM模式 Pulse：设置比较寄存器的值 Output compare preload：是否开启影子寄存器 Fast Mode：是否需要输出非常高频的PWM信号 CH Polarity：设置有效电平极性 CH Idle State：空闲时，PWM通道的输出 HAL库PWM常用函数 1 2 3 HAL_TIM_PWM_Start(\u0026amp;htim1,TIM_CHANNEL_1);//开启PWM HAL_TIM_PWM_Stop(\u0026amp;htim1,TIM_CHANNEL_1);//关闭PWM __HAL_TIM_SET_COMPARE(\u0026amp;htim1,TIM_CHANNEL_1,num);//设置比较寄存器的值 使用PWM控制流水灯 PWM的频率为1000Hz，最大计数值为1000-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM1_Init(); /* USER CODE BEGIN 2 */ HAL_TIM_PWM_Start(\u0026amp;htim1,TIM_CHANNEL_1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { for( int i = 0 ; i \u0026lt; 1000 ; ++ i ) { __HAL_TIM_SET_COMPARE(\u0026amp;htim1,TIM_CHANNEL_1,i); HAL_Delay(0); } for( int i = 1000-1 ; i \u0026gt;= 0 ; -- i ) { __HAL_TIM_SET_COMPARE(\u0026amp;htim1,TIM_CHANNEL_1,i); HAL_Delay(0); } /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 编码器的使用 待完成\n","date":"2025-06-26T17:26:06+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32tim%E5%AE%9A%E6%97%B6%E5%99%A8/","title":"STM32————TIM定时器"},{"content":"一文轻松理解内存对齐 - 知乎\n结构体（struct）对齐 规则 1：成员地址 = min(自身对齐值, 有效对齐值) 的倍数\n规则 2：结构体总大小 = 最大成员对齐值的整数倍\n规则 3：成员排列顺序影响最终大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #pragma pack(1)//设置默认对齐数为1 struct S1 { char c1; int i; char c2; }; #pragma pack()//取消设置的默认对齐数，还原为默认 int main() { //输出的结果是什么？ printf(\u0026#34;%d\\n\u0026#34;, sizeof(struct S1)); return 0; } 1 2 3 4 5 6 7 #pragma pack(push, 1)//设置默认对齐数为1 struct MyStruct { char a; int b; double c; }; #pragma pack(pop)//取消设置的默认对齐数，还原为默认 1 2 3 4 5 struct MyStruct { char a; int b; double c; } __attribute__((packed)); ","date":"2025-06-26T15:35:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%9E%81%E7%AE%80%E7%89%88/","title":"C\u0026C++ 内存对齐（极简版）"},{"content":"MDK介绍及其使用 一文教你使用MDK开发工具-CSDN博客\nMDK、KEIL、uVision 之间的区别\nMDK（ Microcontroller Development Kit ），也称 MDK-ARM 、KEIL MDK、KEIL For ARM，都是同一个东西。ARM 公司现在统一使用 MDK-ARM 的称呼，MDK 的设备数据库中有很多厂商的芯片，是专为微控制器开发的一款工具，为满足基于 MCU 进行嵌入式软件开发的工程师需求而设计，支持 ARM7，ARM9，Cortex-M4/M3/M1，Cortex-R0/R3/R4 等 ARM 微控制器内核。KEIL 是公司的名称，有时候也指 KEIL 公司的所有软件开发工具。Keil 公司在2005年被 ARM 公司收购。\nuVision 是 KEIL 公司开发的一个集成开发环境（IDE）。它包括工程管理，源代码编辑，编译设置，下载调试和模拟仿真等功能，uVision 有 uVision2、uVision3、uVision4 和 uVision5 四个版本，目前最新的版本是 uVision5。它提供一个环境，让开发者易于操作。uVision 通用于 KEIL 的开发工具中，例如 MDK，PK51，PK166，DK251等。\narmclang 就是俗称的AC6 armclang是ARM公司提供的一款C/C++编译器，专门用于为ARM架构的处理器生成高性能代码。该编译器通常与ARM的其他工具链一起使用，适合嵌入式系统开发。\n请注意，确保在项目中使用合适的工具和版本，并根据需求查阅最新的文档。\nOpenOCD 跟我一起学OpenOCD(一) - 知乎 (zhihu.com)\nOpenOCD是一个开源的调试/编程工具，主要用于嵌入式系统，它支持多种硬件设备和调试协议，如JTAG和SWD。它通常与GNU工具链结合使用，可以为开发人员提供硬件调试和烧录固件的功能。\nOzone Ozone使用介绍-基础功能 - 开发环境 - 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)\nMinGW mingw 是一个为 Microsoft Windows 平台编译和运行 Unix 程序的工具套装，它提供了类似于 Unix 环境下的编译器、链接器等工具，以便在 Windows 平台上开发使用 GCC（GNU 编译器集合）和其他开源 Unix 工具的软件。\narm-none-eabi-gcc arm-none-eabi-gcc 是一个专为 ARM 架构的嵌入式系统设计的 GCC 编译器版本。它可以生成裸机代码，适用于没有操作系统的应用程序。开发者常用它来编译针对 ARM Cortex 和其他 ARM 设备的软件。\narm-none-eabi-gcc 和 armclang的区别 arm-none-eabi-gcc 和 armclang 是两种不同的编译工具链，主要用于嵌入式系统中基于 ARM 处理器的代码编译。它们之间存在一些关键的区别，以下是它们各自的特点及区别的简要概述：\n开发者和背景：\narm-none-eabi-gcc: 是 GNU 编译器集合（GCC）的一个变体，专门用于 ARM 处理器。这个工具链是开源的，由 GNU 项目支持。 armclang: 是 ARM 公司推出的编译器，属于 ARM Compiler 工具链的一部分。ARM Compiler 6及更高版本基于开源的 LLVM/Clang 技术，但包含许多 ARM 提供的专有优化和扩展。 编译技术和优化：\narm-none-eabi-gcc: 利用 GCC 的优化技术，提供了广泛的架构支持和成熟的优化方法。 armclang: 使用 LLVM 编译技术框架，通常提供更现代的优化策略和更好的代码生成质量，尤其是在 C++ 的高级特性支持方面。 语言支持：\n两者都支持主要的编程语言如 C 和 C++。但是，由于 ARM Compiler 包括来自 LLVM/Clang 的优势，armclang 可能在支持最新 C++ 标准方面有更好的表现。 调试和错误信息：\narmclang 通常提供更详细的错误和警告信息，这可以使调试过程更加高效。 arm-none-eabi-gcc 的错误信息较为传统，但由于广泛使用，网上有大量关于其调试的资源和社区支持。 生态系统和集成：\narm-none-eabi-gcc 由于是开源和免费，被广泛应用于多种开发环境和项目中。其生态系统非常成熟，有大量的第三方库和工具支持。 armclang 尽管集成了许多 ARM 特定的优化，但作为商业产品，可能在使用上不如 GCC 灵活，特别是在版权和许可证管理方面。 性能：\n性能比较并不绝对，依赖于具体的应用场景和代码特性。在某些情况下，armclang 生成的代码运行效率更高，而在其他情况下，arm-none-eabi-gcc 可能表现得更好。 在选择哪一个编译器进行项目开发时，需要考虑多个因素，如团队的熟悉度、项目需求对优化的依赖程度、成本（尤其是 armclang 可能涉及的许可成本）以及与其他工具的兼容性等。\nclangd clangd是llvm项目推出的C++语言服务器，通过LSP(Language Server Protocal)协议向编辑器如vscode/vim/emacs提供语法补全、错误检测、跳转、格式化等等功能。C++的LSP曾经是cquery, ccls, clangd三足鼎立。但是clangd支持clang-tidy实时检查的功能是另外两者不具备的，而且cquery和ccls都是单个开发者主导的项目，clangd背后则是有llvm的背书。目前来看，“姓赵”的clangd在这场c++ lsp赛跑中已经有了不小的领先优势。\nVScode的IntelliSense IntelliSense 是 VS Code 提供的智能代码补全和理解功能，它结合了代码补全、参数信息、快速信息和成员列表等功能，极大地提高了开发效率。\nIntelliSense 的核心组成\n代码补全 (Code Completion) 输入时自动显示建议列表 包含变量、函数、类、方法等 支持模糊匹配 (如输入 fs.rm 可匹配 fs.rmdir) 参数提示 (Parameter Hints) 显示函数参数信息 当前参数位置高亮显示 函数重载时可通过箭头切换 快速信息 (Quick Info) 悬停时显示符号定义 包含文档注释、类型信息等 错误检查 (Error Checking) 实时语法检查 类型错误检测 未定义符号提示 IntelliSense 的工作原理 VS Code 通过以下方式提供 IntelliSense：\n基于词法分析：简单的文本匹配补全 基于语言服务器协议 (LSP)：通过语言服务器获取深度分析 基于 TypeScript/JavaScript 的 TS Server：专为 JS/TS 优化 基于标签 (Tag Parser)：如 C/C++ 扩展使用的方案 交叉编译器 arm 交叉编译器各种gcc 傻傻分不清楚：gnueabi,gnueabhf,none-eaib - 知乎\n交叉编译工具链的命名规范 arch [-vendor] [-os] [-(gnu)eabi]\narch : 架构的意思，如ARM ，MIPS\nvendor： 工具链的提供厂商\nos： 支持的操作系统\neabi：嵌入式应用二进制接口（Embedded Application Binary Interface）\narm gcc还分为 是否支持操作系统 支持操作系统： arm-none-linux-eabi-gcc 不支持操作系统： arm-none-eabi-gcc none表示vendor是none，也就是不属于某一公司的\nABI 和 EABI ABI：二进制应用程序接口(Application Binary Interface (ABI) for the ARM Architecture)。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。\nEABI：嵌入式ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。\n两者主要区别是，ABI是计算机上的，EABI是嵌入式平台上（如ARM，MIPS等）\nninja，make，cmake cmake cmake是一个生成 .ninja 和 .makefile 的工具。cmake只需要用户通过对源码文件的简单描述（就是CMakeLists.txt文件），就能自动生成一个project的makefile文件或者ninja文件，然后就可以通过ninja或者make进行启动编译了，很多IDE都在用cmake作为项目管理工具。\nmake与ninja make功能强大，可以给人看，ninja启动速度快，项目构建速度快，但不是给人看的 可以认为两者同级。\n","date":"2025-06-26T15:21:07+08:00","permalink":"https://NomadJoeviolet.github.io/p/%E5%B7%A5%E5%85%B7%E9%93%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E7%9F%A5%E8%AF%86/","title":"工具链的一些杂知识"},{"content":"中断简介 中断定义 CPU执行程序中，由于发生了某种随机的事件(外部或内部)，引起CPU暂时 中断正在运行的程序，转去执行一段特殊的服务程序(称为中断服务程序或 中断处理程序)，以处理该事件，该事件处理完后又返回被中断的程序继续 执行，这一过程称为中断 对于单片机来说\n中断事件发生 产生中断信号 单片机接收到中断信号，停止执行当前函数，跳转至中断处理函数 执行完中断处理函数后，单片机自动跳转回主函数执行被中断处 NVIC NVIC是嵌套向量中断控制器，控制着整个芯片中断相关的功能，它跟内核紧密耦合，是内核里面的一个外设。同时掌控中断优先级和中断向量表。\n中断流程 请求挂起寄存器的改变由外设导致 中断信号传递至NVIC，然后NVIC查找对应中断向量，执行中断处理函数 另外中断处理函数都需要去清除请求挂起寄存器对应位，避免中断处理函数被重复调用 HAL库的中断处理及回调函数实现流程 首先是外设发出中断请求信号，NVIC接收到后会根据中断向量表查询对应中断处理函数的入口，在HAL中是对应外设的外设number_IRQHandler，然后再进入HAL库统一的外设中断处理函数HAL_外设_IRQHandler，再调用对应的回调函数 NVIC嵌套向量中断控制器 NVIC会一直检测某一个中断线是否处于激活状态，当中断处理函数运行完成后，需要在中断处理函数中将请求挂起寄存器对应的位清除为0，避免NVIC一直检测到0，一直重复执行中断处理函数，而这一部分代码，在HAL库写的总IRQHandler中已经完成。\n另外，NVIC对于中断还有中断优先级的设置，stm32f103c8t6中断优先级由NVIC的优先级寄存器里的4位决定。中断优先级分为抢占优先级和响应优先级（它们一起用这4位）\n抢占优先级的级别越高，越能够抢占中断通道，优先执行中断 2. 响应优先级的级别越高，可以优先排队。 中断的优先级，都是数字越小，优先级越高 EXTI外部中断 EXTI外部中断实现 EXTI 可分为两大部分功能，一个是产生中断，另一个是产生事件，这两个功能从硬件上就有所不同。我们的主要关注点是中断。 边沿检测电路用来检测输入的电平信号的高低电平的转换，同时会根据 上升沿/下降沿触发选择寄存器来决定是否向后产生高电平信号 软件中断事件寄存器使用软件来模拟产生一个中断 请求挂起寄存器接收到高电平后会将对应通道的位置1（例如EXTI_9产生高电平进入请求挂起寄存器，则该寄存器会将第9位置1） 最后上面的线路就会进入NVIC(嵌套向量中断控制器) 下面的线路，脉冲发生器作为事件信号送到对应外设，这个脉冲信号可以给其他外设电路使用，比如定时器TIM、模拟数字转换器ADC等等，这样的脉冲信号一般用来触发TIM或者ADC开始转换 产生中断线路目的是把输入信号输入到NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。 产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。 调用流程 以EXTI1为例，上升沿触发，当出现上升沿时，就会触发EXTI5的外部中断，进入EXTI9_5_IRQHandler，在EXTI9_5_IRQHandler中调用HAL_GPIO_EXTI_IRQHandler函数统一处理外部中断，在该函数中对挂起寄存器进行清0操作，并调用HAL_GPIO_EXTI_Callback中断回调函数\n按键实现外部中断控制小灯亮灭 Cube配置 EXTI配置 打开中断\n配置的是下降沿触发，检测下降沿，上拉模式 配置参数解释\n上升沿触发：指的是当引脚电平从低电平(0)转变为高电平(1)时，触发事件 下降沿触发：指的是当引脚电平从高电平(1)转变为低电平(0)时，触发事件 双边沿触发：指的是当引脚的电平发生任何变化（即从低电平到高电平或从高电平到低电平）时，都会触发事件 上拉：指使引脚在未连接（悬空）时默认为 高电平(1) 下拉：指使引脚在未连接（悬空）时默认为 低电平(0) GPIO配置 推挽模式，初始输出为Low低电平\n按键消抖 方式1 1 2 3 4 5 6 7 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {//外部中断回调函数 if( GPIO_Pin == GPIO_PIN_5 ) { //HAL_Delay(10); for( int i = 0 ; i \u0026lt;= 72000*100 ; ++ i );//空循环延时 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_2); } } 方式2 1 2 3 4 5 6 7 8 9 int lastTick = 0 ; void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {//外部中断回调函数 if( GPIO_Pin == GPIO_PIN_5 ) { if( HAL_GetTick()-lastTick \u0026gt; 150 ) { HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_2); lastTick = HAL_GetTick(); } } } 代码实现 1 2 3 4 5 6 7 8 9 int lastTick = 0 ; void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {//外部中断回调函数 if( GPIO_Pin == GPIO_PIN_5 ) { if( HAL_GetTick()-lastTick \u0026gt; 150 ) { HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_2); lastTick = HAL_GetTick(); } } } TIM定时器定时中断 在f103c8t6中，TIM1是高级定时器，TIM2，TIM3，TIM4是通用计时器 下面例子中配置的是TIM1，实现每秒翻转1次小灯亮灭\n调用流程 触发更新中断后进入更新中断服务函数TIM1_UP_IRQHandler，其中调用HAL_TIM_IRQHandler，在该函数中调用了HAL_TIM_PeriodElapsedCallback回调函数\nCubeMX参数配置 使用内部时钟模式\n参数配置如下，实现1s触发一次定时器更新中断\nPrescaker:预分频，实际分频数是number+1 Counter Mode:计数模式设置 Counter Period:自动重装载计数器计数值 Internal Clock Division:内部时钟预分频 Repetiton Counter:重复计数器 (RCR -8 bits)，属于高级控制寄存器专用寄存器位，利用它可以非常容易控制输出 PWM 的个数，与内部时钟模式无关 auto-reload preload:是否开启影子寄存器模式 还需要开启定时器更新中断 代码实现 用的PA2作GPIO输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if( htim == \u0026amp;htim1 ) { HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_2); } } int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM1_Init(); /* USER CODE BEGIN 2 */ HAL_TIM_Base_Start_IT(\u0026amp;htim1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } USART中断 USART的轮询模式会阻塞程序运行，浪费CPU资源\n轮询模式 CPU不断查询发送数据寄存器或者接受数据寄存器导致程序的阻塞\n发送 在UART底层有发送移位寄存器和发送数据寄存器，发送数据时，需要CPU将发送数据寄存器的数据移动至发送移位寄存器，然后UART按照指定的波特率发送数据，CPU则不断查询数据发送寄存器是否空，如果空则需要移动数据进来\n接收 在UART底层有接收移位寄存器和接收数据寄存器，接收数据时，UART按照指定的波特率接收数据至接收移位寄存器，然后数据会存储在接收数据寄存器，CPU则不断查询数据接收寄存器是否有数据，如果有数据，CPU会把寄存器的数据移动至我们用来接收数据的变量的内存里\n当HAL_UART_Receive执行完成，我们就可以知道数据接收完成 中断模式 底层中断实现数据每传送一字节，召回CPU继续运输数据，不需要我们考虑，HAL库底层已经帮我们实现 上层中断实现数据接收完成后的数据处理，通过中断回调函数实现，需要我们自己设计\n发送 CPU将数据送入 发送数据寄存器，然后就去执行其他代码，当发送移位寄存器的数据发送后，发送数据寄存器空，会触发发送数据寄存器空中断，CPU再次将数据送入 发送数据寄存器，然后又去执行其他代码，所有数据发送完成后会触发 传送完成中断，调用HAL_UART_TxCpltCallback中断回调函数 接收 CPU在处理其他代码，接收移位寄存器将一帧数据移动至 接受数据寄存器后，会触发 接收数据寄存器非空中断，CPU会回来将 接收数据寄存器 的数据移动至我们用来接收数据的变量的内存里，然后又去执行其他代码，所有数据完成后会调用_HAL_UART_RxCpltCallback_中断回调函数处理接收的数据 而执行HAL_UART_Receive_IT后，我们不能直接对数据继续处理，数据还没接收完成，因为CPU不会进入阻塞态，会去执行其他代码，需要通过HAL_UART_RxCpltCallback回调函数处理接收的数据\n","date":"2025-06-25T21:48:07+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32%E4%B8%AD%E6%96%AD/","title":"STM32——中断"},{"content":"常见名词 CPU，中央处理单元，Central Processing Unit ALU，算术逻辑单元，Arithmetic and Logic Units CU，控制单元，控制器，Control Unit CPU通常由中央处理单元，算术逻辑单元，寄存器组三部分组成 EU，执行单元，Execution Unit BIU，总线接口单元，Bus Interface Unit\nPC，程序计数器，Program Counter IR，指令寄存器，Instruction Register GR，通用寄存器，General Register\n注意$IO$端口和$IO$接口不是同一个东西\n操作系统知识：程序计数器（pc）、指令寄存器（IR）、通用寄存器（GR）、状态寄存器（SR）、程序状态字PSW_pc和ir-CSDN博客\n特殊运算符和指令 PTR用来指定存储器操作数的字长 Byte PTR[BX]\n所有单操作数指令要求操作数不能是立即数，如果是存储器操作数，需要指定字长\n微型计算机基础概论 微型计算机系统 微型计算机系统 由 硬件系统 和 软件系统 组成 硬件系统 硬件系统 由 微型计算机（主机） 和 外设组成\n微型计算机（主机）由 微处理器（CPU），存储器 ，IO接口 ，总线 组成 外设 就包括键盘，鼠标，显示器，硬盘等 软件系统 软件系统 由 系统软件 和 应用软件 构成\n微型计算机运行流程 微机运行的基本流程为，程序存储在存储器中，按程序流程自动连续取出指令并执行；自动连续的实现是程序计数器 PC 的自增；步骤可概括为取指令、译码、执行。修改 PC 指针的值，可实现程序的顺序执行、跳转、循环、过程调用和中断服务等功能。\n计算机中的数制与编码 十进制D，二进制B，十六进制H，八进制O\n有符号二进制数的表示 最高位是符号位，0表示正号，1表示负号\n原码 数值部分保持不变，最高位是符号位 反码 正数的反码与正数的原码一样 负数的反码 等于 负数原码 数值部分 按位取反 补码 正数的补码与正数的反码和原码一样 负数的补码 的符号位 与 负数原码一致，数值部分等于 负数原码 数值部分取反后再加1\n特殊数-128的补码表示为10000000\n微处理器与总线 CPU中央处理单元 CPU是微型计算机的运算和指挥控制中心 一般由ALU（运算器），CU（控制单元），寄存器组组成 CPU内还有两个独立部件：EU（执行单元）和BIU（总线接口单元） 微处理器主要性能指标 CPU的字长/位数，及其一次性能处理的位数 CPU主频，指的是CPU时钟频率\nCU控制单元 控制器的作用是控制程序的执行，是整个系统的指挥中心 具备以下功能\n指令控制 时序控制 操作控制 EU执行单元 EU负责分析指令（指令译码），执行指令 在工作时不断从BIU的指令队列取指令\nBIU总线接口单元 BIU主要功能是负责CPU与存储器，IO接口之间的信息传送 BIU可以负责取指令，取操作数，写结果 BIU内部有一个指令队列和地址加法器 地址加法器能产生20位的物理地址\nCPU程序执行步骤 从存储器取出下一条指令 指令译码 如果指令需要，从存储器中读取操作数 执行指令（算术逻辑运算，IO操作，数据传输等） 如果需要，写入存储器 核心步骤，取指令，译码指令，执行指令 工作时序 时钟周期：每个时钟脉冲持续的时间 总线周期：通过总线进行一次读或写操作的过程称为一个总线周期，一个总线周期包含多个时钟周期 指令周期：执行一条指令所需的时间，一个指令周期包含多个总线周期 一个基本的总线周期由四个时钟周期构成，若内存或 IO 接口速度较慢，则还会在 T3 后插入 Tw 等待周期。 写操作为例的总线周期 包含4个时钟周期（T1,T2,T3,T4） T1地址输出，T2缓存，T3和T4数据输出\n8088/8086 CPU 8088与8086处理器的区别 8088 外部数据线为8根（8086为16根），为准16位CPU，16 位数据要分两次传送；（ 注意：8088和8086均为16位处理 器，内部数据线均为16位，且地址总线均为20位） 指令预取队列：8088为4字节，8086为6字节\n两者均有两种工作模式，最小工作模式和最大工作模式\n8088/8086指令流水线 采用EU（执行单元）和BIU（总线接口单元）并行工作，可同时取指令，执行指令，分析指令 补充-流水线技术 在指令执行过程中，有几类指令相关影响流水线中指令的执行，使得指令不能在预先设定的执行周期中执行，造成流水线断流 相关问题 结构相关；数据相关；控制相关\n结构相关 当CPU的硬件结构不能够同时支持几条指令的执行时，这几条指令将发生结构相关，比如流水线同时访问同一个存储器\n数据相关 一条指令的执行需要上一条或者上几条指令的执行结果时 ，会造成流水线的断流现象。\n所以，当发生数据相关时，需要尽可能早的把上一条或上几条指令的执行结果 交给相关指令作为操作数。这就需要“内部前推\n控制相关 当指令执行到分支指令或者跳转指令时，将产生控制相关，此时会产生流水线断流。 解决方法：\n阻塞流水线直到确定走向 预测分支是否发生，并给予该预测执行指令 8088/8086内存分段 8088/8086内部结构为16位，为了增大内存管理能力使其能产生20位的物理地址，采用了分段管理方法\n段首地址即段基地址 20位物理地址=段基地址 * 16+段偏移地址 8088/8086内部寄存器 8088/8086内部寄存器分为 通用寄存器（8个），段寄存器（4个），控制寄存器（2个） 通用寄存器 通用寄存器包括 数据寄存器，地址指针寄存器，变址寄存器\n数据寄存器 AX（Accumulator）：累加器，常用于存放算术逻辑运算中的操作数，另外所有的IO指令都是用累加器与外设接口传送信息 BX（Base）：基址寄存器，常用来存放访问内存时的偏移地址（一般和DS一起用DS:[BX]） CX（Count）：计数寄存器，在循环和串操作指令中用作计数器 DX（Data）：数据寄存器，在寄存器间接寻址的IO指令中存放IO端口地址 都可拆分为H，L两个8位寄存器\n在做双字节乘除法运算时，DX与AX可以合起来存一个双字长的数（32位），DX存高16位，AX存低16位\n地址指针寄存器 SP（Stack Pointer）：堆栈指针寄存器，常用来存放 栈顶偏移地址 BP（Base Pointer）：基址指针寄存器，一般也用来存放访问内存时的偏移地址（一般和SS一起用SS:[BP]） BX和BP区别: (1)作为通用寄存器，二者均可用于存放数据；(2)作为基址寄存器，用BX表示 所寻找的数据在 数据段 ；用BP则表示数据在 堆栈段\n变址寄存器 SI（Source Index）：源变址寄存器 DI（Destination Index）：目的变址寄存器 段寄存器 段寄存器，用于存放段基址，即段起始地址的高16位\nCS（Code Segment）：代码段寄存器 SS（Stack Segment）：堆栈段寄存器 DS（Data Segment）：数据段寄存器 ES（Extra Segment）：附加数据段寄存器 控制寄存器 IP（Instruction Pointer）：指令指针寄存器，其内容为下一条要执行指令的偏移地址（CS段中） 标志寄存器 FLAGS：状态寄存器，16位寄存器 状态标志位 CF（Carry Flag）：进位标志位，进行加减运算时，若最高位向前有进位错位，则CF=1 PF（Parity Flag）：奇偶标志位，运算结果低8位中1的个数为偶数，PF=1 AF（Auxiliary Carry Flag）：辅助进位标志位，加减法运算，D3向D4进位时，AF=1 ZF（Zero Flag）：零标志位，运算结果为0时，ZF=1 SF（Sign Flag）：当运算结果最高位为1时，SF=1 OF（Overflow Flag）：当算术结果超出了 带符号数的范围时，即溢出时，OF=1 控制标志位\nTF（Trap Flag）：陷井标志位，也叫跟踪标志位。TF=1时，使CPU处于单步执行指令的工作方式 IF（Interrupt Enable Flag）：中断允许标志位。IF=1使CPU可以响应可屏蔽中断请求 DF（Direction Flag）：方向标志位。在数据串操作时确定操作的方向 IF=1，允许响应可屏蔽中断请求，对应指令：STI IF=0，禁止响应可屏蔽中断请求，对应指令：CLI\nDF=0，串操作指令中的地址是增加方向，对应指令：CLD DF=1，串操作指令中的地址是减少方向，对应指令：STD\nTF=1，CPU按跟踪方式（单步方式）执行程序\n8088外部引脚及其功能 最小模式下的引脚描述 按功能对引脚进行划分：\n基础工作引脚：$Vcc,GND,CLK(4.77Mhz)$ 地址总线：${AD}0-{AD}7,A_8-A{15},A{16}-A_{19}$ 数据总线：${AD}_0-{AD}_7$ 模式控制引脚：$MN/\\overline{MX}$ 读写控制引脚：$IO/\\overline M,\\overline{RD},\\overline{WR}$ 中断控制引脚：$INTR,NMI,INTA$ 复位：$RESET$ 总线保持请求/响应：$HOLD,HLDA$ 地址锁存信号：$ALE$ 外部就绪信号：$READY$ 测试信号输入：$\\overline {TEST}$ 数据传输方向控制：$DT/\\overline R$ 数据允许信号：$\\overline {DEN}$ 系统状态输出：$\\overline{{SS}_0}$（与$IO/\\overline M,DT/\\overline R$合作） 各引脚具体功能 $A_{16}-A_{19}/S_3-S_6$：地址，状态复用的引脚，三态输出。（分时复用）状态信号中$S_6$恒等于0，$S_5$指示中断允许标志位$IF$的状态，$S_4,S_5$组合指示CPU正在使用的段寄存器\n$A_8-A_{15}$：8位地址信号，三态输出\n${AD}{0}-{AD}{7}$：地址，数据分时复用的双向信号线，三态。当$ALE=1$时，这些引脚上传输的是地址信号，当$\\overline {DEN}=0$时，这些引脚上传输的是数据信号\n$IO/\\overline M$：输入输出/存储器控制信号，三态。该引脚是用来区分当前操作是访问存储器还是访问$IO$端口\n$\\overline {WR}$：写信号输出，三态。当此引脚输出为低电平时，表示CPU正在对存储器或IO端口进行写操作\n$DT/\\overline {R}$：数据传送方向控制信号，三态。高电平时，CPU向存储器或IO端口发送数据；低电平时，CPU从存储器或IO接口接收数据\n$\\overline {DEN}$：数据允许信号，三态。该信号有效时，表示 数据总线 上具有有效信号。它在每次 访问内存或IO接口以及在中断响应期间有效，常用作数据总线驱动信号\n$ALE$：地址锁存信号，三态输出，高电平有效。它为高电平时，表示CPU地址线上有有效地址\n$\\overline {RD}$：读选通信号，三态输出，低电平有效。其有效时，表示CPU正在对存储器或IO接口进行读操作\n$READY$：外部同步控制输入信号，高电平有效。它是由被访问的内存或IO设备所发出的响应信号。它为高电平时，表示存储器或IO设备已经准备好，CPU可以进行数据传送 。CPU在T3的周期采样$READY$信号，若其为低，CPU自动插入等待周期$T_w$\n$INTR$ ：可屏蔽中断请求输入信号，高电平有效。CPU在每条指令的最后一个周期采样该信号，以决定是否进入中断响应周期\n$\\overline {TEST}$：测试信号输入引脚\n$NMI$：非屏蔽中断请求输入信号，上升沿触发。这个引脚上的中断请求信号不能用让软件屏蔽，CPU在当前指令\n$RESET$：系统复位输入信号，高电平有效。\n$\\overline {INTA}$：中断响应信号输出，低电平有效，此信号是CPU对中断请求信号$INTR$ 的响应。 在响应过程中，CPU在$\\overline {INTA}$上连续输出两个负脉冲用作外部中断的中断向量码的读选通信号\n$HOLD$：总线保持请求信号输入，高电平有效。当某一总线主控设备要占用系统总线时，通过此引脚向CPU提出请求\n$HLDA$：总线保持响应信号输出，高电平有效。这是CPU对$HOLD$请求的响应信号。CPU收到$HOLD$信号后，就会对其做出响应，一方面会使CPU的所有三态输出的地址信号，数据信号和对应的控制信号变为高阻态；同时输出一个有效的$HLDA$，表示CPU已放弃对总线的控制。当CPU检测到$HOLD$信号变低后，就立即使$HLDA$变低，同时恢复对总线的控制\n${SS}_0$：系统状态信号输出\n$CLK$： 时钟信号输入引脚\n$Vcc$：5V电源输入引脚\n$GND$：地线\n8088/8086结构功能 外部结构 总线 总线定义 总线是传输信号或信息的公共路径，是遵循同一技术规范的连接与操作方式\n总线特点 公共性，可同时挂在多个设备\n总线分类 按传送的信息类型分类\n数据总线（Data Bus） 地址总线（Address Bus） 控制总线（Control Bus） 按总线的层次结构划分\n前端总线 系统总线 外设总线 总线结构 单总线结构，多总线结构\n总线基本功能 总线上任意时刻只能允许一对设备进行信息交换\n总线传输同步：协调通信双方的传输操作 总线仲裁控制：避免多个设备同时使用总线造成的冲突，确定总线上哪个设备可以占用总线传输数据 出错处理：检错和处理 总线驱动：增加驱动能力 总线的数据传送 1.同步定时的传输方式 用公共的时钟统一各部件数据发送和接收的时机 （严格按节拍进行，不需要握手信号，效率高）\n2.异步定时的传输方式 用控制和状态信号协调各部件数据发送和接收的时机（应答式）\n3.半同步定时的传输方式 允许不同速度的部件协同工作，主控设备可以根据从设备的状态延长总线 时钟周期，但总线周期一定是时钟周期的整数倍\n常用系统总线和外设总线标准 常用的系统总线标准包括：ISA 总线、PCI 总线、PCIE 总线、AGP 总线 常用的外设总线标准包括：SATA 总线、USB 总线、RS485 总线、IDE 总线、RS232 总线\n指令系统 指令：控制计算机完成指定操作并能够被计算机所识别的命令。 指令系统：一台计算机能够识别的所有指令的集合称为该机的指令系统\n指令格式： 操作码 操作数1，操作数2 操作数数量：零操作数指令，单操作数指令，双操作数指令\n指令中操作数类型：立即操作数，寄存器操作数，存储器操作数 寄存器操作数的指令执行速度\u0026gt; 立即数操作数\u0026gt; 存储器操作数\nCISC（Complex Instruction Set Computer），复杂指令系统计算机 RISC（Reduced Instruction Set Computer），精简指令系统计算机\n指令性指令是CPU中实际存在的可执行的语句。指示性语句是用于说明程序结构，变量等的语句，后者在编译过程中执行，编译完成后不再存在\n对于每个指令 指令码的含义 指令对操作数的要求 指令对标志位的影响 指令的功能 寻址方式 立即寻址（Immediate Addressing） 源操作数是立即数，立即数存放在代码段 MOV AX,3102H\n直接寻址（Direct Addressing） 操作数是存储器操作数，存放的地址由指令直接给出 MOV AX,[3102H]\n寄存器寻址（Register Addressing） 操作数为CPU内部寄存器 MOV AX,BX\n寄存器间接寻址（Register Indirect Addressing） 寄存器存放的不是数据本身，而是存放数据的偏移地址 寄存器间接寻址方式中 存放操作数偏移地址 的寄存器只允许是 $SI,DI,BX,BP$，它们也被称为间址寄存器\n选择$SI,DI,BX$作为间址寄存器时，操作数在数据段，段基址由$DS$决定 选择$BP$作为间址寄存器，则操作数在堆栈段，段基地址由$SS$决定 允许段重设 MOV AX,[BX] MOV AX,ES:[SI] 寄存器相对寻址 操作数在内存中的偏址地址由间址寄存器的值加上一个8位或16位的偏移量 MOV AX,DATA[BX] MOV AX,[BX+DATA]\n基址-变址寻址 基址-变址寻址方式由一个基址寄存器存的值和一个变址寄存器存的值 相加得到偏移地址\n不允许出现两个基址寄存器 不允许出现两个变址寄存器 MOV AX,[BX][SI] MOV AX,[SI][BX] MOV AX,[BX+SI] 基址-变址-相对寻址 所寻地址在内存中，偏移地址由一个基址寄存器、一个变址寄存器和数值偏移 量相加给出。其它规定同“基址-变址寻址” MOV AX,DATA[SI][BX] MOV AX,[BX+DATA][SI] MOV AX,[BX+SI+DATA] MOV AX,[BX+SI]DATA MOV AX,[BX]DATA[SI]\n隐含寻址 指令中隐含了部分固定的操作数的地址 MUL BL 把AL与BL相乘的乘积放入AX\n堆栈段 规定由SS指示堆栈段的段基址，堆栈的最低地址 堆栈指针SP始终指向堆栈的顶部（栈顶）。堆栈的最高地址叫栈底 栈的压入指令 PUSH src 栈的弹出指令 POP dest\n操作原则\n操作数为1个字，且只能是寄存器或存储器操作 存放数据从高地址向低地址方向增长 堆栈段位置由SS决定，SP指向栈顶 PUSH压入过程为先减SP再压数据 1 2 3 SP-2 -\u0026gt; SP src高8位-\u0026gt;[SP+1] src低8位-\u0026gt;[SP] POP弹出过程为先弹数据再加SP 1 2 3 [SP]-\u0026gt;dest低8位 [SP+1]-\u0026gt;dest高8位 SP+2-\u0026gt;SP 堆栈主要用途：保护现场\n数据传送指令 数据传送指令的执行均不影响标志位\n一般传送指令MOV MOV dest,src 对操作数要求：\n两个操作数字长相同 两个操作数不能同时为存储器操作数 不能用立即数直接给段寄存器赋值 两个操作数不能同时为段寄存器 IP和CS只作为MOV的源操作数，不做目标操作数 FLAGS整体不能作为操作数 两个操作数不能同时为存储器操作数，原因是存储器不能确定字长，是在存储器中取1个字节还是多个字节，没有限定\n堆栈操作指令PUSH和POP PUSH src POP dest 操作数为1个字，且只能是寄存器或存储器操作，不能是立即数\n交换指令XCHG 功能：交换源地址与目标地址中的内容 XCHG OPRD1,OPRD2\n输入/输出指令IN和OUT 功能：对输入/输出端口进行读写 输入指令IN用于从IO端口读数据到累加器AL（AX）中 输出指令OUT用于把累加器AL（AX）的内容写到IO端口 IO端口寻址\n直接寻址：指令中的IO端口地址为8位 1 2 IN AL/AX,port OUT port,AL/AX 寄存器间接寻址：端口地址为16位，由DX寄存器指定 1 2 IN AL/AX,DX OUT DX,AL/AX 操作原则\n只有AL或AX可以与I/O端口进行数据交换 IO端口地址可以是8位立即数指向的地址（即直接寻址）或由DX保存的16 位地址（即间接寻址） 当端口地址是16位时，只能用DX取给定端口地址 取偏移地址指令LEA （Load Effect Address） 功能：将存储器操作数的16位偏移地址送到指定寄存器 LEA reg16, mem 操作原则\n源操作数必须是存储器操作数，如： LEA BX, BUFFER LEA BX, [SI] 目标操作数必须是16位通用寄存器，最好使用间址寄存器（BX, SI, DI, BP） 源操作数必须是存储器操作数 算数运算指令 不带进位和带进位的加减指令 无符号和有符号的乘除指令\n算术运算指令的执行会影响状态标志位 乘法指令执行结果为相乘数的双倍字长 除法指令被除数是除数的双倍字长\n乘法指令 乘法指令采用隐含寻址，隐含了存放被乘数的累加器AL或AX，以及存放结果的AX或AX，DX\n无符号乘法指令 MUL BYTE PTR[BX] 有符号乘法指令 IMUL OPRD\n除法指令 DIV OPRD 如果$OPRD$是单字节数 意思是$AX/OPRD$ 结果：AL=商，AH=余数 如果$OPRD$是双字节数 意思是$DX,AX/OPRD$ 结果：AX=商，DX=余数\n算数移位指令 非循环移位 算数移位，逻辑移位 左移，右移\n循环移位 分为带进位移位和不带进位移位\n存储器 RAM（Random-Acess Memory）一般可分为SRAM（静态RAM），DRAM（动态RAM） ROM（Read Only Memory）一般可分为 掩膜ROM，一次性可写ROM，EPROM，EEPROM，闪速存储器Flash\n高位地址，选通芯片 低位地址，选芯片的读写单元\n译码，将输入的一组高位地址信号通过变换，产生一个有效的输出信号，用于选中某一个存储器芯片，从而确定了该存储器芯片在内存的地址范围\n全地址译码 用全部高位地址信号作为译码信号，使得存储器芯片的每一个单元都占据一个唯一的内存地址 部分地址译码 用部分高位地址信号作为译码信号，使得被选中存储器芯片占有几组不同的地址范围\nCache高速缓冲器 Cache高速缓冲存储器，Cache是构成内存储器的部件之一，设置Cahce的原因是内存的速度与处理器的工作速度不匹配\n微机中的存储器系统\nCache存储器系统 虚拟存储器系统 Cache存储系统 Cache存储系统主要有Cache高速缓冲器和主内存构成，有硬件系统负责管理 IO系统 输入输出系统 在计算机系统中，通常把处理器和主存储器之外的部分统称为输入/输出系统， 包括输入/输出设备、输入/输出接口和输入/输出软件\nIO接口 IO接口就是外设连接到系统总线上的一组逻辑电路的总称\nIO端口 端口是接口电路中用于缓存数据及控制信息的部件 CPU与I/O接口进行通信实际上是通过I/O接口内部的一组寄存器实现的，这些寄存器通常称为I/O端口（I/O Port）。它包括3种类型：数据端口、状态端口和命令（控制）端口\nIO端口编址方式 分为统一编址和独立编址\nI/O端口与内存单元统一编址，指令及控制信号统一，内存地址资源减少 I/O端口独立编址，内存地址资源充分利用，使用不同的控制信号，能够应用于端口的指令较少 输入接口需要具备数据控制能力，一般采用三态门接口，防止外设的输入影响数据总线，如74LS244\n输出接口需要具备数据锁存能力，一般采用锁存器接口，如74LS273\n基本输入输出方式 1.无条件传送方式\n2.查询方式\n3.中断方式\n4.直接存储器存取方式（DMA）\n中断 CPU执行程序中，由于发生了某种随机的事件(外部或内部)，引起CPU暂时 中断正在运行的程序，转去执行一段特殊的服务程序(称为中断服务程序或 中断处理程序)，以处理该事件，该事件处理完后又返回被中断的程序继续 执行，这一过程称为中断 中断响应过程 可屏蔽外部中断响应过程 通过两个连续的中断响应总线周期获取中断类型码 获取中断向量后并调用中断，服务程序\n内部中断响应过程 无中断响应总线周期 中断类型码固定或由指令（INT n）给出\n主要芯片 1.计数器8253 特殊引脚 CLK——时钟脉冲输入 GATE——门控信号输入 OUT——定时输出 编程方式 控制字直接写入控制寄存器 计数值写入对应计数器 工作方式 总览\n16位减法计数，计数值减为0时输出相应控制信号 输出控制信号的形式可通过软件设置 方式0——计数结束中断 软件启动，不自动重复计数 计时结束输出高电平，输出可以用作中断请求信号\n不自动重复计数是指 每写入一次计数初值只计数一个周期\n方式1——可重复触发的单稳态触发器 硬件启动，不自动重复计数 但是可以通过GATE重复触发计数，当GATE出现上升沿时，下一个CLK的下降沿开始计数 计数结束后，OUT端输出高电平\n方式2——频率发生器 既可以软件启动，也可以硬件启动 自动重复计数，OUT端输出N-1个时钟周期的高电平，1个时钟周期的低电平\n方式3——方波发生器 软硬件启动，自动重复计数 输出对称方波（连续方波） N为偶数，完全对称，N为奇数，正脉冲会长一点\n方式4——软件触发选通 软件启动，不自动重复计数 计数结束输出一个CLK宽度的低电平\n方式5——硬件触发选通 硬件启动，不自动重复计数 波形与方式4一致，计数结束输出一个CLK宽度的低电平\n小结 需要两个写脉冲——两次写操作\n第一次写脉冲写入控制字 第二次写脉冲写入计数初值 能输出连续波形的只有方式2和方式3\n2.可编程并行接口8255 三个端口 A口：支持0，1，2工作方式 B口：支持0，1工作方式 C口，支持0工作方式\n工作方式 方式0——基本输入输出方式 方式1——选通工作方式 方式1输出接口A\n$\\overline {OBF}$：接口输出缓冲器满信号，告诉外设可以从该端口读走信号 $\\overline {ACK}$：外设从端口取走数据，发出响应信号 外设取走信号后，发出$\\overline {ACK}$响应信号，同时使$\\overline {OBF}=1$，同时还会产生一个有效的$INTR$信号\n方式1输入接口A\n$\\overline {{STB}_A}$：外设写入 ${{IBF}_A}$：当输入缓冲器满后，接口发出的高电平有效信号\n方式2——双向传送方式 可以既作为输入口，又作为输出口 只有A口可以工作在此模式下，当A口工作在方式2时，B口可以工作在方式0或1\n控制字 方式控制字：用于确定3个端口的工作方式及数据传送方向 位控制字：仅用于C端口，可设置C口某位的初始状态（高低电平）\nD7=1，方式控制字 D7=0，位控制字\n3.DA转换芯片DAC0832 差动输出，双缓冲\n工作方式 单缓冲工作方式 双缓冲工作方式 4.AD转换芯片ADC0809 5.可编程中断控制器8259A 特殊引脚 $INT$：接CPU的中断请求引脚 $\\overline {INTA}$：接CPU的中断响应引脚 $A0$：8259A内部寄存器选择信号 $CAS0-CAS2$：多个8259级联引脚时使用，级联控制线 $\\overline {SP}$：在非缓冲模式下，用来指定8259A是从片还是主片，$\\overline {SP}$=1的8259是主片\n内部结构 工作过程 工作方式 中断优先方式与中断嵌套 （1）固定优先级方式 （2）循环优先级方式\n屏蔽中断源的方式 普通屏蔽方式：对IMR某位置1，则屏蔽该位对应的中断请求\n级联工作方式 （1）主片、从片有不同的地址 （2）主片、从片分别进行编程\n8259A的编程 初始化编程 初始化命令字ICW1（初始化字）：单片/多片级联、电平/边沿触发 初始化命令字ICW2（中断向量码）：给CPU提供中断向量 注意：例如，写入ICW1，端口地址为20H，写入ICW2时，端口地址为21H\n初始化命令字ICW3（级联控制字）：指出哪个引脚进行了级联 初始化命令字ICW4（中断结束方式字）：给出8259A结束中断处理的方式\n操作方式编程 操作命令字OCW1（中断屏蔽字）：某位为1则该引脚中断被屏蔽 操作命令字OCW2（中断结束和优先级循环）：指定优先级顺序和中断结束方式 操作命令字OCW3（屏蔽方式和状态读出控制字）：设置特殊屏蔽、查询方式\n","date":"2025-06-24T23:16:11+08:00","permalink":"https://NomadJoeviolet.github.io/p/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/","title":"微机原理"},{"content":"STM32F103C8T6 的 CAN 控制器和 CAN 收发器 1. CAN 控制器 STM32F103C8T6 内置 CAN 控制器：该芯片内置了 bxCAN（Basic Extended CAN）控制器，支持 CAN 2.0A 和 2.0B 协议 功能： 数据帧的封装与解析 错误检测与处理 总线仲裁 位定时与同步 引脚： CAN_RX（PA11）：接收数据 CAN_TX（PA12）：发送数据 2. CAN 收发器 STM32F103C8T6 没有内置 CAN 收发器：CAN 收发器负责将 CAN 控制器的逻辑信号转换为 CAN 总线的差分信号（CAN_H 和 CAN_L），反之亦然 需要外接 CAN 收发器：常见的 CAN 收发器包括 TJA1050、MCP2551 等 功能： 将 CAN 控制器的逻辑信号转换为差分信号 提供电气隔离（部分型号） 保护 CAN 控制器免受总线电气干扰 总结 CAN 控制器：STM32F103C8T6 内置了 CAN 控制器，支持 CAN 2.0A 和 2.0B 协议 CAN 收发器：STM32F103C8T6 没有内置 CAN 收发器，需外接（如 TJA1050 或 MCP2551） 连接方式 CAN 控制器：通过 CAN_RX（PA11）和 CAN_TX（PA12）与 CAN 收发器连接。 CAN 收发器：将 CAN_H 和 CAN_L 连接到 CAN 总线 示例电路 STM32F103C8T6： PA11（CAN_RX） → CAN 收发器的 RXD PA12（CAN_TX） → CAN 收发器的 TXD CAN 收发器（如 TJA1050）： CAN_H 和 CAN_L 连接到 CAN 总线 总结 STM32F103C8T6 内置 CAN 控制器，但需外接 CAN 收发器 才能实现完整的 CAN 通信功能 ","date":"2025-06-24T23:11:52+08:00","permalink":"https://NomadJoeviolet.github.io/p/can%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8Ccan%E6%94%B6%E5%8F%91%E5%99%A8/","title":"CAN控制器和CAN收发器"},{"content":"STM32H743-梳理ADC模数转换器在CubeMX上的配置_overrun behaviour-CSDN博客（写的很好，很详细）\nSTM32-HAL库-ADC学习 - 曲杨 - 博客园\nADC定义 模数转换器(Analog to Digital Converter,ADC) 模拟信号-\u0026gt;数字信号转换器\n通过对输入的模拟信号进行测量，将其分级转换为数字信号\nSTM32单片机中的ADC 一般计算采用一下逻辑方式进行转换\n1 2 3 4 5 6 7 if( V\u0026gt;V_ref_low \u0026amp;\u0026amp; V\u0026lt;V_ref_high ) { return (V-V_ref_low)/(V_ref_high-V_ref_low) * (2\u0026lt;\u0026lt;X-1); //归一化，再按照配置的x进行转换 } else { return erro ; } STM32单片机中的ADC，x一般是12，也可以是其他数值 一般情况下，参考电压为0V，参考高电压为3.3V\n分辨率与精度 分辨率与位数有关，精度与性能有关，位数越高，分辨率越高，性能越高，波动越小，精度越强 ADC位数为12位，则分辨率是1/4096\n使用时PLCK频率控制在36MHz以内，不然ADC模块的精度会大幅降低\nSTM32CubeMX配置 这里以STM32C8T6为例\nx即Resolution 12bits( 15ADC时钟周期 )（看芯片型号，有的需要配置） 数据选择右对齐，得到的数据就是转换后的值 Mode选择Independent mode Scan Conversion Mode（扫描转换模式），会采集ADC开启的所有通道，按顺序采集所有通道 Continuous Conversion Mode（连续转换模式），可以在使能ADC时自动开始采集，而非手动采集 Discontinuous Conversion Mode（间断采集模式），可以在一轮采集完成后暂停等待指令控制下一轮采集\nNumber Of Discontinuous Conversions（单次转换次数）此参数定义每次触发后ADC执行的转换次数，每次转换完都需要HAL_ADC_GetValue来获取值。 如果它设为2，且ADC1使能了通道1，2，5，7的话，那么第一次触发ADC1采样时，就会采样通道1与通道2的值，再一次触发ADC1采样的话，就会采样通道5与通道7值，如此类推。\nADC_Regular_ConversionMode 可以配置每个通道的采集顺序和采样时间\n代码使用 1.开始采集\n1 HAL_ADC_Start(\u0026amp;hadc2); 2.采集后转换\n1 HAL_ADC_PollForConversion(\u0026amp;hadc2,20);//地址，等待时间 关于多数据通道采集 ADC_value[1]对应rank_1的通道的值，第一次采集rank1通道 ADC_value[2]对应rank_2的通道的值，第一次采集rank2通道 rank指在ADC_Regular_ConversionMode中的rank设置\n1 2 3 4 5 6 7 for( int t = 1 ; t \u0026lt;= 10 ; ++ t ) { for( int i = 0 ; i \u0026lt; 2 ; ++ i ) { HAL_ADC_Start(\u0026amp;hadc2); HAL_ADC_PollForConversion(\u0026amp;hadc2,20);//采集后转换 AD_value[i] += HAL_ADC_GetValue(\u0026amp;hadc2) ;//采集十次，平均值处理 } } 检测 1 2 3 if(HAL_IS_BIT_SET( HAL_ADC_GetState(\u0026amp;hadc2),HAL_ADC_STATE_REG_EOC) ) {//检测是否正常采集 ADC_value += HAL_ADC_GetValue(\u0026amp;hadc2); } 关于Number Of Discontinuous Conversions 在STM32CubeMX中，Number Of Discontinuous Conversions（单次转换次数）是ADC（模数转换器）的一个配置选项，主要用于控制ADC在**非连续采样模式（Discontinuous Mode）**下的转换行为。以下是详细解释和使用方法：\n1. 功能含义 作用：\n当ADC配置为非连续模式（Discontinuous Mode）时，此参数定义每次触发后ADC执行的转换次数。 例如，设置为3，则每次触发ADC后，会自动连续完成3次转换（无需额外触发信号）。 若设置为1，则每次触发仅执行1次转换（等同于标准单次模式）。 应用场景：\n适用于需要分组采样的场景，例如： 周期性触发ADC，但每次触发需采集多个通道的数据。 降低CPU干预频率（通过一次触发完成多次转换）。 2. 配置步骤（STM32CubeMX） 启用Discontinuous Mode： 在ADC配置界面，勾选 Discontinuous Mode（通常在Parameter Settings选项卡中）。 此时，Number Of Discontinuous Conversions选项会生效。 设置转换次数： 输入需要的转换次数（取值范围取决于型号，通常为1~8）。 该值必须 ≤ 总启用通道数（例如，若启用5个通道，最多可设置为5）。 配置触发源： 选择触发方式（如定时器触发、外部引脚触发等）。 每次触发信号到来时，ADC会自动完成设定的转换次数。 3. 工作流程示例 硬件环境： ADC通道：CH0、CH1、CH2 配置：Discontinuous Mode + Number Of Discontinuous Conversions = 2 行为： 触发信号到来（如定时器溢出）。 ADC自动连续转换2个通道（例如CH0→CH1）。 转换完成后产生中断/DMA请求。 下次触发时，继续从下一个通道开始（CH2→CH0，依此类推）。 在该配置下（Discontinuous Mode + Number Of Discontinuous Conversions = 2），每次触发后ADC会连续转换2个通道（例如CH0→CH1），因此你需要调用两次 HAL_ADC_GetValue(\u0026amp;hadc2) 来分别读取这两个通道的转换结果。以下是具体说明和注意事项：\n1. 数据读取方式 方法一：轮询模式（Polling） 每次触发后，需手动读取两次ADC值：\n1 2 3 4 5 6 7 8 HAL_ADC_Start(\u0026amp;hadc2); // 启动ADC（或通过触发信号启动） //开启一次，采集两次 if (HAL_ADC_PollForConversion(\u0026amp;hadc2, timeout) == HAL_OK) {//采集后第一次转换 uint32_t ch0_value = HAL_ADC_GetValue(\u0026amp;hadc2); // 读取CH0结果 } if (HAL_ADC_PollForConversion(\u0026amp;hadc2, timeout) == HAL_OK) {//采集后第二次转换 uint32_t ch1_value = HAL_ADC_GetValue(\u0026amp;hadc2); // 读取CH1结果 } 注意：每次调用 HAL_ADC_GetValue() 会返回最后一次完成的转换结果，因此需按顺序读取。 方法二：中断模式（Interrupt） 在ADC转换完成中断中读取：\n1 2 3 4 5 6 void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) { if (hadc == \u0026amp;hadc2) { uint32_t ch0_value = HAL_ADC_GetValue(\u0026amp;hadc2); // 第一次转换结果（CH0） uint32_t ch1_value = HAL_ADC_GetValue(\u0026amp;hadc2); // 第二次转换结果（CH1） } } 关键点：在中断回调中需连续读取两次，顺序由ADC的Rank配置决定。 方法三：DMA模式（推荐） 若启用DMA，ADC会自动将多次转换结果存入指定数组，无需手动调用 HAL_ADC_GetValue()：\n1 2 uint32_t adc_results[2]; // 存储2次转换结果 HAL_ADC_Start_DMA(\u0026amp;hadc2, adc_results, 2); // 启动DMA传输 结果存储：\nadc_results[0] → CH0的值，adc_results[1] → CH1的值（顺序由Rank决定）。 4. 注意事项 与连续模式（Continuous Mode）的区别： 连续模式：ADC无限循环转换所有启用通道，无需触发。 非连续模式：需外部触发，且每次触发仅转换设定的次数。 DMA配合： 建议启用DMA，以高效搬运多组转换结果（尤其是高频触发场景）。 DMA缓冲区大小需 ≥ 转换次数 × 通道数。 通道顺序： 转换顺序由Rank（在ADC配置中定义）决定，而非通道编号。 总结 Number Of Discontinuous Conversions 是ADC非连续模式下每次触发的转换次数。 关键配置：启用Discontinuous Mode → 设置转换次数 → 配置触发源。 优势：灵活控制采样节奏，减少CPU负担，适合分组采样需求。 ","date":"2025-06-24T22:44:59+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32adc%E6%A8%A1%E5%9D%97/","title":"STM32————ADC模块"},{"content":"视频推荐： 【c/cpp程序编译过程】https://www.bilibili.com/video/BV1JM4m127y7?vd_source=5a0790755035f26a67935abfbfcdfd5b\n文章推荐： 详解C/C++代码的预处理、编译、汇编、链接全过程 - 知乎 (zhihu.com) C++ 预编译，编译，汇编，链接 - Suarezz - 博客园 (cnblogs.com) C/C++编译链接 - 知乎 (zhihu.com)(进阶)\n关于编译器与不同系统的文件 一般编译器可以分为前端和后端，前端主要负责 语义分析，后端主要负责 代码生成\nLinux macOS Windows 可执行文件 .out或/ .out或/ .exe 目标文件 .o .o .obj 静态库 .a .a .lib 动态库 .so .dylib .dll GCC负责编译，生成各类库和目标文件，然后调用外部链接器进行链接然后生成可执行文件\nLLVM同时有编译器和链接器（例如：armclang和armlink）\n运行程序的运行阶段，是让加载器将最后生成的可执行文件放到内存中\nGCC、GNU、gcc与g++ GNU：一个操作系统，具体内容不重要，感兴趣可以参考：\nGCC、GNU到底啥意思？_一只杨阳羊的博客-CSDN博客​blog.csdn.net/qq_43617936/article/details/104504992\nGCC：GNU Compiler Collection（GNU编译器集合）的缩写，可以理解为一组GNU操作系统中的编译器集合，可以用于编译C、C++、Java、Go、Fortan、Pascal、Objective-C等语言 gcc：GCC（编译器集合）中的GNU C Compiler(C 编译器) g++：GCC（编译器集合）中的GNU C++ Compiler(C++ 编译器) 简单来说，gcc调用了GCC中的C Compiler，而g++调用了GCC中的C++ Compiler 对于 *.c 和 *.cpp 文件，gcc分别当作 c 和 cpp文件编译，而g++则统一当作cpp文件编译\n![[Pasted image 20241126223616.png]]\nGDB(gdb) GDB（gdb）全称“GNU symbolic debugger”，是 Linux 下常用的程序调试器。 为了能够使用 gdb 调试，需要在代码编译的时候加上-g，如\n1 g++ -g -o test test.cpp 常用指令 ![[Pasted image 20241027090624.png]]\n编译过程 ![[Pasted image 20241027085312.png]]\n![[Pasted image 20241027092346.png]]\nstep1. 预处理 ![[Pasted image 20241026230159.png]] 命令：\n1 g++ -E test.cpp -o test.i 作用：\n去掉注释 预处理指令替换（ifndef ，宏定义等） include 导入的头文件替换 预处理实例对比 .cpp 文件 ![[Pasted image 20241026230758.png]]\n预处理后的 .i 文件\n还有替换的\n1 #include\u0026lt;iostream\u0026gt; 被省略了，替换的内容有3万多行\n翻到最下面查看\n![[Pasted image 20241026230952.png]]\n具体解释 预处理，顾名思义就是编译前的一些准备工作\n预编译把一些#define的宏定义完成文本替换，然后将#include的文件里的内容复制到.cpp文件里，如果.h文件里还有.h文件，就递归展开。在预处理这一步，代码注释直接被忽略，不会进入到后续的处理中，所以注释在程序中不会执行\nstep2. 编译阶段 ![[Pasted image 20241027001928.png]]\n命令：\n1 g++ -S test.i -o test.s 对 .i 文件进行编译 也可以对 .cpp 文件进行编译\n1 g++ -S test.cpp -o test.s 作用：\n翻译成汇编语言 检查代码报错 具体解释 编译只是把我们写的代码转为汇编代码，它的工作是检查词法和语法规则，所以，如果程序没有词法或则语法错误，那么不管逻辑是怎样错误的，都不会报错。\n编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程\nstep3. 汇编阶段 ![[Pasted image 20241027002224.png]] 命令：\n1 g++ -c test.s -o test.o 作用：\n将 .s 文件，汇编成二进制文件（二进制文件不可执行） step4. 链接阶段 ![[Pasted image 20241027002618.png]]\n命令：\n1 gcc test.o -o test 作用：\n将目标文件 .o和库文件链接 具体解释：C语言代码经过编译以后，并没有生成最终的可执行文件（.exe 文件），而是生成了一种叫做目标文件（Object File）的中间文件（或者说临时文件）。目标文件也是二进制形式的，它和可执行文件的格式是一样的。对于 Visual C++，目标文件的后缀是.obj；对于 GCC，目标文件的后缀是.o。这就是一开始所说的编译完一堆.obj和.o文件的来源。\n目标文件经过链接（Link）以后才能变成可执行文件。既然目标文件和可执行文件的格式是一样的，为什么还要再链接一次呢，因为编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。链接（Link）其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做链接器（Linker）。\nC++程序编译的时候其实只识别.cpp文件。每个cpp文件都会分别编译一次，生成一个.o或者.obj文件。这个时候，链接器除了将目标文件和系统组件组合起来，还需要将编译器生成的多个.o或者.obj文件组合起来。\ng++自动链接了系统组件，我们只需要把自定义函数的目标文件与main.o链接即可\n链接的其他过程 C/C++编译链接 - 知乎 (zhihu.com)(进阶)\n合并段 ![[Pasted image 20241027092742.png]]\n调整段偏移 ![[Pasted image 20241027092757.png]]\n多文件g++编译指令 ![[Pasted image 20241027222011.png]]\n1 g++ src/cmake_leran.cpp tools/hello.cpp -I includes -o cmake_leran src/cmake_leran.cpp tools/hello.cpp 是在指定当前目录下哪些源文件需要编译 -I includes 是 库文件所在的目录\n![[Pasted image 20241126230718.png]]\n杂谈 关于库文件 ![[Pasted image 20241126224636.png]]\n![[Pasted image 20241126224803.png]]\n关于可执行文件 ![[Pasted image 20241126225616.png]]\n关于C与C++联合生成可执行文件 在C++中，告诉编译器以C的标准进行编译 C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //关键字 extern \u0026#34;C\u0026#34; //example #include\u0026lt;iostream\u0026gt; using namespace std; extern \u0026#34;C\u0026#34; void func() { //用 extern\u0026#34;C\u0026#34;修饰 } extern \u0026#34;C\u0026#34; void func(int v) {//用 extern\u0026#34;C\u0026#34;修饰 } int main() {\treturn 0; } 1 2 3 4 5 6 7 8 9 10 11 12 //如果当前文件为cpp文件，就会告诉编译器按C语言方式编译和链接 //如果不是cpp文件，则会被略过 #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif \u0026lt;被调用内容\u0026gt; #ifdef __cplusplus } #enddif 如果编译器是 C++ 编译器，__cplusplus 宏会被定义，extern \u0026ldquo;C\u0026rdquo; 块将会被包含，这告诉编译器按照 C 语言的规则来处理函数名称，而不是 C++ 的规则。这样做的目的是为了保持与已经存在的 C 代码库的兼容性，特别是当使用 C++ 编写新代码时。\n__cplusplus宏定义作用 在 C++ 中，__cplusplus 是一个预定义的宏，它用于确定正在使用的 C++ 标准的版本。这个宏的存在使得 C++ 代码能够以标准 C 形式输出，即以 C 的形式被调用，这对于跨平台编程和与 C 语言的兼容性至关重要。\n宏的定义和使用 __cplusplus 宏通常在编写涉及 C 和 C++ 混合编程的头文件时使用。当 C++ 代码需要被 C 编译器调用时，使用这个宏可以确保 C++ 中的名称修饰（name mangling）不会发生，从而允许 C 代码安全地调用 C++ 函数。例如：\n1 2 3 4 5 6 7 8 9 #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif // C++ 函数声明 #ifdef __cplusplus } #endif ![[Pasted image 20241213212614.png]]\n在这个例子中，如果编译器是 C++ 编译器，__cplusplus 宏会被定义，extern \u0026ldquo;C\u0026rdquo; 块将会被包含，这告诉编译器按照 C 语言的规则来处理函数名称，而不是 C++ 的规则。这样做的目的是为了保持与已经存在的 C 代码库的兼容性，特别是当使用 C++ 编写新代码时。\n宏的值 __cplusplus 宏的值表示 C++ 标准的版本，例如：\nC++98 标准：199711L C++11 标准：201103L C++14 标准：201402L C++17 标准：201703L C++20 标准：202002L 不同的编译器，如 GCC、Clang 或 Visual C++，都遵循这些标准，并在编译时定义相应的 __cplusplus 值。这个宏的值可以用来确定编译器支持的 C++ 版本，从而在编写代码时做出相应的兼容性处理。 实际应用 在实际应用中，__cplusplus 宏确保了 C++ 代码可以与 C 代码无缝集成。例如，如果有一个用 C 语言编写的库，它的头文件是 f.h，产生的库文件是 f.lib，那么在 C++ 中使用这个库文件时，需要这样写：\n1 2 3 extern \u0026#34;C\u0026#34; { #include \u0026#34;f.h\u0026#34; } 这样，C++ 编译器就会知道如何正确地链接和调用 C 语言编写的函数。如果没有使用 __cplusplus 宏，可能会出现链接错误，因为 C++ 编译器和 C 编译器对函数名称的处理方式不同。\n总结来说，__cplusplus 宏是 C++ 语言为了兼容 C 语言和支持混合编程而提供的一个重要工具。它允许开发者在保持 C++ 功能的同时，确保代码能够在不同的编程环境中正确运行。\n关于extern关键字 C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客 ![[Pasted image 20241213212619.png]]\n","date":"2025-06-24T22:30:22+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","title":"C\u0026C++ 编译过程"},{"content":"STM32 hal库串口空闲中断最新用法 - STM32团队 ST意法半导体中文论坛\n（非常详细）【STM32】 DMA原理，步骤超细详解，一文看懂DMA-CSDN博客\nSTM32CubeIDE HAL库DMA与UART不定长数据接收实现：空闲中断详解-物联沃-IOTWORD物联网\nSTM32 hal库串口空闲中断最新用法_stm32hal库串口空闲中断-CSDN博客\nHAL库 串口空闲中断+DMA接收不定长数据 详解及踩坑_hal库串口空闲中断-CSDN博客\n（写的非常好，非常有助于提升底层理解）（stm32之HAL库）UART工作在DMA模式要打开串口中断吗？_hal uart dma-CSDN博客\nDMA DMA，全称为Direct Memory Access，直接内存访问，本质是将传输数据从一个内存空间搬运至另一个内存空间，可以用来提供外设和内存，内存和外设之间的高速数据传输\n在HAL库中直接使用的HAL_UART_Transmit_DMA，HAL_UART_Receive_DMA，HAL_UARTEx_ReceiveToIdle_DMA等都有中断的参与，需要在Cube中开启中断\n对具体底层原理和DMA模式实现底层与中断模式底层实现区别感兴趣可参考以下博客 （stm32之HAL库）UART工作在DMA模式要打开串口中断吗？_hal uart dma-CSDN博客\nUSART发送 在普通的轮询USART中，CPU一直在等待外设发送数据，外设每发送一帧数据，CPU就从内存中移动一帧数据到外设的寄存器\n在中断的USART中，外设每从寄存器中发送一帧数据，就会触发一次发送数据寄存器空中断，使CPU回来将一帧数据从内存搬运至外设的寄存器中\nUSART的DMA发送 没有DMA的话，CPU会作为数据发送的中转站，而使用DMA的话，整个数据传输过程不需要CPU的参与，由DMA代理执行，DMA负责将内存数据搬运至外设的传输寄存器\n在整个数据发送过半时会触发一个传输过半中断，所有数据传输完成后会调用传输完成中断回调函数（HAL_UART_TxCpltCallback）\n1 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) HAL_UART_Transmit_DMA的传输完成中断回调函数HAL_UART_TxCpltCallback以及传输过半中断回调函数HAL_UART_TxHalfCpltCallback\nDMA发送注意事项 在传输的过程中，当传输一半的数据后，半传输标志(HTIF)被置1，当设置了允许半传输中断位(HTIE)时，将产生一个中断请求。在数据传输结束后，传输完成标志(TCIF)被置1，当设置了允许传输完成中断位 (TCIE)时，将产生一个中断请求\n会触发的三个中断，传输完成中断，传输过半中断，错误中断 在stm32f1xx_hal_uart.c的HAL_UART_Transmit_DMA函数中可以查看到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) { . . . /* Set the UART DMA transfer complete callback */ huart-\u0026gt;hdmatx-\u0026gt;XferCpltCallback = UART_DMATransmitCplt; /* Set the UART DMA Half transfer complete callback */ huart-\u0026gt;hdmatx-\u0026gt;XferHalfCpltCallback = UART_DMATxHalfCplt; /* Set the DMA error callback */ huart-\u0026gt;hdmatx-\u0026gt;XferErrorCallback = UART_DMAError; . . . } } USART接收 在普通的轮询USART中，CPU一直在询问外设是否接收完数据，外设接收一帧数据，该位数据由CPU从外设的数据接收寄存器运进内存，CPU再次询问外设是否接收完数据，再运，直至整个数据接收完成\n而在中断USART中，外设每接收一帧数据，触发一次数据接收寄存器非空中断，CPU过来将数据从寄存器搬运至内存，所有数据接收完成后，会调用接收完成中断回调函数（HAL_UART_RxCpltCallback）\nUSART的DMA接收 没有DMA的话，CPU会作为数据转运的中转站，而使用DMA的话，整个数据转运过程不需要CPU的参与，由DMA代理执行\n在整个数据接收过半时会触发一个传输过半中断，所有数据接收完成后会调用传输完成中断回调函数（HAL_UART_RxCpltCallback）\n1 HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) HAL_UART_Receive_DMA的接收完成中断回调函数HAL_UART_RxCpltCallback以及接收过半中断回调函数HAL_UART_RxHalfCpltCallback\nDMA接收注意事项 同DMA发送，类比即可\nHAL库USART使用DMA 如果USART串口的DMA出现错误，会调用HAL_UART_ErrorCallback\nDMA发送 1 HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) 会触发中断\nHAL_UART_TxCpltCallback HAL_UART_TxHalfCpltCallback DMA接收 1 HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size) 会触发的中断\nHAL_UART_RxCpltCallback HAL_UART_RxHalfCpltCallback DMA模式 normal模式 以接收为例 单次接收，接收至数据上限，完成整个固定数据接收后停止，再次接收需要再次开启HAL_UART_Receive_DMA ，需要软件显式重启，触发接收过半和接收完成中断\nsummary：单次传输，完成后停止，需要软件显式重启，接收过半和接收完成中断\ncircular模式 以接收为例 无限循环，接收至数据上限一半，触发接收过半中断，接受至数据上限，触发接收完成中断，同时会硬件自动重启，接收完成中断会调用``\nsummary：无限循环，硬件自动重启，接收过半和接收完成中断\n空闲中断 空闲中断定义 空闲中断（IDLE Interrupt） 是UART通信中的一种特殊中断类型，它在检测到UART接收线路连续空闲超过1个字节传输时间时触发的中断。\u0026ldquo;空闲\u0026quot;指线路保持逻辑1状态（高电平），线上无数据传输\nHAL库自带的空闲中断实现 使用的是HAL库提供的拓展函数，同时都需要在Cube中开启中断\n1 2 //在阻塞模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen, uint32_t Timeout); 1 2 //在中断模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 1 2 //在DMA模式下接收一定数量的数据，直到接收到预期数量的数据或发生空闲事件。 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 1 2 //使用空闲中断时的接收回调函数 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size); 在触发空闲中断，接收完成中断都会调用HAL_UARTEx_RxEventCallback回调函数，需要注意的是在F103c8t6单片机上，使用HAL_UARTEx_ReceiveToIdle_DMA时，接收过半中断也会去调用该回调函数\n接收过半中断的处理 STM32CubeIDE HAL库DMA与UART不定长数据接收实现：空闲中断详解-物联沃-IOTWORD物联网 HAL_UARTEx_RecceiveToIdle_DMA会调用UART_Start_Receive_DMA(huart, pData, Size)函数，该函数会把DMA中断传输完成，半传输，传输错误全部开启\n1 __HAL_DMA_ENABLE_IT(DMA_IT_TC | DMA_IT_HC | DMA_IT_TE) UART_Start_Receive_DMA(huart, pData, Size) 设置接收数组缓存到达数组一半时会执行下面的回调函数\n1 2 /* Set the UART DMA Half transfer complete callback */ huart-\u0026gt;hdmarx-\u0026gt;XferHalfCpltCallback = UART_DMARxHalfCplt; 而UART_DMARxHalfCplt会调用HAL_UARTEx_RxEventCallback\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma) { UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)-\u0026gt;Parent; /* Initialize type of RxEvent that correspond to RxEvent callback execution; In this case, Rx Event type is Half Transfer */ huart-\u0026gt;RxEventType = HAL_UART_RXEVENT_HT; /* Check current reception Mode : If Reception till IDLE event has been selected : use Rx Event callback */ if (huart-\u0026gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE) { #if (USE_HAL_UART_REGISTER_CALLBACKS == 1) /*Call registered Rx Event callback*/ huart-\u0026gt;RxEventCallback(huart, huart-\u0026gt;RxXferSize / 2U); #else /*Call legacy weak Rx Event callback*/ HAL_UARTEx_RxEventCallback(huart, huart-\u0026gt;RxXferSize / 2U); #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ } else { /* In other cases : use Rx Half Complete callback */ #if (USE_HAL_UART_REGISTER_CALLBACKS == 1) /*Call registered Rx Half complete callback*/ huart-\u0026gt;RxHalfCpltCallback(huart); #else /*Call legacy weak Rx Half complete callback*/ HAL_UART_RxHalfCpltCallback(huart); #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ } } 为了避免接收过半中断的调用，需要使用下面的语句\n1 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx,DMA_IT_HT);//关闭dma接收半满中断函数，这样我们在接收一组数据时就不会触发半满中断，dma就可以正常接收一组数据 另外在UART_DMAReceiveCplt函数中也调用了HAL_UARTEx_RxEventCallback函数\n1 static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma) DMA+空闲中断的实现接收不定长数据 方式1 自定义DMA+空闲中断\n前置内容 需要自己写的宏定义\n1 2 #define __HAL_DMA_SET_COUNTERT(__HANDLE__,__COUNTER__) ((__HANDLE__)-\u0026gt;Instance-\u0026gt;CNDTR = (uint16_t)(__COUNTER__)) //重新设定计数值 1 2 //用法 __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); 用到的宏定义\n1 2 __HAL_DMA_GET_COUNTER(huart-\u0026gt;hdmarx) //获取剩余未传输的计数值 用到的关于中断的操作\n1 2 3 4 5 6 7 8 9 10 __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx)//关闭DMA __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx)//开启DMA //清除空闲标志位 __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1) //开启空闲中断 __HAL_UART_ENABLE_IT(\u0026amp;huart1 , UART_IT_IDLE ) //关闭空闲中断 __HAL_UART_DISABLE_IT(\u0026amp;huart1, UART_IT_IDLE ) 代码实现 1 2 3 #define rxBufferLen 10 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; 1 2 3 4 5 void UART_InitDMAReceive() { __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1);//清除空闲中断标志位 __HAL_UART_ENABLE_IT(\u0026amp;huart1 , UART_IT_IDLE );//使能空闲中断 HAL_UART_Receive_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//开启DMA接收 } 需要关闭DMA才能重设DMA的COUNTER\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //自定义的DMA空闲中断回调函数 void UART_DMAIdleCallback(UART_HandleTypeDef *huart) { if (huart == \u0026amp;huart1 ) { __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//失能DMA int datalen = rxBufferLen - __HAL_DMA_GET_COUNTER(huart-\u0026gt;hdmarx); for(int i=0;i\u0026lt;datalen;i++) { char temp = rxBuffer[i]; txBuffer[i] = (temp \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; temp \u0026lt;= \u0026#39;z\u0026#39;) ? temp-32:temp; } HAL_UART_Transmit_DMA(\u0026amp;huart1,(uint8_t*)txBuffer,datalen); __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen);//重置DMA计数 __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//使能DMA } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void USART1_IRQHandler(void) { /* USER CODE BEGIN USART1_IRQn 0 */ /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(\u0026amp;huart1); /* USER CODE BEGIN USART1_IRQn 1 */ //触发空闲中断后，会进入中断请求处理函数 if (__HAL_UART_GET_FLAG(\u0026amp;huart1 , UART_FLAG_IDLE) != RESET ) {//在此判断是否为空闲中断 __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1);//清除空闲中断标志位 __HAL_UART_DISABLE_IT(\u0026amp;huart1, UART_IT_IDLE);//失能空闲中断 UART_DMAIdleCallback(\u0026amp;huart1);//调用自定义中断回调函数 __HAL_UART_ENABLE_IT(\u0026amp;huart1, UART_IT_IDLE);//使能空闲中断 } /* USER CODE END USART1_IRQn 1 */ } 关于normal和circular在方式1的空闲中断实现的区别 normal模式 在上述空闲中断实现中，如果使用normal模式，需要注意接收的数据一定不能超过rxBufferLen，一旦超过，DMA接收就会终止\n执行流程是，触发空闲中断，进入USART1_IRQHandler，再进入自定义空闲中断，在里面重新设置了DMA的计数值（指针也会重新设置，重新指向rxBuffer[0]），最开始开启的HAL_UART_Receive_DMA始终没有接收完 完整的数据，就不会关闭，一直接收\n但如果接收的数据超过rxBufferLen，会触发接收过半和接收完成中断（对应回调函数没使用，约等于空函数），同时HAL_UART_Receive_DMA会结束，需要软件显式重启\n例如：rxBufferlen=10，发送12345678910，会回复1234567891，随后DMA终止，再发送数据无回复\ncircular模式 在上述空闲中断实现中，如果使用circular模式，则接收的数据可以超过rxBufferLen，超过后，DMA接收会自动重启\n执行流程是，触发空闲中断，进入USART1_IRQHandler，再进入自定义空闲中断，在里面重新设置了DMA的计数值（指针也会重新设置，重新指向rxBuffer[0]），就算接收数据超过rxBufferLen，HAL_UART_Receive_DMA也会重新启动\n但是需要注意，如果达到rxBufferLen,会触发接收过半和接收完成中断，然后硬件重启，重新回到rxBufferLen[0]的位置读数据，直至发生空闲中断\n例如：rxBufferlen=10，发送12345678910，会回复0，随后DMA仍然正常工作\n方式2 使用HAL库提供的拓展空闲中断，使用normal模式\n该方式下的空闲中断回调函数为HAL_UARTEx_RxEventCallback ，需要注意接收过半中断也会调用HAL_UARTEx_RxEventCallback的问题，在每次开启HAL_UARTEx_ReceiveToIdle_DMA后都需要关闭接收过半中断\n1 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx,DMA_IT_HT);//关闭dma接收半满中断函数，这样我们在接收一组数据时就不会触发半满中断，dma就可以正常接收一组数据 当接收数据超过rxBufferLen时，接收完成中断函数会调用HAL_UARTEx_RxEventCallback回调函数，然后重新开启接收\n例如：rxBufferLen=10，接收12345678910，发送1234567891（就是因为接收完成中断导致），后面DMA空闲中断接收正常开启\n代码实现 1 2 3 4 void Init_IdleDMA(void) {//初始化，开启DMA空闲中断接收 HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } 1 2 3 4 5 6 7 8 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//normal模式，接受一次后需要重新开启 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } } 关于normal和circular在方式2下的空闲中断实现的区别 normal模式 方式2中，在数据接收过半，接收完成，空闲时会触发对应中断，最后调用HAL_UARTEx_RxEventCallback回调函数，在回调函数中软件显式重启HAL_UARTEx_ReceiveToIdle_DMA\ncircular模式 方式2中，若使用circular模式，则数据会一直积累，到达rxBufferLen时，会硬件重启，同时也会有数据接收过半，接收完成，空闲时会触发对应中断，最后调用HAL_UARTEx_RxEventCallback回调函数\n例如： (1)关闭接收过半中断 rxBufferLen=10，接收123，发送123， 再接收456，发送123456， 再接收78910，会先发送1234567891（接收完成），再发送0（空闲中断）， 再接收111213，发送0111213\n(2)未关闭接收过半中断 rxBufferLen=10，接收123，发送123， 再接收123，会先发送12312（接收过半中断），再发送123123空闲中断， 再接收12345，会先发送1231231234（接收完成中断），再发送5空闲中断\n方式3 使用HAL库提供的空闲中断，但是使用circular模式实现\n在circuar要想实现一帧一帧不定长数据的接收主要需要考虑的就是如何实现在接收完一帧后让DMA的计数值重置\n实现原理 关闭 要实现DMA计数值的重置，需要使用HAL_UART_DMAStop(\u0026amp;huart1)函数将DMA关闭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart) { uint32_t dmarequest = 0x00U; /* The Lock is not implemented on this API to allow the user application to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback(): when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() */ /* Stop UART DMA Tx request if ongoing */ dmarequest = HAL_IS_BIT_SET(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAT); if ((huart-\u0026gt;gState == HAL_UART_STATE_BUSY_TX) \u0026amp;\u0026amp; dmarequest) { ATOMIC_CLEAR_BIT(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAT); /* Abort the UART DMA Tx channel */ if (huart-\u0026gt;hdmatx != NULL) { HAL_DMA_Abort(huart-\u0026gt;hdmatx); } UART_EndTxTransfer(huart); } /* Stop UART DMA Rx request if ongoing */ dmarequest = HAL_IS_BIT_SET(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAR); if ((huart-\u0026gt;RxState == HAL_UART_STATE_BUSY_RX) \u0026amp;\u0026amp; dmarequest) { ATOMIC_CLEAR_BIT(huart-\u0026gt;Instance-\u0026gt;CR3, USART_CR3_DMAR); /* Abort the UART DMA Rx channel */ if (huart-\u0026gt;hdmarx != NULL) { HAL_DMA_Abort(huart-\u0026gt;hdmarx); } UART_EndRxTransfer(huart); } return HAL_OK; } 其中会调用HAL_DMA_Abort(huart-\u0026gt;hdmatx)，但都不会重置DMA的计数值\n开启 在关闭DMA后，需要HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen)重新开启DMA以及空闲中断\n在HAL_UARTEx_ReceiveToIdle_DMA中，会进行判断if (huart-\u0026gt;RxState == HAL_UART_STATE_READY) ，判断RxState是否为HAL_UART_STATE_READY，如果是，则说明uart没有开启，但是是在预备状态，随后会去调用UART_Start_Receive_DMA(huart, pData, Size)开启uart以及DMA\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { HAL_StatusTypeDef status; /* Check that a Rx process is not already ongoing */ if (huart-\u0026gt;RxState == HAL_UART_STATE_READY) { if ((pData == NULL) || (Size == 0U)) { return HAL_ERROR; } /* Set Reception type to reception till IDLE Event*/ huart-\u0026gt;ReceptionType = HAL_UART_RECEPTION_TOIDLE; huart-\u0026gt;RxEventType = HAL_UART_RXEVENT_TC; status = UART_Start_Receive_DMA(huart, pData, Size); /* Check Rx process has been successfully started */ if (huart-\u0026gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE) { __HAL_UART_CLEAR_IDLEFLAG(huart); ATOMIC_SET_BIT(huart-\u0026gt;Instance-\u0026gt;CR1, USART_CR1_IDLEIE); } else { /* In case of errors already pending when reception is started, Interrupts may have already been raised and lead to reception abortion. (Overrun error for instance). In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */ status = HAL_ERROR; } return status; } else { return HAL_BUSY; } } 在UART_Start_Receive_DMA中会将uart的RxState设置为HAL_UART_STATE_BUSY_RX，中间还会去调用HAL_DMA_Start_IT\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { uint32_t *tmp; huart-\u0026gt;pRxBuffPtr = pData; huart-\u0026gt;RxXferSize = Size; huart-\u0026gt;ErrorCode = HAL_UART_ERROR_NONE; huart-\u0026gt;RxState = HAL_UART_STATE_BUSY_RX; ...... HAL_DMA_Start_IT(huart-\u0026gt;hdmarx, (uint32_t)\u0026amp;huart-\u0026gt;Instance-\u0026gt;DR, *(uint32_t *)tmp, Size); ...... } 在HAL_DMA_Start_IT会调用DMA_SetConfig去对DMA计数值等进行重置\n1 2 3 4 5 6 7 HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength) { ...... /* Configure the source, destination address and the data length \u0026amp; clear flags*/ DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength); ...... } 原理总结 1.HAL_UARTEx_ReceiveToIdle_DMA如果判断出huart-\u0026gt;RxState == HAL_UART_STATE_READY会调用UART_Start_Receive_DMA\n2.UART_Start_Receive_DMA会调用HAL_DMA_Start_IT，同时会将RxState修改为BUSY huart-\u0026gt;RxState = HAL_UART_STATE_BUSY_RX\n3.HAL_DMA_Start_IT会调用DMA_SetConfig进行DMA计数值等的重置\n而使用HAL_UART_DMAStop可以保证在回调函数处理数据时停止DMA接收，保证数据不会被覆盖，同时可以将huart-\u0026gt;RxState状态设置为HAL_UART_STATE_READY，随后再次开启DMA空闲中断接收就能重置DMA计数值\n从而实现非定长数据的接收\n代码实现 同样注意，需要关闭接收过半中断\n1 2 3 #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; 1 2 3 4 5 //初始化 void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } 1 2 3 4 5 6 7 8 9 10 11 12 //回调函数 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { HAL_UART_DMAStop(\u0026amp;huart1);//不会改变DMA的计数值 memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); memset(txBuffer, 0, Size); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//如果是normal模式，接受一次后需要重新开启，如果关闭了DMA，也需要重新启动 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 } } 实验检验 我们设置cnt_i去记录AL_UART_DMAStop(\u0026amp;huart1)前后以及HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen)前后的DMA计数值变化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {//接收完成和接收过半，空闲中断都会调用该中断回调函数 if (huart == \u0026amp;huart1 ) { uint32_t cnt_1 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); HAL_UART_DMAStop(\u0026amp;huart1);//不会改变DMA的计数值 uint32_t cnt_2 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); memset(txBuffer, 0, Size); HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen);//如果是normal模式，接受一次后需要重新开启，如果关闭了DMA，也需要重新启动 __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭f103板子DMA的接收过半中断 uint32_t cnt_3 = __HAL_DMA_GET_COUNTER(huart1.hdmarx); sprintf(txBuffer, \u0026#34;\\ncnt_1=%d cnt_2=%d cnt_3=%d\\n\u0026#34;, cnt_1,cnt_2,cnt_3); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, sizeof(txBuffer), 10); } } 实验结果\n1 2 3 4 输入：123456789101112131415161718192021 输出：123456789101112131415161718192021 cnt_1=479 cnt_2=479 cnt_3=512 证明我们在重启DMA空闲中断时实现了DMA计数值重置\n方式4 再仔细想一想，在circuar要想实现一帧一帧不定长数据的接收主要需要考虑的就是如何实现在接收完一帧后让DMA的计数值重置，也就是说没有必要为此使用HAL_UART_DMAStop再重启DMA空闲中断接收\n如何优化呢，结合方式1的实现就可以得到答案\n1 2 3 __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define __HAL_DMA_SET_COUNTERT(__HANDLE__,__COUNTER__) ((__HANDLE__)-\u0026gt;Instance-\u0026gt;CNDTR = (uint16_t)(__COUNTER__)) //重新设定计数值 #define rxBufferLen 512 uint8_t rxBuffer[rxBufferLen]; uint8_t txBuffer[rxBufferLen]; void Init_IdleDMA(void) { HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rxBuffer, rxBufferLen); __HAL_DMA_DISABLE_IT(\u0026amp;hdma_usart1_rx, DMA_IT_HT);//关闭DMA的接收过半中断 } void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) { if (huart == \u0026amp;huart1 ) { __HAL_DMA_DISABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER __HAL_DMA_SET_COUNTERT(huart-\u0026gt;hdmarx,rxBufferLen); memcpy(txBuffer, rxBuffer, Size); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)txBuffer, Size,10); __HAL_DMA_ENABLE(huart-\u0026gt;hdmarx);//需要关闭DMA才能重设DMA的COUNTER } } ","date":"2025-06-18T19:52:33+08:00","permalink":"https://NomadJoeviolet.github.io/p/stm32dma%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD/","title":"STM32——DMA使用与空闲中断"},{"content":"基于菜鸟教程写的个人笔记\nstatic定义 static是C/C++中常用的修饰符，控制变量的存储方式和可见性\nstatic-前置-空间分配 在函数内部定义的变量，当程序执行到其定义处时没编译器会为它在栈上分配空间，函数在栈上分配的空间再次函数结束时会释放掉\n如果想将函数中此变量的值保存至下一次调用：\n（1）将该变量定义为全局变量，但带来许多缺点，例如破坏了此变量的访问范围（在此函数中定义的变量，不仅仅只受此函数的控制）\n（2）使用static关键词修饰\n静态数据的存储 全局（静态）存储区：分为 DATA 段和 BSS 段 DATA 段（全局初始化区）存放初始化的全局变量和静态变量 BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量 程序运行结束时自动释放 BSS段在程序执行前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。\n在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。\n在C/C++中static的作用 General （1）在修饰变量时，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放 （2）static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能被其他文件调用，即使是extern外部声明也不可以 （3）static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0 （4）static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用 （5）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰 （6）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）\n关于静态变量与普通变量 静态全局变量 （1）静态变量都在全局数据区分配内存 （2）未经初始化的静态全局变量会被程序自动初始化为0 （3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的\n（1）全局变量和全局静态变量的区别\n1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。 2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。 静态局部变量 （1）该变量在全局数据区分配内存 （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，及以后的函数调用不会再进行初始化 （3）静态局部变量一般在声明处初始化，如果没有显示初始化，会被程序自动初始化为0 （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束\n一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。\nstatic用法 在C++中 static在类中的作用： 被 static 修饰的变量、被 static 修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变\n在 C++ 中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存\n静态成员的定义或声明要加个关键 static。静态成员可以通过双冒号来使用 即 \u0026lt;类名\u0026gt;::\u0026lt;静态成员名\u0026gt;\n结论：\n不能通过类名来调用类的非静态成员函数，可以通过类的对象调用静态成员函数和非静态成员函数 类的静态成员函数不可以使用类的非静态函数 在类的非静态成员函数中可以使用类的静态成员（函数，变量），非静态成员函数在调用静态成员变量时，静态成员变量必须在使用前初始化 因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员函数必须在类实例化对象后才有内存空间\n类的静态成员变量必须先初始化再使用 一些解释： 1）静态方法能不能引用非静态资源？不能，实例化对象的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。 2）静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。 3）非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是实例化对象之后才产生的，那么属于类的内容它都认识\nSummary:\n（1）静态成员函数中不能调用非静态成员 （2）非静态成员函数中可以调用静态成员。因为静态成员属于类本身，在类的对象产生之前就已经存在了，所以在非静态成员函数中是可以调用静态成员的 （3）静态成员变量使用前必须先初始化(如 int MyClass::m_nNumber = 0;)，否则会在 linker 时出错 静态数据成员 （1）静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变 （2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间 （3）静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0 （4）静态数据成员既可以通过对象名引用，也可以通过类名引用 静态成员函数 （1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员 （2）非静态成员函数有 this 指针，而静态成员函数没有 this 指针 （3）静态成员函数主要用来f访问静态数据成员而不能访问非静态成员 ","date":"2025-01-13T16:24:31+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-statiic/","title":"C\u0026C++ Statiic"},{"content":"【关于C和C++混合编程中编译和链接的问题】https://www.bilibili.com/video/BV1Zm4y1E7nm?vd_source=5a0790755035f26a67935abfbfcdfd5b\nextern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园\nC++\u0026ndash;名字修饰_c++的函数名修饰是在哪个阶段进行的-CSDN博客\nC/C++ 函数签名与名字修饰（符号修饰）-CSDN博客\nC/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n符号修饰 在C/C++中，一个程序要运行起来，需要经历以下几个阶段：预处理、编译、汇编、链接。\n名字修饰（Name Mangling）是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过一定算法，重新修饰为一个全局唯一的名称。\n由于C++和C的名字修饰规则不同（不同操作系统下的编译器的名字修饰方式也会不同），导致C++可以支持函数重载，而C不支持函数重载\n可以简单理解，c++中支持函数重载，c语言不支持函数重载，这造成了c++和c语言的函数名解析不同（名字修饰/符号修饰）。c语言函数名就是函数名，c++的函数名是函数名+参数组合起来的。\nC与C++符号修饰的实例 extern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园 （直接copy自该博客）\n比如，函数void func(double a) 在C和C++中的编译阶段函数名称会被解析成什么呢？\n在C语言中，由于没有名称修饰，所以在编译时函数名称仍然是func，不会因为参数类型或数量而改变。\n在C++中，由于名称修饰的存在，函数名称在编译阶段会被编译器转换成一个包含函数原型信息的唯一标识符。通常会涉及函数返回类型、参数类型以及参数数量。以GCC(GNU Compiler Collection)为例，func(double a)会被转换成_Z4funcd ，这里：\n_Z：是GCC用来表示修饰名称的前缀 4：表示函数名称func的的字符数 d：是double类型的编码 因此，用c++的方式去寻找c语言的符号是无法寻找到的。extern \u0026quot;C\u0026quot;为何可以做到？\nextern \u0026quot;C\u0026quot;的作用就是修改了符号表的生成方式，将c++符号的生成方式换成了c的生成方式。\n即 c库中生成的符号是c编译器的符号， 因此c语言可以直接链接。而c++程序需要使用extern \u0026quot;C\u0026quot;让编译器使用c的符号命名方式去进行链接，这样才能找到对应的符号。\nextern \u0026ldquo;C\u0026rdquo; C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n看这一篇就够了 看实例\ncpp调用c，cpp编译时会有C++的符号修饰，导致链接C库的函数找不到，需要用extern \u0026ldquo;C\u0026quot;告诉g++编译器以C语言的风格进行编译 c调用cpp（不涉及C++的类和成员函数），设计一个C的接口，接口的实现在cpp中，接口函数内部去使用C++的特性 c中调用c++成员函数，需要一个接口函数 ","date":"2025-01-13T16:17:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E7%9A%84%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0/","title":"C++ 的名字修饰（符号修饰）"},{"content":"作用 如果一个变量被const修饰，那么它的值就不能再被改变\nconst的优点 （1）可以保护被修饰的东西，防止意外修改，增强程序的健壮性\n（2）编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高\nconst修饰局部变量 1 2 const int n=5; int const n=5; 这两种写法是一样的，都是表示变量n的值不能被改变了，需要注意的是，用const修饰变量时，一定要给变脸初始化，否则之后就不能再进行赋值\nconst 修饰指针 1.常量指针 常量指针是指针指向的内容是常量，可以有一下两种定义方式\n1 2 const int * n; int const * n; 注意： （1）常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的\n（2）常量指针指向的值不能改变，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址\n2.指针常量 指针常量是指指针本身是个常量，不能再指向其他的地址\n1 int *const n; 需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改\n3.指向常量的常指针 指向常量的常指针是以上两种的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值\n1 const int* const p; const修饰函数的参数 1.防止修改指针指向的内容\n1 void StringCopy(char *strDestination, const char *strSource); 其中 strSource 是输入参数，strDestination 是输出参数 给 strSource 加上 const 修饰后，如果函数体内的语句试图改动 strSource 的内容，编译器将指出错误\n2.防止修改指针指向的地址\n1 void swap ( int * const p1 , int * const p2 ) 指针p1和指针p2指向的地址都不能修改\n","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-const/","title":"C\u0026C++ const"},{"content":"基于菜鸟教程写的个人笔记\n存储类 存储类定义了C程序中变量/函数的存储位置，生命周期，作用域\nauto register static extern 1.auto存储类 auto存储类是所有局部变量默认的存储类 定义在函数中的变量都默认为auto存储类 它们在函数开始时被创建，在函数结束时被销毁\n1 2 3 4 { int month ; auto int month ; } auto只能修饰局部变量\n2.register存储类 register存储类用于定义存储在寄存器上，而不是RAM中的局部变量 register存储类定义存储在寄存器，变量访问速度更快，不能直接地取地址（因为它存储在RAM中）\n1 2 3 { register int miles ； } 寄存器一般用于需要快速访问的变量\n3.static存储类 （1）static作用于局部变量 a.使局部变量在程序生命周期内都存在，不需要每次进入和离开其作用域（函数）的时候创建（重新分配内存）和销毁。 b.使用static修饰局部变量可以在函数调用之间保持局部变量的值\nstatic作用的变量，静态局部变量存储在静态（全局）存储区\n（2）static作用于全局变量 当static修饰全局变量时，会使变量的作用域限制在声明它的文件内\n（3）静态变量的特性 静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; /* 函数声明 */ void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main() { while (count--) { func1(); } return 0; } void func1(void) { /* \u0026#39;thingy\u0026#39; 是 \u0026#39;func1\u0026#39; 的局部变量 - 只初始化一次 * 每次调用函数 \u0026#39;func1\u0026#39; \u0026#39;thingy\u0026#39; 值不会被重置。 */ static int thingy=5; thingy++; printf(\u0026#34; thingy 为 %d ， count 为 %d\\n\u0026#34;, thingy, count); } 实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置\n当上面的代码被编译和执行时，它会产生下列结果：\n1 2 3 4 5 6 7 8 9 10 thingy 为 6 ， count 为 9 thingy 为 7 ， count 为 8 thingy 为 8 ， count 为 7 thingy 为 9 ， count 为 6 thingy 为 10 ， count 为 5 thingy 为 11 ， count 为 4 thingy 为 12 ， count 为 3 thingy 为 13 ， count 为 2 thingy 为 14 ， count 为 1 thingy 为 15 ， count 为 0 4.extern存储类 extern存储类用于定义在其他文件中声明的全局变量或函数 当使用extern关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义\nextern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n第一个文件 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; extern int count; void write_extern(void) { printf(\u0026#34;count is %d\\n\u0026#34;, count); } 结果 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：\n1 $ gcc main.c support.c 这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：\n1 count is 5 ","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/c%E5%AD%98%E5%82%A8%E7%B1%BB/","title":"C存储类"}]