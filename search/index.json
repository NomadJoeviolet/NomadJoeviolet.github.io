[{"content":"基于菜鸟教程写的个人笔记\nstatic定义 static是C/C++中常用的修饰符，控制变量的存储方式和可见性\nstatic-前置-空间分配 在函数内部定义的变量，当程序执行到其定义处时没编译器会为它在栈上分配空间，函数在栈上分配的空间再次函数结束时会释放掉\n如果想将函数中此变量的值保存至下一次调用：\n（1）将该变量定义为全局变量，但带来许多缺点，例如破坏了此变量的访问范围（在此函数中定义的变量，不仅仅只受此函数的控制）\n（2）使用static关键词修饰\n静态数据的存储 全局（静态）存储区：分为 DATA 段和 BSS 段 DATA 段（全局初始化区）存放初始化的全局变量和静态变量 BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量 程序运行结束时自动释放 BSS段在程序执行前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。\n在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。\n在C/C++中static的作用 General （1）在修饰变量时，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放 （2）static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能被其他文件调用，即使是extern外部声明也不可以 （3）static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0 （4）static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用 （5）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰 （6）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）\n关于静态变量与普通变量 静态全局变量 （1）静态变量都在全局数据区分配内存 （2）未经初始化的静态全局变量会被程序自动初始化为0 （3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的\n（1）全局变量和全局静态变量的区别\n1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。 2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。 静态局部变量 （1）该变量在全局数据区分配内存 （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，及以后的函数调用不会再进行初始化 （3）静态局部变量一般在声明处初始化，如果没有显示初始化，会被程序自动初始化为0 （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束\n一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。\nstatic用法 在C++中 static在类中的作用： 被 static 修饰的变量、被 static 修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变\n在 C++ 中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存\n静态成员的定义或声明要加个关键 static。静态成员可以通过双冒号来使用 即 \u0026lt;类名\u0026gt;::\u0026lt;静态成员名\u0026gt;\n结论：\n不能通过类名来调用类的非静态成员函数，可以通过类的对象调用静态成员函数和非静态成员函数 类的静态成员函数不可以使用类的非静态函数 在类的非静态成员函数中可以使用类的静态成员（函数，变量），非静态成员函数在调用静态成员变量时，静态成员变量必须在使用前初始化 因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员函数必须在类实例化对象后才有内存空间\n类的静态成员变量必须先初始化再使用 一些解释： 1）静态方法能不能引用非静态资源？不能，实例化对象的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。 2）静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。 3）非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是实例化对象之后才产生的，那么属于类的内容它都认识\nSummary:\n（1）静态成员函数中不能调用非静态成员 （2）非静态成员函数中可以调用静态成员。因为静态成员属于类本身，在类的对象产生之前就已经存在了，所以在非静态成员函数中是可以调用静态成员的 （3）静态成员变量使用前必须先初始化(如 int MyClass::m_nNumber = 0;)，否则会在 linker 时出错 静态数据成员 （1）静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变 （2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间 （3）静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0 （4）静态数据成员既可以通过对象名引用，也可以通过类名引用 静态成员函数 （1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员 （2）非静态成员函数有 this 指针，而静态成员函数没有 this 指针 （3）静态成员函数主要用来f访问静态数据成员而不能访问非静态成员 ","date":"2025-01-13T16:24:31+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-statiic/","title":"C\u0026C++ Statiic"},{"content":"【关于C和C++混合编程中编译和链接的问题】https://www.bilibili.com/video/BV1Zm4y1E7nm?vd_source=5a0790755035f26a67935abfbfcdfd5b extern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园 C++\u0026ndash;名字修饰_c++的函数名修饰是在哪个阶段进行的-CSDN博客 C/C++ 函数签名与名字修饰（符号修饰）-CSDN博客 C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n符号修饰 在C/C++中，一个程序要运行起来，需要经历以下几个阶段：预处理、编译、汇编、链接。\n名字修饰（Name Mangling）是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过一定算法，重新修饰为一个全局唯一的名称。\n由于C++和C的名字修饰规则不同（不同操作系统下的编译器的名字修饰方式也会不同），导致C++可以支持函数重载，而C不支持函数重载\n可以简单理解，c++中支持函数重载，c语言不支持函数重载，这造成了c++和c语言的函数名解析不同（名字修饰/符号修饰）。c语言函数名就是函数名，c++的函数名是函数名+参数组合起来的。\nC与C++符号修饰的实例 extern \u0026ldquo;c\u0026quot;的用法：c与c++的互相调用 - 青山牧云人 - 博客园 （直接copy自该博客）\n比如，函数void func(double a) 在C和C++中的编译阶段函数名称会被解析成什么呢？\n在C语言中，由于没有名称修饰，所以在编译时函数名称仍然是func，不会因为参数类型或数量而改变。\n在C++中，由于名称修饰的存在，函数名称在编译阶段会被编译器转换成一个包含函数原型信息的唯一标识符。通常会涉及函数返回类型、参数类型以及参数数量。以GCC(GNU Compiler Collection)为例，func(double a)会被转换成_Z4funcd ，这里：\n_Z：是GCC用来表示修饰名称的前缀 4：表示函数名称func的的字符数 d：是double类型的编码 因此，用c++的方式去寻找c语言的符号是无法寻找到的。extern \u0026quot;C\u0026quot;为何可以做到？\nextern \u0026quot;C\u0026quot;的作用就是修改了符号表的生成方式，将c++符号的生成方式换成了c的生成方式。\n即 c库中生成的符号是c编译器的符号， 因此c语言可以直接链接。而c++程序需要使用extern \u0026quot;C\u0026quot;让编译器使用c的符号命名方式去进行链接，这样才能找到对应的符号。\nextern \u0026ldquo;C\u0026rdquo; C/C++中的 extern 和extern“C“关键字的理解和使用（对比两者的异同）_c extern c-CSDN博客\n看这一篇就够了 看实例\ncpp调用c，cpp编译时会有C++的符号修饰，导致链接C库的函数找不到，需要用extern \u0026ldquo;C\u0026quot;告诉g++编译器以C语言的风格进行编译 c调用cpp（不涉及C++的类和成员函数），设计一个C的接口，接口的实现在cpp中，接口函数内部去使用C++的特性 c中调用c++成员函数，需要一个接口函数 ","date":"2025-01-13T16:17:46+08:00","permalink":"https://NomadJoeviolet.github.io/p/c-%E7%9A%84%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0/","title":"C++ 的名字修饰（符号修饰）"},{"content":"作用 如果一个变量被const修饰，那么它的值就不能再被改变\nconst的优点 （1）可以保护被修饰的东西，防止意外修改，增强程序的健壮性\n（2）编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高\nconst修饰局部变量 1 2 const int n=5; int const n=5; 这两种写法是一样的，都是表示变量n的值不能被改变了，需要注意的是，用const修饰变量时，一定要给变脸初始化，否则之后就不能再进行赋值\nconst 修饰指针 1.常量指针 常量指针是指针指向的内容是常量，可以有一下两种定义方式\n1 2 const int * n; int const * n; 注意： （1）常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的\n（2）常量指针指向的值不能改变，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址\n2.指针常量 指针常量是指指针本身是个常量，不能再指向其他的地址\n1 int *const n; 需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改\n3.指向常量的常指针 指向常量的常指针是以上两种的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值\n1 const int* const p; const修饰函数的参数 1.防止修改指针指向的内容\n1 void StringCopy(char *strDestination, const char *strSource); 其中 strSource 是输入参数，strDestination 是输出参数 给 strSource 加上 const 修饰后，如果函数体内的语句试图改动 strSource 的内容，编译器将指出错误\n2.防止修改指针指向的地址\n1 void swap ( int * const p1 , int * const p2 ) 指针p1和指针p2指向的地址都不能修改\n","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/cc-const/","title":"C\u0026C++ const"},{"content":"基于菜鸟教程写的个人笔记\n存储类 存储类定义了C程序中变量/函数的存储位置，生命周期，作用域\nauto register static extern 1.auto存储类 auto存储类是所有局部变量默认的存储类 定义在函数中的变量都默认为auto存储类 它们在函数开始时被创建，在函数结束时被销毁\n1 2 3 4 { int month ; auto int month ; } auto只能修饰局部变量\n2.register存储类 register存储类用于定义存储在寄存器上，而不是RAM中的局部变量 register存储类定义存储在寄存器，变量访问速度更快，不能直接地取地址（因为它存储在RAM中）\n1 2 3 { register int miles ； } 寄存器一般用于需要快速访问的变量\n3.static存储类 （1）static作用于局部变量 a.使局部变量在程序生命周期内都存在，不需要每次进入和离开其作用域（函数）的时候创建（重新分配内存）和销毁。 b.使用static修饰局部变量可以在函数调用之间保持局部变量的值\nstatic作用的变量，静态局部变量存储在静态（全局）存储区\n（2）static作用于全局变量 当static修饰全局变量时，会使变量的作用域限制在声明它的文件内\n（3）静态变量的特性 静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置\n代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; /* 函数声明 */ void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main() { while (count--) { func1(); } return 0; } void func1(void) { /* \u0026#39;thingy\u0026#39; 是 \u0026#39;func1\u0026#39; 的局部变量 - 只初始化一次 * 每次调用函数 \u0026#39;func1\u0026#39; \u0026#39;thingy\u0026#39; 值不会被重置。 */ static int thingy=5; thingy++; printf(\u0026#34; thingy 为 %d ， count 为 %d\\n\u0026#34;, thingy, count); } 实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置\n当上面的代码被编译和执行时，它会产生下列结果：\n1 2 3 4 5 6 7 8 9 10 thingy 为 6 ， count 为 9 thingy 为 7 ， count 为 8 thingy 为 8 ， count 为 7 thingy 为 9 ， count 为 6 thingy 为 10 ， count 为 5 thingy 为 11 ， count 为 4 thingy 为 12 ， count 为 3 thingy 为 13 ， count 为 2 thingy 为 14 ， count 为 1 thingy 为 15 ， count 为 0 4.extern存储类 extern存储类用于定义在其他文件中声明的全局变量或函数 当使用extern关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义\nextern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n第一个文件 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; extern int count; void write_extern(void) { printf(\u0026#34;count is %d\\n\u0026#34;, count); } 结果 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：\n1 $ gcc main.c support.c 这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：\n1 count is 5 ","date":"2025-01-08T18:08:42+08:00","permalink":"https://NomadJoeviolet.github.io/p/c%E5%AD%98%E5%82%A8%E7%B1%BB/","title":"C存储类"}]